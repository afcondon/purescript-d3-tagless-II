-- | Auto-generated module containing code snippets
-- | Generated by scripts/generate-code-snippets.js
-- | DO NOT EDIT THIS FILE MANUALLY
module CodeSnippets where

import Prelude

-- | Snippet metadata
type SnippetInfo =
  { name :: String
  , content :: String
  , source :: String
  , lines :: String
  }

-- ** Snippet Content Constants **

snippet_threeLittleCircles_content :: String
snippet_threeLittleCircles_content = "module D3.Viz.TreeAPI.ThreeLittleCircles where\n\nimport Prelude\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, fill)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree, joinData)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Three Little Circles - The classic D3 example using declarative tree API\n-- |\n-- | This demonstrates:\n-- | - Data joins with the declarative API\n-- | - Template functions that customize each element based on datum\n-- | - Polymorphic attributes (functions of datum)\n\ntype CircleData =\n  { x :: Number\n  , y :: Number\n  , r :: Number\n  , color :: String\n  }\n\ncircleData :: Array CircleData\ncircleData =\n  [ { x: 100.0, y: 100.0, r: 40.0, color: \"red\" }\n  , { x: 200.0, y: 100.0, r: 30.0, color: \"green\" }\n  , { x: 300.0, y: 100.0, r: 50.0, color: \"blue\" }\n  ]\n\nthreeLittleCircles :: Effect Unit\nthreeLittleCircles = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define the tree with a DATA JOIN\n  -- Note: The datum type is CircleData because we're using joinData with CircleData\n  let tree :: Tree CircleData\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num 400.0\n          , height $ num 200.0\n          , viewBox 0.0 0.0 400.0 200.0\n          , attr \"id\" $ text \"three-circles-svg\"\n          , attr \"class\" $ text \"tree-api-example\"\n          ]\n          `T.withChild`\n            -- Here's the magic: joinData creates N copies of the template\n            (joinData \"circles\" \"circle\" circleData $ \\d ->\n              T.elem Circle\n                [ cx $ num d.x\n                , cy $ num d.y\n                , r $ num d.r\n                , fill $ text d.color\n                ])\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Three Little Circles (Declarative API) ===\"\n    Console.log \"\"\n    Console.log \"Structure: SVG → [Circle × 3] (via joinData)\"\n    Console.log \"\"\n\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"circles\" selections of\n      Just _ -> Console.log \"✓ Circles collection created (3 circles via data join)\"\n      Nothing -> Console.log \"✗ Missing circles collection\"\n\n    Console.log \"\"\n    Console.log \"Expected result:\"\n    Console.log \"  - Red circle (r=40) at (100, 100)\"\n    Console.log \"  - Green circle (r=30) at (200, 100)\"\n    Console.log \"  - Blue circle (r=50) at (300, 100)\"\n    Console.log \"\"\n    Console.log \"Check the browser to verify!\"\n"

snippet_threeLittleCirclesTransition_content :: String
snippet_threeLittleCirclesTransition_content = "module D3.Viz.TreeAPI.ThreeLittleCirclesTransition where\n\n-- | Three Little Circles with Transitions using Tree API\n-- |\n-- | Demonstrates:\n-- | - Initial render with Tree API\n-- | - Re-rendering with updated data\n-- | - Transitions between states\n-- | - Click handlers with onClick behavior\n-- |\n-- | Based on Mike Bostock's \"Three Little Circles\" (https://bost.ocks.org/mike/circles/)\n\nimport Prelude\n\nimport Data.Int (toNumber)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Console (log)\nimport Effect.Ref as Ref\nimport PSD3.Expr.Friendly (num, text, attr, from, fromStr, viewBox, width, height, cx, cy, r, fill, opacity)\nimport PSD3.Internal.Capabilities.Selection (renderTree, select)\nimport PSD3.Internal.Capabilities.Transition (withTransition)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SBoundOwns, SEmpty)\nimport PSD3.Internal.Transition.Types (transitionWith)\nimport PSD3.AST as T\nimport Partial.Unsafe (unsafePartial, unsafeCrashWith)\nimport Web.DOM.Element (Element)\n\n-- | Circle data type\ntype CircleData = Int\n\n-- | State of the circles visualization\ndata CircleState = StateGreen | StateRGB\n\nderive instance Eq CircleState\n\ninstance Show CircleState where\n  show StateGreen = \"StateGreen\"\n  show StateRGB = \"StateRGB\"\n\n-- | Toggle between states\ntoggleState :: CircleState -> CircleState\ntoggleState StateGreen = StateRGB\ntoggleState StateRGB = StateRGB -- Stay in RGB state once shown\n\n-- | Transition circles to a given state\ntransitionToState :: D3v2Selection_ SBoundOwns Element CircleData -> CircleState -> Effect Unit\ntransitionToState circlesSel state = runD3v2M do\n  let\n    transitionConfig = transitionWith\n      { duration: Milliseconds 1000.0\n      , delay: Nothing\n      , staggerDelay: Nothing\n      , easing: Nothing\n      }\n\n  case state of\n    StateGreen ->\n      -- Three green circles in a row\n      withTransition transitionConfig circlesSel\n        [ fromStr \"fill\" colorFnGreen\n        , from \"cx\" cxFnGreen\n        , from \"cy\" cyFnGreen\n        , r $ num 40.0\n        , attr \"fill-opacity\" $ num 1.0 -- Fully opaque\n        ]\n    StateRGB ->\n      withTransition transitionConfig circlesSel\n        [ fromStr \"fill\" colorFnRGB\n        , from \"cx\" cxFnRGB\n        , from \"cy\" cyFnRGB\n        , r $ num 60.0 -- Increased from 30 to 60 for proper overlap and color mixing\n        , attr \"fill-opacity\" $ num 0.5 -- Semi-transparent for color mixing\n        ]\n\n  pure unit\n  where\n  -- Green state: all circles green\n  colorFnGreen :: CircleData -> String\n  colorFnGreen _ = \"#00ff00\"\n\n  cxFnGreen :: CircleData -> Number\n  cxFnGreen d = 100.0 + toNumber d * 100.0 -- Spaced 100px apart\n\n  cyFnGreen :: CircleData -> Number\n  cyFnGreen _ = 125.0 -- All at same height\n\n  -- RGB colors: Red, Green, Blue\n  colorFnRGB :: CircleData -> String\n  colorFnRGB d = case d of\n    0 -> \"#ff0000\" -- Red\n    1 -> \"#00ff00\" -- Green\n    _ -> \"#0000ff\" -- Blue\n\n  -- RGB X positions: form triangle with overlap\n  cxFnRGB :: CircleData -> Number\n  cxFnRGB d = case d of\n    0 -> 150.0 -- Red on left\n    1 -> 250.0 -- Green on right\n    _ -> 200.0 -- Blue in center\n\n  -- RGB Y positions: red/green at bottom, blue at top\n  cyFnRGB :: CircleData -> Number\n  cyFnRGB d = case d of\n    0 -> 130.0 -- Red at bottom\n    1 -> 130.0 -- Green at bottom\n    _ -> 70.0 -- Blue at top\n\n-- | Draw three circles with visible initial state\nthreeLittleCirclesTransition :: String -> Effect { stateRef :: Ref.Ref CircleState, circlesSel :: D3v2Selection_ SBoundOwns Element CircleData }\nthreeLittleCirclesTransition selector = do\n  -- Create state ref - start with green circles\n  stateRef <- Ref.new StateGreen\n\n  runD3v2M do\n    container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n    -- Initial tree: three green circles in a row\n    let\n      initialTree :: T.Tree CircleData\n      initialTree =\n        T.named SVG \"svg\"\n          [ width $ num 400.0\n          , height $ num 250.0\n          , viewBox 0.0 0.0 400.0 250.0\n          , attr \"id\" $ text \"three-circles-transition-tree\"\n          ]\n          `T.withChild`\n            ( T.joinData \"circles\" \"circle\" [ 0, 1, 2 ] $ \\d ->\n                T.elem Circle\n                  [ fill $ text \"#00ff00\" -- Start green\n                  , cx $ num (100.0 + toNumber d * 100.0) -- Three in a row\n                  , cy $ num 125.0\n                  , r $ num 40.0\n                  , attr \"fill-opacity\" $ num 1.0\n                  ]\n            )\n\n    -- Render initial state\n    selections <- renderTree container initialTree\n\n    -- Extract the circles selection for transitions\n    let\n      circlesSel = case Map.lookup \"circles\" selections of\n        Just sel -> sel\n        Nothing -> unsafePartial $ unsafeCrashWith \"circles selection not found\"\n\n    -- Return the state ref and selection so external button can trigger transition\n    pure { stateRef, circlesSel }\n\n-- | Helper to create transition function for a button\n-- | Call this after threeLittleCirclesTransition to get a function to attach to a button\ncreateTransitionTrigger :: { stateRef :: Ref.Ref CircleState, circlesSel :: D3v2Selection_ SBoundOwns Element CircleData } -> Effect Unit\ncreateTransitionTrigger { stateRef, circlesSel } = do\n  currentState <- Ref.read stateRef\n  let newState = toggleState currentState\n  Ref.write newState stateRef\n  log $ \"Transitioning to: \" <> show newState\n  transitionToState circlesSel newState\n"

snippet_simpleTree_content :: String
snippet_simpleTree_content = "module D3.Viz.TreeAPI.SimpleTreeExample where\n\nimport Prelude\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, textAnchor, textContent)\nimport Web.DOM.Element (Element)\n\n-- | Simple test: Render a basic tree structure without data joins\n-- |\n-- | Structure:\n-- | ```\n-- | div#viz\n-- |   └─ svg (800x600)\n-- |      └─ g.container\n-- |         ├─ circle (at 100, 100)\n-- |         └─ text (at 100, 130)\n-- | ```\ntestSimpleTree :: Effect Unit\ntestSimpleTree = runD3v2M do\n  -- Select the container\n  container <- select \"#viz\" :: _  (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define the tree structure using the declarative API\n  let tree :: Tree Unit\n      tree =\n        T.named SVG \"svg\" [width $ num 800.0, height $ num 600.0, viewBox 0.0 0.0 800.0 600.0, attr \"id\" $ text \"simple-tree-svg\"]\n          `T.withChild`\n            (T.named Group \"container\" [attr \"class\" $ text \"container\"]\n              `T.withChildren`\n                [ T.named Circle \"circle\" [cx $ num 100.0, cy $ num 100.0, r $ num 20.0, fill $ text \"steelblue\"]\n                , T.named Text \"text\" [x $ num 100.0, y $ num 130.0, textContent $ text \"Hello Tree API!\", textAnchor $ text \"middle\"]\n                ])\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  -- Log what we got back\n  liftEffect do\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ Found svg selection\"\n      Nothing -> Console.log \"✗ Missing svg selection\"\n\n    case Map.lookup \"container\" selections of\n      Just _ -> Console.log \"✓ Found container selection\"\n      Nothing -> Console.log \"✗ Missing container selection\"\n\n    case Map.lookup \"circle\" selections of\n      Just _ -> Console.log \"✓ Found circle selection\"\n      Nothing -> Console.log \"✗ Missing circle selection\"\n\n    case Map.lookup \"text\" selections of\n      Just _ -> Console.log \"✓ Found text selection\"\n      Nothing -> Console.log \"✗ Missing text selection\"\n\n    Console.log \"Simple tree rendering complete!\"\n"

snippet_nestedElements_content :: String
snippet_nestedElements_content = "module D3.Viz.TreeAPI.NestedElementsExample where\n\nimport Prelude\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, fontSize, textAnchor, textContent, transform)\nimport Web.DOM.Element (Element)\n\n-- | Test: Multi-level nested elements (Group → Circle + Text)\n-- |\n-- | This is the key pattern for visualizations - a container group with\n-- | multiple child elements (shape + label).\n-- |\n-- | This validates that withChildren works correctly and that we can\n-- | create the nested structures that were blocking code-explorer.\ntestNestedElements :: Effect Unit\ntestNestedElements = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define a tree with MULTI-LEVEL NESTING\n  -- This is the pattern: Group → (Circle + Text)\n  let tree :: Tree Unit\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num 600.0\n          , height $ num 400.0\n          , viewBox 0.0 0.0 600.0 400.0\n          , attr \"id\" $ text \"nested-example-svg\"\n          ]\n          `T.withChild`\n            (T.named Group \"mainGroup\" [attr \"class\" $ text \"main-group\"]\n              `T.withChildren`\n                -- Multiple node groups, each with Circle + Text\n                [ -- Node 1\n                  T.named Group \"node1\"\n                    [ attr \"class\" $ text \"node\"\n                    , transform $ text \"translate(100, 100)\"\n                    ]\n                    `T.withChildren`\n                      [ T.named Circle \"node1Circle\"\n                          [ cx $ num 0.0, cy $ num 0.0\n                          , r $ num 25.0\n                          , fill $ text \"steelblue\"\n                          , stroke $ text \"white\"\n                          , strokeWidth $ num 2.0\n                          ]\n                      , T.named Text \"node1Label\"\n                          [ x $ num 0.0, y $ num 40.0\n                          , textContent $ text \"Node A\"\n                          , textAnchor $ text \"middle\"\n                          , fontSize $ num 14.0\n                          ]\n                      ]\n\n                , -- Node 2\n                  T.named Group \"node2\"\n                    [ attr \"class\" $ text \"node\"\n                    , transform $ text \"translate(300, 150)\"\n                    ]\n                    `T.withChildren`\n                      [ T.named Circle \"node2Circle\"\n                          [ cx $ num 0.0, cy $ num 0.0\n                          , r $ num 20.0\n                          , fill $ text \"orange\"\n                          , stroke $ text \"white\"\n                          , strokeWidth $ num 2.0\n                          ]\n                      , T.named Text \"node2Label\"\n                          [ x $ num 0.0, y $ num 35.0\n                          , textContent $ text \"Node B\"\n                          , textAnchor $ text \"middle\"\n                          , fontSize $ num 14.0\n                          ]\n                      ]\n\n                , -- Node 3\n                  T.named Group \"node3\"\n                    [ attr \"class\" $ text \"node\"\n                    , transform $ text \"translate(500, 100)\"\n                    ]\n                    `T.withChildren`\n                      [ T.named Circle \"node3Circle\"\n                          [ cx $ num 0.0, cy $ num 0.0\n                          , r $ num 30.0\n                          , fill $ text \"green\"\n                          , stroke $ text \"white\"\n                          , strokeWidth $ num 2.0\n                          ]\n                      , T.named Text \"node3Label\"\n                          [ x $ num 0.0, y $ num 45.0\n                          , textContent $ text \"Node C\"\n                          , textAnchor $ text \"middle\"\n                          , fontSize $ num 14.0\n                          ]\n                      ]\n                ])\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Nested Elements Test ===\"\n    Console.log \"\"\n    Console.log \"Structure: SVG → Group → (Node1, Node2, Node3)\"\n    Console.log \"           Each Node → (Circle + Text)\"\n    Console.log \"\"\n\n    -- Verify all selections\n    let checkSelection name = case Map.lookup name selections of\n          Just _ -> Console.log $ \"✓ \" <> name\n          Nothing -> Console.log $ \"✗ Missing: \" <> name\n\n    Console.log \"Top-level:\"\n    checkSelection \"svg\"\n    checkSelection \"mainGroup\"\n\n    Console.log \"\\nNode 1 (steelblue at 100, 100):\"\n    checkSelection \"node1\"\n    checkSelection \"node1Circle\"\n    checkSelection \"node1Label\"\n\n    Console.log \"\\nNode 2 (orange at 300, 150):\"\n    checkSelection \"node2\"\n    checkSelection \"node2Circle\"\n    checkSelection \"node2Label\"\n\n    Console.log \"\\nNode 3 (green at 500, 100):\"\n    checkSelection \"node3\"\n    checkSelection \"node3Circle\"\n    checkSelection \"node3Label\"\n\n    Console.log $ \"\\n\" <> show (Map.size selections) <> \" total selections in map\"\n\n    Console.log \"\\n=== SUCCESS CRITERIA ===\"\n    Console.log \"✓ Multi-level nesting works (Group → Circle + Text)\"\n    Console.log \"✓ withChildren handles arrays of subtrees\"\n    Console.log \"✓ All named nodes are accessible via Map\"\n    Console.log \"\"\n    Console.log \"NEXT: Need data joins to generate this structure from Array data\"\n    Console.log \"      instead of manually creating each node.\"\n"

snippet_threeLittleDimensions_content :: String
snippet_threeLittleDimensions_content = "module D3.Viz.TreeAPI.ThreeLittleDimensionsExample where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Integration (evalAttrStr)\nimport PSD3.Expr.Expr (str)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Nested data structure: array of arrays\ntype Matrix = Array (Array Int)\n\n-- | Sample 3x3 matrix\nmatrixData :: Matrix\nmatrixData = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\n\n-- | Three Little Dimensions using declarative tree API\n-- | This demonstrates nested data joins: outer array → rows, inner arrays → cells\nthreeLittleDimensions :: Effect Unit\nthreeLittleDimensions = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- The challenge: how to represent nested decomposition in a tree?\n  -- Outer datum type: Array Int (a row)\n  -- Inner datum type: Int (a cell value)\n\n  -- Approach: Use nestedJoin to handle datum type decomposition\n  -- Outer type: Array Int (a row)\n  -- Inner type: Int (a cell value)\n  let\n    tree :: T.Tree (Array Int)\n    tree =\n      T.named Table \"table\"\n        [ evalAttrStr \"class\" (str \"nested-data-table\") ]\n        `T.withChild`\n          -- nestedJoin handles the type change from Array Int → Int\n          -- identity is the decomposer: it just returns the row data as-is\n          ( T.nestedJoin \"rows\" \"tr\" matrixData identity $ \\cellValue ->\n              -- cellValue :: Int (decomposed from Array Int)\n              T.elem Td\n                [ evalAttrStr \"class\" (str \"table-cell\")\n                , evalAttrStr \"textContent\" (str (show cellValue))\n                ]\n          )\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Three Little Dimensions (Tree API) ===\"\n    Console.log \"\"\n\n    case Map.lookup \"table\" selections of\n      Just _ -> Console.log \"✓ Table created\"\n      Nothing -> Console.log \"✗ Missing table\"\n\n    case Map.lookup \"rows\" selections of\n      Just _ -> Console.log $ \"✓ Rows created (\" <> show (Array.length matrixData) <> \")\"\n      Nothing -> Console.log \"✗ Missing rows\"\n\n    case Map.lookup \"cells\" selections of\n      Just _ ->\n        let\n          totalCells = Array.foldl (\\acc row -> acc + Array.length row) 0 matrixData\n        in\n          Console.log $ \"✓ Cells created (\" <> show totalCells <> \" total)\"\n      Nothing -> Console.log \"✗ Missing cells\"\n\n    Console.log \"\"\n    Console.log \"Expected: 3x3 table with numbers 1-9\"\n"

snippet_barChart_content :: String
snippet_barChart_content = "module D3.Viz.TreeAPI.BarChartExample where\n\nimport Prelude\n\nimport Data.Array (length)\nimport Data.Foldable (maximum)\nimport Data.Int as Int\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, strokeWidth, transform)\nimport PSD3.Axis.Axis (axisBottom, axisLeft, renderAxis, Scale)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Simple data point\ntype DataPoint = { x :: Number, y :: Number }\n\n-- | Sample data\nsampleData :: Array DataPoint\nsampleData =\n  [ { x: 1.0, y: 30.0 }\n  , { x: 2.0, y: 80.0 }\n  , { x: 3.0, y: 45.0 }\n  , { x: 4.0, y: 60.0 }\n  , { x: 5.0, y: 20.0 }\n  , { x: 6.0, y: 90.0 }\n  , { x: 7.0, y: 55.0 }\n  ]\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 600.0\n  , height: 400.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 40.0\n  , marginLeft: 50.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Bar chart using declarative tree API\nbarChart :: Effect Unit\nbarChart = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n  let iWidth = innerWidth dims\n  let iHeight = innerHeight dims\n\n  -- Calculate data extents\n  let yValues = map _.y sampleData\n  let minY = 0.0 -- Start bars from zero\n  let maxY = fromMaybe 100.0 $ maximum yValues\n\n  -- Calculate bar width (80% of available space per bar)\n  let numBars = length sampleData\n  let barWidth = if numBars > 0 then (iWidth / (Int.toNumber numBars)) * 0.8 else 0.0\n\n  -- KEY: Create scales to map data values → pixel positions\n  -- Scales are the bridge between data space and visual space\n  let\n    xScale :: Scale\n    xScale =\n      { domain: { min: 1.0, max: Int.toNumber numBars } -- Data range\n      , range: { min: 0.0, max: iWidth } -- Pixel range\n      }\n\n  let\n    yScale :: Scale\n    yScale =\n      { domain: { min: minY, max: maxY } -- Data range (0 to max value)\n      , range: { min: iHeight, max: 0.0 } -- Pixel range (inverted for SVG coords)\n      }\n\n  -- Create axes\n  let xAxis = axisBottom xScale\n  let yAxis = axisLeft yScale\n\n  -- First, render the SVG container with axes (datum type: Unit)\n  let\n    axesTree :: Tree Unit\n    axesTree =\n      T.named SVG \"svg\"\n        [ width $ num dims.width\n        , height $ num dims.height\n        , viewBox 0.0 0.0 dims.width dims.height\n        , attr \"class\" $ text \"bar-chart-tree\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"chart-content\"\n              , transform $ text (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\")\n              ]\n              `T.withChildren`\n                [ -- X axis\n                  T.named Group \"xAxis\"\n                    [ transform $ text (\"translate(0,\" <> show iHeight <> \")\")\n                    , attr \"class\" $ text \"x-axis\"\n                    ]\n                    `T.withChild`\n                      renderAxis xAxis\n                , -- Y axis\n                  T.named Group \"yAxis\"\n                    [ attr \"class\" $ text \"y-axis\"\n                    ]\n                    `T.withChild`\n                      renderAxis yAxis\n                ]\n          )\n\n  -- Render axes first (underlaying)\n  axesSelections <- renderTree container axesTree\n\n  -- KEY: Reselect the chartGroup for layered rendering\n  -- This allows us to render bars on top of axes\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" axesSelections\n\n  -- KEY: Data join creates one rect per data point\n  let\n    barsTree :: Tree DataPoint\n    barsTree =\n      T.joinData \"bars\" \"rect\" sampleData $ \\point ->\n        -- Calculate bar position and dimensions from data\n        let\n          xPos = (point.x - 1.0) * (iWidth / (Int.toNumber numBars)) + ((iWidth / (Int.toNumber numBars)) - barWidth) / 2.0\n          yPos = iHeight - ((point.y - minY) / (maxY - minY) * iHeight) -- Manual scale calculation\n          barHeight = iHeight - yPos -- Bar grows from baseline\n        in\n          T.elem Rect\n            [ x $ num xPos -- Horizontal position\n            , y $ num yPos -- Top of bar (SVG coords from top-left)\n            , width $ num barWidth -- Bar width\n            , height $ num barHeight -- Bar height (grows downward in SVG)\n            , fill $ text \"#4a90e2\"\n            , stroke $ text \"#357abd\"\n            , strokeWidth $ num 1.0\n            , attr \"class\" $ text \"bar\"\n            ]\n\n  -- Render bars into the chart group (overlaying)\n  barsSelections <- renderTree chartGroupSel barsTree\n\n  liftEffect do\n    Console.log \"=== Bar Chart (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (length sampleData) <> \" bars with axes\"\n\n    case Map.lookup \"svg\" axesSelections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"chartGroup\" axesSelections of\n      Just _ -> Console.log \"✓ Chart group created\"\n      Nothing -> Console.log \"✗ Missing chart group\"\n\n    case Map.lookup \"xAxis\" axesSelections of\n      Just _ -> Console.log \"✓ X axis created\"\n      Nothing -> Console.log \"✗ Missing X axis\"\n\n    case Map.lookup \"yAxis\" axesSelections of\n      Just _ -> Console.log \"✓ Y axis created\"\n      Nothing -> Console.log \"✗ Missing Y axis\"\n\n    case Map.lookup \"bars\" barsSelections of\n      Just _ -> Console.log \"✓ Bars collection created\"\n      Nothing -> Console.log \"✗ Missing bars collection\"\n\n    Console.log \"\"\n    Console.log \"Expected: 7 blue bars of varying heights with X and Y axes\"\n"

snippet_scatterPlot_content :: String
snippet_scatterPlot_content = "module D3.Viz.TreeAPI.ScatterPlotExample where\n\nimport Prelude\n\nimport Data.Array (length)\nimport Data.Foldable (maximum, minimum)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, fill, opacity, transform)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree, joinData)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Data point with x, y coordinates\ntype Point = { x :: Number, y :: Number }\n\n-- | Sample scatter plot data\nscatterData :: Array Point\nscatterData =\n  [ { x: 10.0, y: 20.0 }\n  , { x: 25.0, y: 45.0 }\n  , { x: 40.0, y: 30.0 }\n  , { x: 55.0, y: 70.0 }\n  , { x: 70.0, y: 50.0 }\n  , { x: 85.0, y: 85.0 }\n  , { x: 100.0, y: 65.0 }\n  , { x: 115.0, y: 90.0 }\n  , { x: 130.0, y: 75.0 }\n  , { x: 145.0, y: 95.0 }\n  ]\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 600.0\n  , height: 400.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 40.0\n  , marginLeft: 50.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Scatter plot using declarative tree API\nscatterPlot :: Effect Unit\nscatterPlot = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n  let iWidth = innerWidth dims\n  let iHeight = innerHeight dims\n\n  -- Calculate data extents\n  let xValues = map _.x scatterData\n  let yValues = map _.y scatterData\n  let minX = fromMaybe 0.0 $ minimum xValues\n  let maxX = fromMaybe 100.0 $ maximum xValues\n  let minY = fromMaybe 0.0 $ minimum yValues\n  let maxY = fromMaybe 100.0 $ maximum yValues\n\n  -- Simple linear scale functions\n  let xScale val = ((val - minX) / (maxX - minX)) * iWidth\n  let yScale val = iHeight - ((val - minY) / (maxY - minY)) * iHeight\n\n  -- Define the tree structure\n  let tree :: Tree Point\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num dims.width\n          , height $ num dims.height\n          , viewBox 0.0 0.0 dims.width dims.height\n          , attr \"class\" $ text \"scatter-plot-tree\"\n          ]\n          `T.withChild`\n            (T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"chart-content\"\n              , transform $ text (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\")\n              ]\n              `T.withChild`\n                -- Data join for points\n                (joinData \"points\" \"circle\" scatterData $ \\point ->\n                  T.elem Circle\n                    [ cx $ num (xScale point.x)\n                    , cy $ num (yScale point.y)\n                    , r $ num 6.0\n                    , fill $ text \"#e74c3c\"\n                    , opacity $ num 0.7\n                    , attr \"class\" $ text \"point\"\n                    ]\n                ))\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Scatter Plot (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (length scatterData) <> \" points\"\n\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"chartGroup\" selections of\n      Just _ -> Console.log \"✓ Chart group created\"\n      Nothing -> Console.log \"✗ Missing chart group\"\n\n    case Map.lookup \"points\" selections of\n      Just _ -> Console.log \"✓ Points collection created\"\n      Nothing -> Console.log \"✗ Missing points collection\"\n\n    Console.log \"\"\n    Console.log \"Expected: 10 red circles showing scatter pattern\"\n"

snippet_lineChart_content :: String
snippet_lineChart_content = "module D3.Viz.TreeAPI.LineChartExample where\n\nimport Prelude\n\nimport Data.Array (length, mapWithIndex, range)\nimport Data.Foldable (maximum, minimum)\nimport Data.Int as Int\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.String (joinWith)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, fill, stroke, strokeWidth, transform, path)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Data point\ntype Point = { x :: Number, y :: Number }\n\n-- | Sample line data (sine wave)\nlineData :: Array Point\nlineData = mapWithIndex (\\i _ ->\n  let x = (Int.toNumber i) * 0.1\n      y = sin(x * pi) * 50.0 + 50.0\n  in { x, y }\n) (range 0 62)\n\n-- FFI for Math functions\nforeign import sin :: Number -> Number\nforeign import pi :: Number\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 600.0\n  , height: 300.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 40.0\n  , marginLeft: 50.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Generate SVG path data string from points\npointsToPath :: Dimensions -> Array Point -> Number -> Number -> Number -> Number -> String\npointsToPath dims points minX maxX minY maxY =\n  let iWidth = innerWidth dims\n      iHeight = innerHeight dims\n      xScale val = ((val - minX) / (maxX - minX)) * iWidth\n      yScale val = iHeight - ((val - minY) / (maxY - minY)) * iHeight\n\n      toCommand :: Int -> Point -> String\n      toCommand 0 p = \"M \" <> show (xScale p.x) <> \" \" <> show (yScale p.y)\n      toCommand _ p = \"L \" <> show (xScale p.x) <> \" \" <> show (yScale p.y)\n  in\n    joinWith \" \" (mapWithIndex toCommand points)\n\n-- | Line chart using declarative tree API\nlineChart :: Effect Unit\nlineChart = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n\n  -- Calculate data extents\n  let xValues = map _.x lineData\n  let yValues = map _.y lineData\n  let minX = fromMaybe 0.0 $ minimum xValues\n  let maxX = fromMaybe 10.0 $ maximum xValues\n  let minY = fromMaybe 0.0 $ minimum yValues\n  let maxY = fromMaybe 100.0 $ maximum yValues\n\n  -- Generate path data\n  let pathData = pointsToPath dims lineData minX maxX minY maxY\n\n  -- Define the tree structure\n  let tree :: Tree Unit\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num dims.width\n          , height $ num dims.height\n          , viewBox 0.0 0.0 dims.width dims.height\n          , attr \"class\" $ text \"line-chart-tree\"\n          ]\n          `T.withChild`\n            (T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"chart-content\"\n              , transform $ text (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\")\n              ]\n              `T.withChild`\n                -- Single path element for the line\n                (T.named Path \"line\"\n                  [ path $ text pathData\n                  , fill $ text \"none\"\n                  , stroke $ text \"#2ecc71\"\n                  , strokeWidth $ num 2.0\n                  , attr \"class\" $ text \"line\"\n                  ]\n                ))\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Line Chart (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered line with \" <> show (length lineData) <> \" points\"\n\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"chartGroup\" selections of\n      Just _ -> Console.log \"✓ Chart group created\"\n      Nothing -> Console.log \"✗ Missing chart group\"\n\n    case Map.lookup \"line\" selections of\n      Just _ -> Console.log \"✓ Line path created\"\n      Nothing -> Console.log \"✗ Missing line path\"\n\n    Console.log \"\"\n    Console.log \"Expected: Green sine wave curve\"\n"

snippet_groupedBarChart_content :: String
snippet_groupedBarChart_content = "module D3.Viz.TreeAPI.GroupedBarChartExample where\n\nimport Prelude\n\nimport Data.Array (filter, findIndex, nub)\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Foldable (maximum)\nimport Data.Int as Int\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number as Number\nimport Data.String (Pattern(..), split, trim)\nimport Effect (Effect)\nimport Effect.Aff (Aff, launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (DataFile(..), loadDataFile, parseCSVRow)\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr, fnAttr, fnAttrStr)\nimport PSD3.Expr.Expr (lit, str)\nimport PSD3.Axis.Axis (axisBottom, axisLeft, renderAxis, Scale)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Grouped Bar Chart Data (State population by age group)\ntype GroupedBarData =\n  { state :: String\n  , age :: String\n  , population :: Number\n  }\n\n-- | Parse CSV row into population data\n-- | CSV format: State,Under 5 Years,5 to 13 Years,14 to 17 Years,18 to 24 Years,25 to 44 Years,45 to 64 Years,65 Years and Over\n-- | Map to 9 age categories: <10, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70-79, ≥80\nparsePopulationRow :: String -> Array GroupedBarData\nparsePopulationRow line =\n  case parseCSVRow line of\n    [ state, under5Str, age5to13Str, age14to17Str, age18to24Str, age25to44Str, age45to64Str, age65plusStr ] -> do\n      let\n        under5 = fromMaybe 0.0 $ Number.fromString (trim under5Str)\n        age5to13 = fromMaybe 0.0 $ Number.fromString (trim age5to13Str)\n        age14to17 = fromMaybe 0.0 $ Number.fromString (trim age14to17Str)\n        age18to24 = fromMaybe 0.0 $ Number.fromString (trim age18to24Str)\n        age25to44 = fromMaybe 0.0 $ Number.fromString (trim age25to44Str)\n        age45to64 = fromMaybe 0.0 $ Number.fromString (trim age45to64Str)\n        age65plus = fromMaybe 0.0 $ Number.fromString (trim age65plusStr)\n      [ { state: trim state, age: \"<10\", population: under5 + age5to13 * 0.5 }\n      , { state: trim state, age: \"10-19\", population: age5to13 * 0.5 + age14to17 }\n      , { state: trim state, age: \"20-29\", population: age18to24 + age25to44 * 0.25 }\n      , { state: trim state, age: \"30-39\", population: age25to44 * 0.5 }\n      , { state: trim state, age: \"40-49\", population: age25to44 * 0.25 }\n      , { state: trim state, age: \"50-59\", population: age45to64 * 0.6 }\n      , { state: trim state, age: \"60-69\", population: age45to64 * 0.4 }\n      , { state: trim state, age: \"70-79\", population: age65plus * 0.6 }\n      , { state: trim state, age: \"≥80\", population: age65plus * 0.4 }\n      ]\n    _ -> []\n\n-- | Load population data from CSV\nloadPopulationData :: Aff (Array GroupedBarData)\nloadPopulationData = do\n  result <- loadDataFile USPopulationStateAgeCSV\n  case result of\n    Left err -> do\n      liftEffect $ Console.log $ \"Failed to load population data: \" <> err\n      pure []\n    Right body -> do\n      let lines = split (Pattern \"\\n\") body\n      let dataLines = Array.drop 1 lines -- Skip header\n      let parsed = Array.concatMap parsePopulationRow dataLines\n      liftEffect $ Console.log $ \"Loaded \" <> show (Array.length parsed) <> \" population data points\"\n      pure parsed\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 800.0\n  , height: 500.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 60.0\n  , marginLeft: 60.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Group data by state\ntype StateGroup = { state :: String, bars :: Array GroupedBarData }\n\ngroupByState :: Array GroupedBarData -> Array StateGroup\ngroupByState data' =\n  let\n    states = nub $ map _.state data'\n    getStateData st = filter (\\d -> d.state == st) data'\n  in\n    map (\\st -> { state: st, bars: getStateData st }) states\n\n-- | Get all unique age groups\ngetAges :: Array GroupedBarData -> Array String\ngetAges = nub <<< map _.age\n\n-- | Color scale for age groups\ncolorForAge :: String -> String\ncolorForAge \"<10\" = \"#e8384f\"\ncolorForAge \"10-19\" = \"#fd612c\"\ncolorForAge \"20-29\" = \"#fd8d3c\"\ncolorForAge \"30-39\" = \"#feb078\"\ncolorForAge \"40-49\" = \"#ffe0b3\"\ncolorForAge \"50-59\" = \"#d7eaf3\"\ncolorForAge \"60-69\" = \"#abd9e9\"\ncolorForAge \"70-79\" = \"#74add1\"\ncolorForAge \"≥80\" = \"#4575b4\"\ncolorForAge _ = \"#999\"\n\n-- | Grouped bar chart using Tree API\n-- |\n-- | This demonstrates:\n-- | - Nested joins: states → bars within each state\n-- | - Multiple data series with color encoding\n-- | - Axes with proper scales\n-- | Draw grouped bar chart with loaded data\ndrawGroupedBarChart :: String -> Array GroupedBarData -> Effect Unit\ndrawGroupedBarChart selector populationData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n  let iWidth = innerWidth dims\n  let iHeight = innerHeight dims\n\n  -- Group data by state\n  let stateGroups = groupByState populationData\n  let ages = getAges populationData\n  let numStates = Array.length stateGroups\n  let numAges = Array.length ages\n\n  -- Calculate bar dimensions\n  let groupWidth = iWidth / Int.toNumber numStates\n  let barWidth = groupWidth / Int.toNumber numAges * 0.9\n\n  -- Calculate scales\n  let populationValues = map _.population populationData\n  let maxPop = fromMaybe 6000000.0 $ maximum populationValues\n\n  -- X scale maps state index to position\n  let\n    xScale :: Scale\n    xScale =\n      { domain: { min: 0.0, max: Int.toNumber numStates }\n      , range: { min: 0.0, max: iWidth }\n      }\n\n  -- Y scale maps population to height\n  let\n    yScale :: Scale\n    yScale =\n      { domain: { min: 0.0, max: maxPop }\n      , range: { min: iHeight, max: 0.0 }\n      }\n\n  -- Create axes\n  let xAxis = axisBottom xScale\n  let yAxis = axisLeft yScale\n\n  -- First tree: SVG container with axes\n  let\n    axesTree :: T.Tree Unit\n    axesTree =\n      T.named SVG \"svg\"\n        [ evalAttr \"width\" (lit dims.width)\n        , evalAttr \"height\" (lit dims.height)\n        , evalAttrStr \"viewBox\" (str (\"0 0 \" <> show dims.width <> \" \" <> show dims.height))\n        , evalAttrStr \"class\" (str \"grouped-bar-chart\")\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ evalAttrStr \"class\" (str \"chart-content\")\n              , evalAttrStr \"transform\" (str (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\"))\n              ]\n              `T.withChildren`\n                [ -- X axis\n                  T.named Group \"xAxis\"\n                    [ evalAttrStr \"transform\" (str (\"translate(0,\" <> show iHeight <> \")\"))\n                    , evalAttrStr \"class\" (str \"x-axis\")\n                    ]\n                    `T.withChild`\n                      renderAxis xAxis\n                , -- Y axis\n                  T.named Group \"yAxis\"\n                    [ evalAttrStr \"class\" (str \"y-axis\")\n                    ]\n                    `T.withChild`\n                      renderAxis yAxis\n                ]\n          )\n\n  -- Render axes\n  axesSelections <- renderTree container axesTree\n\n  -- Second tree: Grouped bars\n  -- Extract the chartGroup selection for the second render\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" axesSelections\n\n  -- Use nestedJoin to create state groups → bars\n  let\n    barsTree :: T.Tree StateGroup\n    barsTree =\n      T.nestedJoin \"stateGroups\" \"g\" stateGroups (_.bars) $ \\bar ->\n        -- bar :: GroupedBarData\n        -- Calculate position for this bar\n        let\n          -- Find which state this bar belongs to\n          stateIdx = fromMaybe 0 $ findIndex (\\g -> g.state == bar.state) stateGroups\n          -- Find which age group this is\n          ageIdx = fromMaybe 0 $ findIndex (\\a -> a == bar.age) ages\n\n          -- X position: state position + age offset\n          xPos = Int.toNumber stateIdx * groupWidth + Int.toNumber ageIdx * barWidth\n\n          -- Y position and height from population\n          yPos = iHeight - ((bar.population / maxPop) * iHeight)\n          barHeight = (bar.population / maxPop) * iHeight\n        in\n          T.elem Rect\n            [ evalAttr \"x\" (lit xPos)\n            , evalAttr \"y\" (lit yPos)\n            , evalAttr \"width\" (lit barWidth)\n            , evalAttr \"height\" (lit barHeight)\n            , evalAttrStr \"fill\" (str (colorForAge bar.age))\n            , evalAttrStr \"class\" (str \"bar\")\n            ]\n\n  -- Render bars\n  barsSelections <- renderTree chartGroupSel barsTree\n\n  liftEffect do\n    Console.log \"=== Grouped Bar Chart (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (Array.length populationData) <> \" bars in \"\n      <> show numStates\n      <> \" groups\"\n\n    case Map.lookup \"svg\" axesSelections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n-- | Main entry point - loads data then renders\ngroupedBarChart :: String -> Effect Unit\ngroupedBarChart selector = launchAff_ do\n  populationData <- loadPopulationData\n  liftEffect $ drawGroupedBarChart selector populationData\n"

snippet_multiLineChart_content :: String
snippet_multiLineChart_content = "module D3.Viz.TreeAPI.MultiLineChartExample where\n\nimport Prelude\n\nimport Data.Array (findIndex, groupBy, length, mapMaybe, sortBy, uncons)\nimport Data.Array as Data.Array\nimport Data.Array.NonEmpty as NEA\nimport Data.Either (Either(..))\nimport Data.Foldable (maximum, foldl)\nimport Data.Function (on) as F\nimport Data.Int (toNumber)\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number as Number\nimport Data.String (Pattern(..), split, trim)\nimport Effect (Effect)\nimport Effect.Aff (Aff, launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (DataFile(..), loadDataFile, parseCSVRow)\n-- v3 Integration: all attributes via evalAttr/evalAttrStr (no ToAttr typeclass)\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr, fnAttrStr)\nimport PSD3.Expr.Expr (lit, str)\nimport PSD3.Axis.Axis (axisBottom, axisLeft, renderAxis, Scale)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree, on)\nimport PSD3.Internal.Behavior.Types (onMouseLeaveWithInfo, onMouseMoveWithInfo, MouseEventInfo)\nimport Data.Map as Map\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree, joinData)\nimport PSD3.AST as T\nimport PSD3.Tooltip (showTooltip, hideTooltip)\nimport Web.DOM.Element (Element)\nimport Effect.Ref as Ref\nimport Data.Maybe (Maybe(..)) as Maybe\n\n-- | Multi-line chart showing unemployment rates over time for US metro areas\n-- |\n-- | Data: BLS metro area unemployment data (42 cities, 2000-2013)\n-- | Visual: Many light gray lines that highlight dark on hover\n-- |\n-- | Key concept: Hover interaction makes dense overlapping data readable\n\ntype DataPoint =\n  { date :: String     -- Date string (YYYY-MM-DD)\n  , division :: String -- Metro area name\n  , rate :: Number     -- Unemployment rate (percentage)\n  }\n\ntype Series =\n  { division :: String\n  , points :: Array DataPoint\n  }\n\n-- Parse CSV row into DataPoint using centralized CSV parser\nparseDataPoint :: String -> Maybe DataPoint\nparseDataPoint line =\n  case parseCSVRow line of\n    [division, date, rateStr] -> do\n      rate <- Number.fromString (trim rateStr)\n      pure { division: trim division, date: trim date, rate }\n    _ -> Nothing\n\n-- Load and parse CSV data using centralized loader\nloadUnemploymentData :: Aff (Array DataPoint)\nloadUnemploymentData = do\n  result <- loadDataFile MetroUnemploymentCSV\n  case result of\n    Left err -> do\n      liftEffect $ Console.log $ \"Failed to load unemployment data: \" <> err\n      pure []\n    Right body -> do\n      let lines = split (Pattern \"\\n\") body\n      let dataLines = Data.Array.drop 1 lines  -- Skip header\n      let parsed = mapMaybe parseDataPoint dataLines\n      liftEffect $ Console.log $ \"Loaded \" <> show (length parsed) <> \" unemployment data points\"\n      pure parsed\n\n-- Group data by division\ngroupByDivision :: Array DataPoint -> Array Series\ngroupByDivision dataPoints =\n  let grouped = groupBy (\\a b -> a.division == b.division) $ sortBy (compare `F.on` _.division) dataPoints\n      toSeries group =\n        let first = NEA.head group\n            points = NEA.toArray group\n        in { division: first.division\n           , points: sortBy (compare `F.on` _.date) points\n           }\n  in map toSeries grouped\n\n-- FFI for setTimeout/clearTimeout\nforeign import setTimeout_ :: Effect Unit -> Int -> Effect Int\nforeign import clearTimeout_ :: Int -> Effect Unit\n\n-- Draw the multi-line chart with loaded data\ndrawMultiLineChart :: String -> Array DataPoint -> Effect Unit\ndrawMultiLineChart selector unemploymentData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Timeout ref for debounced tooltip hiding\n  hideTimeoutRef <- liftEffect $ Ref.new (Maybe.Nothing :: Maybe.Maybe Int)\n\n  -- Chart dimensions\n  let margin = { top: 20.0, right: 20.0, bottom: 50.0, left: 60.0 }\n      svgWidth = 928.0\n      svgHeight = 600.0\n      plotWidth = svgWidth - margin.left - margin.right\n      plotHeight = svgHeight - margin.top - margin.bottom\n\n      -- Get all unique dates for x-axis\n      allDates = Data.Array.nub $ map _.date unemploymentData\n      dateCount = toNumber $ length allDates\n\n      -- Scales\n      xScale :: Scale\n      xScale = { domain: { min: 0.0, max: dateCount - 1.0 }, range: { min: 0.0, max: plotWidth } }\n\n      maxRate = fromMaybe 20.0 $ maximum $ map _.rate unemploymentData\n      yScale :: Scale\n      yScale = { domain: { min: 0.0, max: maxRate }, range: { min: plotHeight, max: 0.0 } }\n\n      -- Scale helpers\n      scaleX :: String -> Number\n      scaleX date =\n        let idx = fromMaybe 0 $ findIndex (\\d -> d == date) allDates\n            value = toNumber idx\n            domainSpan = xScale.domain.max - xScale.domain.min\n            rangeSpan = xScale.range.max - xScale.range.min\n            normalized = (value - xScale.domain.min) / domainSpan\n        in xScale.range.min + (normalized * rangeSpan)\n\n      scaleY :: Number -> Number\n      scaleY rate =\n        let domainSpan = yScale.domain.max - yScale.domain.min\n            rangeSpan = yScale.range.max - yScale.range.min\n            normalized = (rate - yScale.domain.min) / domainSpan\n        in yScale.range.min + (normalized * rangeSpan)\n\n      -- Build path string for a series\n      linePath :: Array DataPoint -> String\n      linePath points =\n        case uncons points of\n          Nothing -> \"\"\n          Just { head: first, tail: rest } ->\n            let moveCmd = \"M\" <> show (scaleX first.date) <> \",\" <> show (scaleY first.rate)\n                lineSegments = map (\\p -> \"L\" <> show (scaleX p.date) <> \",\" <> show (scaleY p.rate)) rest\n            in moveCmd <> foldl (\\acc seg -> acc <> seg) \"\" lineSegments\n\n      -- Group data by division\n      series = groupByDivision unemploymentData\n\n  -- Build the tree using v3 attributes exclusively\n  let tree :: Tree Series\n      tree =\n        T.named SVG \"svg\"\n          [ evalAttr \"width\" (lit svgWidth)\n          , evalAttr \"height\" (lit svgHeight)\n          , evalAttrStr \"viewBox\" (str $ \"0 0 \" <> show svgWidth <> \" \" <> show svgHeight)\n          , evalAttrStr \"class\" (str \"multi-line-chart\")  -- This class enables hover CSS\n          ]\n          `T.withChild`\n            (T.named Group \"plot-area\"\n              [ evalAttrStr \"transform\" (str $ \"translate(\" <> show margin.left <> \",\" <> show margin.top <> \")\") ]\n              `T.withChildren`\n                [ -- X-axis\n                  T.named Group \"x-axis\"\n                    [ evalAttrStr \"transform\" (str $ \"translate(0,\" <> show plotHeight <> \")\")\n                    , evalAttrStr \"class\" (str \"x-axis\")\n                    ]\n                    `T.withChild` renderAxis (axisBottom xScale)\n\n                , -- Y-axis\n                  T.named Group \"y-axis\"\n                    [ evalAttrStr \"class\" (str \"y-axis\") ]\n                    `T.withChild` renderAxis (axisLeft yScale)\n\n                , -- Y-axis label\n                  T.elem Text\n                    [ evalAttrStr \"transform\" (str \"rotate(-90)\")\n                    , evalAttr \"x\" (lit (-(plotHeight / 2.0)))\n                    , evalAttr \"y\" (lit (-40.0))\n                    , evalAttrStr \"text-anchor\" (str \"middle\")\n                    , evalAttr \"font-size\" (lit 12.0)\n                    , evalAttrStr \"textContent\" (str \"Unemployment Rate (%)\")\n                    ]\n\n                , -- Lines with hover interaction (CSS: .multi-line-chart .line:hover)\n                  -- All lines are light gray (#ddd), dark gray (#333) on hover\n                  joinData \"lines\" \"path\" series $ \\_ ->\n                    T.elem Path\n                      [ fnAttrStr \"d\" (\\s -> linePath s.points)\n                      , evalAttrStr \"fill\" (str \"none\")\n                      , evalAttrStr \"stroke\" (str \"#ddd\")  -- Light gray for all lines\n                      , evalAttr \"stroke-width\" (lit 1.5)\n                      , evalAttrStr \"class\" (str \"line\")  -- CSS uses .multi-line-chart .line for hover\n                      ]\n                ])\n\n  -- Render and get selections\n  selections <- renderTree container tree\n\n  -- Helper to find nearest point by offsetX\n  let findNearestPoint :: Series -> Number -> Maybe DataPoint\n      findNearestPoint s mouseX = do\n        -- Adjust for margin to get plot-relative x\n        let plotX = mouseX - margin.left\n        -- Sort points by date (x position)\n        let sortedPoints = sortBy (compare `F.on` _.date) s.points\n        -- Find nearest by comparing scaled x positions\n        let withDistances = sortedPoints # map \\p ->\n              { point: p, dist: Number.abs (scaleX p.date - plotX) }\n        case Data.Array.head (sortBy (compare `F.on` _.dist) withDistances) of\n          Just { point } -> Just point\n          Nothing -> Nothing\n\n  -- Attach hover with tooltip to lines\n  -- Visual highlighting is handled by CSS (.multi-line-chart .line:hover)\n  -- Tooltip is handled by PureScript via onMouseMoveWithInfo/onMouseLeaveWithInfo\n  -- We use a debounced hide to avoid flickering from tiny mouse movements\n  case Map.lookup \"lines\" selections of\n    Just linesSel -> do\n      -- Use onMouseMoveWithInfo to continuously update tooltip as mouse moves along line\n      _ <- on (onMouseMoveWithInfo \\(info :: MouseEventInfo Series) -> do\n        -- Cancel any pending hide timeout\n        maybeTimeout <- Ref.read hideTimeoutRef\n        case maybeTimeout of\n          Maybe.Just timeoutId -> do\n            clearTimeout_ timeoutId\n            Ref.write Maybe.Nothing hideTimeoutRef\n          Maybe.Nothing -> pure unit\n\n        -- Find nearest point based on mouse x position\n        case findNearestPoint info.datum info.offsetX of\n          Maybe.Just point -> do\n            let content = \"<strong>\" <> info.datum.division <> \"</strong><br/>\"\n                       <> point.date <> \": \" <> show point.rate <> \"%\"\n            showTooltip content info.pageX info.pageY\n          Maybe.Nothing -> pure unit\n        ) linesSel\n\n      -- Use onMouseLeaveWithInfo to hide tooltip with a small delay\n      -- This provides a buffer so tiny mouse movements don't immediately cancel the tooltip\n      _ <- on (onMouseLeaveWithInfo \\(_ :: MouseEventInfo Series) -> do\n        -- Set a timeout to hide after 150ms\n        timeoutId <- setTimeout_ hideTooltip 150\n        Ref.write (Maybe.Just timeoutId) hideTimeoutRef\n        ) linesSel\n\n      pure unit\n    Nothing -> pure unit\n\n  liftEffect do\n    Console.log \"=== Multi-Line Chart ===\"\n    Console.log \"\"\n    Console.log (\"Metro areas: \" <> show (length series))\n    Console.log (\"Data points: \" <> show (length unemploymentData))\n    Console.log \"\"\n\n-- Main entry point - loads data then renders\nmultiLineChart :: String -> Effect Unit\nmultiLineChart selector = launchAff_ do\n  unemploymentData <- loadUnemploymentData\n  liftEffect $ drawMultiLineChart selector unemploymentData\n\n"

snippet_radialStackedBar_content :: String
snippet_radialStackedBar_content = "module D3.Viz.TreeAPI.RadialStackedBarExample where\n\nimport Prelude\n\nimport Data.Array (groupBy, length, sortBy)\nimport Data.Array as Array\nimport Data.Array.NonEmpty as NEA\nimport Data.Either (Either(..))\nimport Data.Foldable (sum, maximum)\nimport Data.Function (on)\nimport Data.Int (toNumber)\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number (pi, cos, sin)\nimport Data.Number as Number\nimport Data.String (Pattern(..), split, trim)\nimport Effect (Effect)\nimport Effect.Aff (Aff, launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (DataFile(..), loadDataFile, parseCSVRow)\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr)\nimport PSD3.Expr.Expr (lit, str)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Radial Stacked Bar Chart - polar coordinates visualization\n-- |\n-- | Data: US population by state and age (all 50 states + DC)\n-- | Visual: States arranged in a circle, age groups stacked radially\n-- |\n-- | Key concepts: Polar coordinates, arc paths, radial stacking, nestedJoin\n\ntype GroupedBarData =\n  { state :: String\n  , age :: String\n  , population :: Number\n  }\n\ntype AgeSegment =\n  { age :: String\n  , population :: Number\n  , innerRadius :: Number\n  , outerRadius :: Number\n  }\n\ntype StateData =\n  { state :: String\n  , stateIndex :: Int\n  , ageSegments :: Array AgeSegment\n  , totalPopulation :: Number\n  }\n\n-- | Parse CSV row into population data\nparsePopulationRow :: String -> Array GroupedBarData\nparsePopulationRow line =\n  case parseCSVRow line of\n    [ state, under5Str, age5to13Str, age14to17Str, age18to24Str, age25to44Str, age45to64Str, age65plusStr ] -> do\n      let\n        under5 = fromMaybe 0.0 $ Number.fromString (trim under5Str)\n        age5to13 = fromMaybe 0.0 $ Number.fromString (trim age5to13Str)\n        age14to17 = fromMaybe 0.0 $ Number.fromString (trim age14to17Str)\n        age18to24 = fromMaybe 0.0 $ Number.fromString (trim age18to24Str)\n        age25to44 = fromMaybe 0.0 $ Number.fromString (trim age25to44Str)\n        age45to64 = fromMaybe 0.0 $ Number.fromString (trim age45to64Str)\n        age65plus = fromMaybe 0.0 $ Number.fromString (trim age65plusStr)\n      [ { state: trim state, age: \"<10\", population: under5 + age5to13 * 0.5 }\n      , { state: trim state, age: \"10-19\", population: age5to13 * 0.5 + age14to17 }\n      , { state: trim state, age: \"20-29\", population: age18to24 + age25to44 * 0.25 }\n      , { state: trim state, age: \"30-39\", population: age25to44 * 0.5 }\n      , { state: trim state, age: \"40-49\", population: age25to44 * 0.25 }\n      , { state: trim state, age: \"50-59\", population: age45to64 * 0.6 }\n      , { state: trim state, age: \"60-69\", population: age45to64 * 0.4 }\n      , { state: trim state, age: \"70-79\", population: age65plus * 0.6 }\n      , { state: trim state, age: \"≥80\", population: age65plus * 0.4 }\n      ]\n    _ -> []\n\n-- | Load population data from CSV\nloadPopulationData :: Aff (Array GroupedBarData)\nloadPopulationData = do\n  result <- loadDataFile USPopulationStateAgeCSV\n  case result of\n    Left err -> do\n      liftEffect $ Console.log $ \"Failed to load population data: \" <> err\n      pure []\n    Right body -> do\n      let lines = split (Pattern \"\\n\") body\n      let dataLines = Array.drop 1 lines -- Skip header\n      let parsed = Array.concatMap parsePopulationRow dataLines\n      liftEffect $ Console.log $ \"Loaded \" <> show (Array.length parsed) <> \" population data points\"\n      pure parsed\n\n-- Age group colors (Spectral scheme)\nageColors :: Array String\nageColors =\n  [ \"#d53e4f\" -- <10\n  , \"#f46d43\" -- 10-19\n  , \"#fdae61\" -- 20-29\n  , \"#fee08b\" -- 30-39\n  , \"#e6f598\" -- 40-49\n  , \"#abdda4\" -- 50-59\n  , \"#66c2a5\" -- 60-69\n  , \"#3288bd\" -- 70-79\n  , \"#5e4fa2\" -- ≥80\n  ]\n\n-- Get color for age group index\ngetAgeColor :: Int -> String\ngetAgeColor idx = fromMaybe \"#999\" $ Array.index ageColors idx\n\n-- Get color for age group name\ngetAgeColorByName :: String -> String\ngetAgeColorByName age = case age of\n  \"<10\" -> \"#d53e4f\"\n  \"10-19\" -> \"#f46d43\"\n  \"20-29\" -> \"#fdae61\"\n  \"30-39\" -> \"#fee08b\"\n  \"40-49\" -> \"#e6f598\"\n  \"50-59\" -> \"#abdda4\"\n  \"60-69\" -> \"#66c2a5\"\n  \"70-79\" -> \"#3288bd\"\n  \"≥80\" -> \"#5e4fa2\"\n  _ -> \"#999\"\n\n-- Format large numbers with SI prefix (millions)\nformatSI :: Number -> String\nformatSI n =\n  if n >= 1000000.0 then show (n / 1000000.0) <> \"M\"\n  else show n\n\n-- Group data by state and calculate radial positions\nprepareRadialData :: Array GroupedBarData -> Array StateData\nprepareRadialData dataPoints =\n  let\n    grouped = groupBy (\\a b -> a.state == b.state) $ sortBy (compare `on` _.state) dataPoints\n\n    -- Find max total across ALL states for global scaling\n    allTotals = map (\\g -> sum $ map _.population $ NEA.toArray g) grouped\n    maxTotal = fromMaybe 1.0 $ maximum allTotals\n\n    innerRadius = 80.0\n    outerRadius = 300.0\n    radiusRange = outerRadius - innerRadius\n\n  in\n    Array.mapWithIndex (toStateData maxTotal innerRadius radiusRange) grouped\n  where\n  toStateData :: Number -> Number -> Number -> Int -> NEA.NonEmptyArray GroupedBarData -> StateData\n  toStateData maxTotal innerR radiusRange stateIndex group =\n    let\n      first = NEA.head group\n      points = NEA.toArray group\n      total = sum $ map _.population points\n\n      -- Calculate cumulative radii for stacking, scaled by global max\n      segments = Array.foldl\n        ( \\acc item ->\n            let\n              prevRadius = case Array.last acc.result of\n                Just prev -> prev.outerRadius\n                Nothing -> innerR\n              -- Scale by global max, not local total\n              thickness = (item.population / maxTotal) * radiusRange\n            in\n              { result: Array.snoc acc.result\n                  { age: item.age\n                  , population: item.population\n                  , innerRadius: prevRadius\n                  , outerRadius: prevRadius + thickness\n                  }\n              }\n        )\n        { result: [] }\n        points\n\n    in\n      { state: first.state\n      , stateIndex\n      , ageSegments: segments.result\n      , totalPopulation: total\n      }\n\n-- Create an arc path in SVG\n-- startAngle and endAngle in radians, innerRadius and outerRadius in pixels\narcPath :: Number -> Number -> Number -> Number -> String\narcPath startAngle endAngle innerRadius outerRadius =\n  let -- Outer arc\n    outerStartX = outerRadius * cos startAngle\n    outerStartY = outerRadius * sin startAngle\n    outerEndX = outerRadius * cos endAngle\n    outerEndY = outerRadius * sin endAngle\n\n    -- Inner arc\n    innerEndX = innerRadius * cos endAngle\n    innerEndY = innerRadius * sin endAngle\n    innerStartX = innerRadius * cos startAngle\n    innerStartY = innerRadius * sin startAngle\n\n    largeArc = if (endAngle - startAngle) > pi then 1 else 0\n\n  in\n    \"M\" <> show outerStartX <> \",\" <> show outerStartY\n      <> \" A\"\n      <> show outerRadius\n      <> \",\"\n      <> show outerRadius\n      <> \" 0 \"\n      <> show largeArc\n      <> \",1 \"\n      <> show outerEndX\n      <> \",\"\n      <> show outerEndY\n      <> \" L\"\n      <> show innerEndX\n      <> \",\"\n      <> show innerEndY\n      <> \" A\"\n      <> show innerRadius\n      <> \",\"\n      <> show innerRadius\n      <> \" 0 \"\n      <> show largeArc\n      <> \",0 \"\n      <> show innerStartX\n      <> \",\"\n      <> show innerStartY\n      <>\n        \" Z\"\n\n-- | Draw radial stacked bar chart with loaded data\ndrawRadialStackedBar :: String -> Array GroupedBarData -> Effect Unit\ndrawRadialStackedBar selector populationData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Prepare data\n  let\n    states = prepareRadialData populationData\n    stateCount = toNumber $ length states\n    anglePerState = (2.0 * pi) / stateCount\n\n    -- Calculate max total for grid lines\n    allTotals = map _.totalPopulation states\n    maxTotal = fromMaybe 1.0 $ maximum allTotals\n\n    -- Grid line values (25%, 50%, 75%, 100%)\n    gridValues = [ 0.25 * maxTotal, 0.5 * maxTotal, 0.75 * maxTotal, maxTotal ]\n\n    -- Age groups for legend\n    ageGroups = [ \"<10\", \"10-19\", \"20-29\", \"30-39\", \"40-49\", \"50-59\", \"60-69\", \"70-79\", \"≥80\" ]\n\n    -- Radii\n    innerRadius = 80.0\n    outerRadius = 300.0\n    radiusRange = outerRadius - innerRadius\n\n    -- Helper to scale value to radius\n    radiusScale :: Number -> Number\n    radiusScale v = innerRadius + (v / maxTotal) * radiusRange\n\n    -- SVG dimensions\n    svgSize = 700.0\n    centerX = svgSize / 2.0\n    centerY = svgSize / 2.0\n\n    -- Helper to create grid line elements (circle + label with stroke outline)\n    makeGridLine :: Number -> Array (Tree Unit)\n    makeGridLine value =\n      let\n        gridRadius = radiusScale value\n      in\n        [ T.elem Circle\n            [ evalAttr \"r\" (lit gridRadius)\n            , evalAttrStr \"stroke\" (str \"#000000\")\n            , evalAttr \"stroke-opacity\" (lit 0.5)\n            , evalAttrStr \"fill\" (str \"none\")\n            , evalAttrStr \"class\" (str \"grid-circle\")\n            ]\n        , T.elem Text\n            [ evalAttr \"y\" (lit (-gridRadius))\n            , evalAttr \"dy\" (lit 5.6)\n            , evalAttrStr \"text-content\" (str (formatSI value))\n            , evalAttrStr \"stroke\" (str \"#ffffff\")\n            , evalAttr \"stroke-width\" (lit 5.0)\n            , evalAttrStr \"fill\" (str \"none\")\n            , evalAttrStr \"class\" (str \"grid-label-bg\")\n            ]\n        , T.elem Text\n            [ evalAttr \"y\" (lit (-gridRadius))\n            , evalAttr \"dy\" (lit 5.6)\n            , evalAttrStr \"text-content\" (str (formatSI value))\n            , evalAttrStr \"fill\" (str \"#000000\")\n            , evalAttrStr \"class\" (str \"grid-label\")\n            ]\n        ]\n\n    -- Helper to create legend items\n    makeLegendItem :: Int -> String -> Tree Unit\n    makeLegendItem idx age =\n      let\n        ageCount = length ageGroups\n        yOffset = (toNumber ageCount / 2.0 - toNumber idx - 1.0) * 20.0\n      in\n        T.named Group (\"legend-\" <> age)\n          [ evalAttrStr \"transform\" (str (\"translate(-40,\" <> show yOffset <> \")\"))\n          , evalAttrStr \"class\" (str \"legend-item\")\n          ]\n          `T.withChildren`\n            [ T.elem Rect\n                [ evalAttr \"width\" (lit 18.0)\n                , evalAttr \"height\" (lit 18.0)\n                , evalAttrStr \"fill\" (str (getAgeColorByName age))\n                ]\n            , T.elem Text\n                [ evalAttr \"x\" (lit 24.0)\n                , evalAttr \"y\" (lit 9.0)\n                , evalAttr \"dy\" (lit 5.6)\n                , evalAttrStr \"text-content\" (str age)\n                , evalAttrStr \"class\" (str \"legend-label\")\n                ]\n            ]\n\n  -- Build tree using nestedJoin\n  -- Note: The tree type is Unit because grid lines/legend are Unit, not StateData\n  let\n    tree :: Tree Unit\n    tree =\n      T.named SVG \"svg\"\n        [ evalAttr \"width\" (lit svgSize)\n        , evalAttr \"height\" (lit svgSize)\n        , evalAttrStr \"viewBox\" (str (\"0 0 \" <> show svgSize <> \" \" <> show svgSize))\n        , evalAttrStr \"class\" (str \"radial-stacked-bar\")\n        ]\n        `T.withChild`\n          ( T.named Group \"plot-area\"\n              [ evalAttrStr \"transform\" (str (\"translate(\" <> show centerX <> \",\" <> show centerY <> \")\")) ]\n              `T.withChildren`\n                [ -- Circular grid lines\n                  T.named Group \"y-axis\" [ evalAttrStr \"text-anchor\" (str \"middle\") ]\n                    `T.withChildren`\n                      ( [ T.elem Text\n                            [ evalAttr \"y\" (lit (-(outerRadius + 10.0)))\n                            , evalAttr \"font-size\" (lit 12.0)\n                            , evalAttrStr \"text-content\" (str \"Population\")\n                            , evalAttrStr \"class\" (str \"axis-label\")\n                            ]\n                        ] <> Array.concatMap makeGridLine gridValues\n                      )\n                , -- Color legend\n                  T.named Group \"legend\" []\n                    `T.withChildren` (Array.mapWithIndex makeLegendItem ageGroups)\n                , -- Data arcs - manually build without nestedJoin to maintain Tree Unit type\n                  T.named Group \"data-arcs\" []\n                    `T.withChildren` (Array.concatMap makeStateArcs states)\n                , -- State labels\n                  T.named Group \"state-labels\" []\n                    `T.withChildren` (map makeStateLabel states)\n                ]\n          )\n\n    -- Helper to create arcs for a single state\n    makeStateArcs :: StateData -> Array (Tree Unit)\n    makeStateArcs stateData =\n      Array.mapWithIndex\n        ( \\ageIdx segment ->\n            let\n              stateIdx = stateData.stateIndex\n              startAngle = toNumber stateIdx * anglePerState - (pi / 2.0)\n              endAngle = startAngle + anglePerState\n            in\n              T.elem Path\n                [ evalAttrStr \"d\" (str (arcPath startAngle endAngle segment.innerRadius segment.outerRadius))\n                , evalAttrStr \"fill\" (str (getAgeColor ageIdx))\n                , evalAttrStr \"class\" (str \"age-arc\")\n                ]\n        )\n        stateData.ageSegments\n\n    -- Helper to create state label\n    makeStateLabel :: StateData -> Tree Unit\n    makeStateLabel stateData =\n      let\n        stateIdx = stateData.stateIndex\n        startAngle = toNumber stateIdx * anglePerState - (pi / 2.0)\n        labelAngle = startAngle + (anglePerState / 2.0)\n        labelRadius = 320.0\n        labelX = labelRadius * cos labelAngle\n        labelY = labelRadius * sin labelAngle\n        rotation = (labelAngle * 180.0 / pi) + 90.0\n      in\n        T.elem Text\n          [ evalAttr \"x\" (lit labelX)\n          , evalAttr \"y\" (lit labelY)\n          , evalAttrStr \"text-anchor\" (str \"middle\")\n          , evalAttr \"font-size\" (lit 10.0)\n          , evalAttrStr \"transform\" (str (\"rotate(\" <> show rotation <> \" \" <> show labelX <> \" \" <> show labelY <> \")\"))\n          , evalAttrStr \"text-content\" (str stateData.state)\n          , evalAttrStr \"class\" (str \"state-label\")\n          ]\n\n  -- Render\n  _ <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Radial Stacked Bar Chart ===\"\n    Console.log \"\"\n    Console.log (\"States: \" <> show (length states))\n    Console.log \"All 50 US states + DC in polar coordinates\"\n    Console.log \"\"\n\n-- | Main entry point - loads data then renders\nradialStackedBar :: String -> Effect Unit\nradialStackedBar selector = launchAff_ do\n  populationData <- loadPopulationData\n  liftEffect $ drawRadialStackedBar selector populationData\n\n"

snippet_anscombesQuartet_content :: String
snippet_anscombesQuartet_content = "module D3.Viz.TreeAPI.AnscombesQuartet where\n\nimport Prelude\n\nimport Data.Array (length, index)\nimport Data.Foldable (sum)\nimport Data.Int (toNumber)\nimport Data.Maybe (fromMaybe)\nimport Data.Number (pow, sqrt)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Axis.Axis (axisBottom, axisLeft, renderAxis)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree, joinData)\nimport PSD3.AST as T\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr, fnAttr)\nimport PSD3.Expr.Expr (lit, str)\nimport Web.DOM.Element (Element)\n\n-- | Anscombe's Quartet - Why visualization matters\n-- |\n-- | Four datasets with IDENTICAL statistics but DIFFERENT distributions\n-- | This demonstrates why summary statistics alone are misleading\n-- |\n-- | Key insight: You MUST visualize data to understand it\n\ntype Point = { x :: Number, y :: Number }\n\ntype Dataset =\n  { name :: String\n  , data :: Array Point\n  , stats :: Statistics\n  }\n\ntype Statistics =\n  { meanX :: Number\n  , meanY :: Number\n  , varianceX :: Number\n  , varianceY :: Number\n  , correlation :: Number\n  }\n\n-- Anscombe's original datasets\ndataset1 :: Array Point\ndataset1 =\n  [ { x: 10.0, y: 8.04 }\n  , { x: 8.0, y: 6.95 }\n  , { x: 13.0, y: 7.58 }\n  , { x: 9.0, y: 8.81 }\n  , { x: 11.0, y: 8.33 }\n  , { x: 14.0, y: 9.96 }\n  , { x: 6.0, y: 7.24 }\n  , { x: 4.0, y: 4.26 }\n  , { x: 12.0, y: 10.84 }\n  , { x: 7.0, y: 4.82 }\n  , { x: 5.0, y: 5.68 }\n  ]\n\ndataset2 :: Array Point\ndataset2 =\n  [ { x: 10.0, y: 9.14 }\n  , { x: 8.0, y: 8.14 }\n  , { x: 13.0, y: 8.74 }\n  , { x: 9.0, y: 8.77 }\n  , { x: 11.0, y: 9.26 }\n  , { x: 14.0, y: 8.10 }\n  , { x: 6.0, y: 6.13 }\n  , { x: 4.0, y: 3.10 }\n  , { x: 12.0, y: 9.13 }\n  , { x: 7.0, y: 7.26 }\n  , { x: 5.0, y: 4.74 }\n  ]\n\ndataset3 :: Array Point\ndataset3 =\n  [ { x: 10.0, y: 7.46 }\n  , { x: 8.0, y: 6.77 }\n  , { x: 13.0, y: 12.74 }\n  , { x: 9.0, y: 7.11 }\n  , { x: 11.0, y: 7.81 }\n  , { x: 14.0, y: 8.84 }\n  , { x: 6.0, y: 6.08 }\n  , { x: 4.0, y: 5.39 }\n  , { x: 12.0, y: 8.15 }\n  , { x: 7.0, y: 6.42 }\n  , { x: 5.0, y: 5.73 }\n  ]\n\ndataset4 :: Array Point\ndataset4 =\n  [ { x: 8.0, y: 6.58 }\n  , { x: 8.0, y: 5.76 }\n  , { x: 8.0, y: 7.71 }\n  , { x: 8.0, y: 8.84 }\n  , { x: 8.0, y: 8.47 }\n  , { x: 8.0, y: 7.04 }\n  , { x: 8.0, y: 5.25 }\n  , { x: 19.0, y: 12.50 }\n  , { x: 8.0, y: 5.56 }\n  , { x: 8.0, y: 7.91 }\n  , { x: 8.0, y: 6.89 }\n  ]\n\n-- Calculate statistics for a dataset\ncalculateStats :: Array Point -> Statistics\ncalculateStats points =\n  let n = toNumber (length points)\n      xs = map _.x points\n      ys = map _.y points\n\n      meanX = sum xs / n\n      meanY = sum ys / n\n\n      varianceX = (sum (map (\\x -> pow (x - meanX) 2.0) xs)) / (n - 1.0)\n      varianceY = (sum (map (\\y -> pow (y - meanY) 2.0) ys)) / (n - 1.0)\n\n      -- Pearson correlation coefficient\n      covariance = (sum (map (\\p -> (p.x - meanX) * (p.y - meanY)) points)) / (n - 1.0)\n      correlation = covariance / (sqrt varianceX * sqrt varianceY)\n\n  in { meanX, meanY, varianceX, varianceY, correlation }\n\n-- All four datasets with statistics\nallDatasets :: Array Dataset\nallDatasets =\n  [ { name: \"A\", data: dataset1, stats: calculateStats dataset1 }\n  , { name: \"B\", data: dataset2, stats: calculateStats dataset2 }\n  , { name: \"C\", data: dataset3, stats: calculateStats dataset3 }\n  , { name: \"D\", data: dataset4, stats: calculateStats dataset4 }\n  ]\n\nanscombesQuartet :: String -> Effect Unit\nanscombesQuartet selector = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Layout parameters\n  -- Compact size for foundational example\n  let plotSize = 140.0\n      margin = { top: 20.0, right: 20.0, bottom: 40.0, left: 50.0 }\n      plotWidth = plotSize - margin.left - margin.right\n      plotHeight = plotSize - margin.top - margin.bottom\n      gap = 20.0\n\n      -- Shared scales across all plots\n      xScale = { domain: { min: 0.0, max: 20.0 }, range: { min: 0.0, max: plotWidth } }\n      yScale = { domain: { min: 0.0, max: 14.0 }, range: { min: plotHeight, max: 0.0 } }\n\n      -- Scale helper functions\n      scaleX :: Number -> Number\n      scaleX value =\n        let domainSpan = xScale.domain.max - xScale.domain.min\n            rangeSpan = xScale.range.max - xScale.range.min\n            normalized = (value - xScale.domain.min) / domainSpan\n        in xScale.range.min + (normalized * rangeSpan)\n\n      scaleY :: Number -> Number\n      scaleY value =\n        let domainSpan = yScale.domain.max - yScale.domain.min\n            rangeSpan = yScale.range.max - yScale.range.min\n            normalized = (value - yScale.domain.min) / domainSpan\n        in yScale.range.min + (normalized * rangeSpan)\n\n      -- Calculate position for each plot in a 2x2 grid\n      getPlotX :: Int -> Number\n      getPlotX idx = if idx `mod` 2 == 0 then 0.0 else plotSize + gap\n\n      getPlotY :: Int -> Number\n      getPlotY idx = if idx < 2 then 0.0 else plotSize + gap\n\n  -- Build a single scatterplot with stats\n  let buildPlot :: Int -> Dataset -> Tree Point\n      buildPlot idx dataset =\n        T.named Group (\"plot-\" <> show idx)\n          [ evalAttrStr \"transform\" (str (\"translate(\" <> show (getPlotX idx) <> \",\" <> show (getPlotY idx) <> \")\"))\n          , evalAttrStr \"class\" (str \"anscombe-plot\")\n          ]\n          `T.withChildren`\n            [ -- Title\n              T.elem Text\n                [ evalAttr \"x\" (lit (plotSize / 2.0))\n                , evalAttr \"y\" (lit 10.0)\n                , evalAttrStr \"text-anchor\" (str \"middle\")\n                , evalAttrStr \"class\" (str \"plot-title\")\n                , evalAttrStr \"textContent\" (str dataset.name)\n                ]\n\n            , -- Main plot area\n              T.named Group \"plot-area\"\n                [ evalAttrStr \"transform\" (str (\"translate(\" <> show margin.left <> \",\" <> show margin.top <> \")\")) ]\n                `T.withChildren`\n                  [ -- X-axis\n                    T.named Group \"x-axis\"\n                      [ evalAttrStr \"transform\" (str (\"translate(0,\" <> show plotHeight <> \")\")) ]\n                      `T.withChild` renderAxis (axisBottom xScale)\n\n                  , -- Y-axis\n                    T.named Group \"y-axis\"\n                      []\n                      `T.withChild` renderAxis (axisLeft yScale)\n\n                  , -- Data points\n                    joinData (\"points-\" <> show idx) \"circle\" dataset.data $ \\d ->\n                      T.elem Circle\n                        [ evalAttr \"cx\" (lit (scaleX d.x))\n                        , evalAttr \"cy\" (lit (scaleY d.y))\n                        , evalAttr \"r\" (lit 3.0)\n                        , evalAttrStr \"fill\" (str \"steelblue\")\n                        ]\n                  ]\n            ]\n\n  -- Build all four plots\n  let svgWidth = (plotSize * 2.0) + gap\n      svgHeight = (plotSize * 2.0) + gap\n\n      tree :: Tree Point\n      tree =\n        T.named SVG \"svg\"\n          [ evalAttr \"width\" (lit svgWidth)\n          , evalAttr \"height\" (lit svgHeight)\n          , evalAttrStr \"viewBox\" (str (\"0 0 \" <> show svgWidth <> \" \" <> show svgHeight))\n          , evalAttrStr \"id\" (str \"anscombes-quartet-svg\")\n          , evalAttrStr \"class\" (str \"tree-api-example\")\n          ]\n          `T.withChildren`\n            [ buildPlot 0 (getDataset 0)\n            , buildPlot 1 (getDataset 1)\n            , buildPlot 2 (getDataset 2)\n            , buildPlot 3 (getDataset 3)\n            ]\n\n      -- Safe dataset getter with fallback\n      getDataset :: Int -> Dataset\n      getDataset idx = fromMaybe (allDatasets `index` 0 # fromMaybe emptyDataset) (allDatasets `index` idx)\n\n      emptyDataset :: Dataset\n      emptyDataset = { name: \"Empty\", data: [], stats: { meanX: 0.0, meanY: 0.0, varianceX: 0.0, varianceY: 0.0, correlation: 0.0 } }\n\n  -- Render the tree\n  _ <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Anscombe's Quartet ===\"\n    Console.log \"\"\n    Console.log \"Four datasets with IDENTICAL statistics:\"\n    Console.log \"  - Mean X ≈ 9.0\"\n    Console.log \"  - Mean Y ≈ 7.5\"\n    Console.log \"  - Variance X ≈ 11.0\"\n    Console.log \"  - Variance Y ≈ 4.1\"\n    Console.log \"  - Correlation ≈ 0.816\"\n    Console.log \"\"\n    Console.log \"But look at the plots - completely different distributions!\"\n    Console.log \"  I: Linear relationship\"\n    Console.log \"  II: Curved relationship\"\n    Console.log \"  III: Linear with outlier\"\n    Console.log \"  IV: Vertical line with outlier\"\n    Console.log \"\"\n    Console.log \"THIS IS WHY VISUALIZATION MATTERS.\"\n    Console.log \"Summary statistics alone don't tell the story.\"\n    Console.log \"\"\n\n-- Helper to format numbers to 2 decimal places\nformatNum :: Number -> String\nformatNum n =\n  let rounded = (n * 100.0) / 100.0  -- Simple rounding\n  in show rounded\n\n"

snippet_wealthHealth_content :: String
snippet_wealthHealth_content = "module D3.Viz.TreeAPI.WealthHealthDraw where\n\nimport Prelude\n\nimport Data.Int (floor)\nimport Data.Number (log, sqrt)\nimport Effect (Effect)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport PSD3.Internal.Behavior.Types (Behavior(..), MouseEventInfo)\nimport PSD3.Tooltip (showTooltip, hideTooltip)\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr, fnAttr, fnAttrStr)\nimport PSD3.Expr.Expr (lit, str)\nimport Web.DOM.Element (Element)\n\n-- | Type alias for a nation data point ready for visualization\ntype NationPoint =\n  { name :: String\n  , income :: Number\n  , population :: Number\n  , lifeExpectancy :: Number\n  , region :: String -- Region name for display\n  , regionColor :: String -- Color for the region\n  }\n\n-- | Configuration for visualization dimensions and margins\ntype VizConfig =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultConfig :: VizConfig\ndefaultConfig =\n  { width: 960.0\n  , height: 560.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 35.0\n  , marginLeft: 40.0\n  }\n\n-- | Scale functions\nscaleX :: VizConfig -> Number -> Number\nscaleX config income =\n  let\n    -- Logarithmic scale for income ($200 to $100,000)\n    minLog = 5.298317 -- log(200)\n    maxLog = 11.512925 -- log(100000)\n    logIncome = if income > 0.0 then log income else minLog\n    normalized = (logIncome - minLog) / (maxLog - minLog)\n    rangeWidth = config.width - config.marginLeft - config.marginRight\n  in\n    config.marginLeft + (normalized * rangeWidth)\n\nscaleY :: VizConfig -> Number -> Number\nscaleY config lifeExpectancy =\n  let\n    -- Linear scale for life expectancy (14 to 86 years)\n    minLife = 14.0\n    maxLife = 86.0\n    normalized = (lifeExpectancy - minLife) / (maxLife - minLife)\n    rangeHeight = config.height - config.marginTop - config.marginBottom\n  in\n    config.height - config.marginBottom - (normalized * rangeHeight)\n\nscaleRadius :: Number -> Number\nscaleRadius population =\n  let\n    -- Square root scale for population (area proportional to population)\n    minRadius = 3.0\n    maxRadius = 80.0\n    maxPop = 5000000000.0 -- 5 billion\n    normalized = population / maxPop\n    scaled = sqrt normalized * maxRadius\n  in\n    max minRadius scaled\n\n-- | Format income values for axis labels\nformatIncome :: Number -> String\nformatIncome value\n  | value >= 1000.0 = \"$\" <> show (floor (value / 1000.0)) <> \"k\"\n  | otherwise = \"$\" <> show (floor value)\n\n-- | Tick values for axes\nxTicks :: Array Number\nxTicks = [ 200.0, 500.0, 1000.0, 2000.0, 5000.0, 10000.0, 20000.0, 50000.0, 100000.0 ]\n\nyTicks :: Array Number\nyTicks = [ 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0 ]\n\n-- | Build vertical grid line\nverticalGridLine :: VizConfig -> Number -> Tree NationPoint\nverticalGridLine config tickValue =\n  T.elem Line\n    [ evalAttr \"x1\" (lit (0.5 + scaleX config tickValue))\n    , evalAttr \"x2\" (lit (0.5 + scaleX config tickValue))\n    , evalAttr \"y1\" (lit config.marginTop)\n    , evalAttr \"y2\" (lit (config.height - config.marginBottom))\n    ]\n\n-- | Build horizontal grid line\nhorizontalGridLine :: VizConfig -> Number -> Tree NationPoint\nhorizontalGridLine config tickValue =\n  T.elem Line\n    [ evalAttr \"y1\" (lit (0.5 + scaleY config tickValue))\n    , evalAttr \"y2\" (lit (0.5 + scaleY config tickValue))\n    , evalAttr \"x1\" (lit config.marginLeft)\n    , evalAttr \"x2\" (lit (config.width - config.marginRight))\n    ]\n\n-- | Build x-axis tick mark and label\nxAxisTick :: VizConfig -> Number -> Tree NationPoint\nxAxisTick config tickValue =\n  T.named Group \"x-tick\" []\n    `T.withChildren`\n      [ T.elem Line\n          [ evalAttr \"x1\" (lit (scaleX config tickValue))\n          , evalAttr \"x2\" (lit (scaleX config tickValue))\n          , evalAttr \"y1\" (lit (config.height - config.marginBottom))\n          , evalAttr \"y2\" (lit (config.height - config.marginBottom + 6.0))\n          , evalAttrStr \"stroke\" (str \"#333\")\n          , evalAttr \"stroke-width\" (lit 1.0)\n          ]\n      , T.elem Text\n          [ evalAttr \"x\" (lit (scaleX config tickValue))\n          , evalAttr \"y\" (lit (config.height - config.marginBottom + 15.0))\n          , evalAttrStr \"text-anchor\" (str \"middle\")\n          , evalAttr \"font-size\" (lit 10.0)\n          , evalAttrStr \"fill\" (str \"#333\")\n          , evalAttrStr \"textContent\" (str (formatIncome tickValue))\n          ]\n      ]\n\n-- | Build y-axis tick mark and label\nyAxisTick :: VizConfig -> Number -> Tree NationPoint\nyAxisTick config tickValue =\n  T.named Group \"y-tick\" []\n    `T.withChildren`\n      [ T.elem Line\n          [ evalAttr \"x1\" (lit (config.marginLeft - 6.0))\n          , evalAttr \"x2\" (lit config.marginLeft)\n          , evalAttr \"y1\" (lit (scaleY config tickValue))\n          , evalAttr \"y2\" (lit (scaleY config tickValue))\n          , evalAttrStr \"stroke\" (str \"#333\")\n          , evalAttr \"stroke-width\" (lit 1.0)\n          ]\n      , T.elem Text\n          [ evalAttr \"x\" (lit (config.marginLeft - 10.0))\n          , evalAttr \"y\" (lit (scaleY config tickValue + 3.0))\n          , evalAttrStr \"text-anchor\" (str \"end\")\n          , evalAttr \"font-size\" (lit 10.0)\n          , evalAttrStr \"fill\" (str \"#333\")\n          , evalAttrStr \"textContent\" (str (show $ floor tickValue))\n          ]\n      ]\n\n-- | Initialize the visualization - creates SVG structure and returns update function\ninitWealthHealth :: String -> Effect (Array NationPoint -> Effect Unit)\ninitWealthHealth selector = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let config = defaultConfig\n\n  -- Build the static visualization tree (without data-bound circles)\n  let\n    staticTree :: Tree NationPoint\n    staticTree =\n      T.named SVG \"svg\"\n        [ evalAttr \"width\" (lit config.width)\n        , evalAttr \"height\" (lit config.height)\n        , evalAttrStr \"viewBox\" (str (\"0 0 \" <> show config.width <> \" \" <> show config.height))\n        , evalAttrStr \"class\" (str \"wealth-health-viz\")\n        ]\n        `T.withChildren`\n          [ -- Grid lines\n            T.named Group \"grid\"\n              [ evalAttrStr \"stroke\" (str \"currentColor\")\n              , evalAttr \"stroke-opacity\" (lit 0.1)\n              ]\n              `T.withChildren`\n                ( map (verticalGridLine config) xTicks <>\n                    map (horizontalGridLine config) yTicks\n                )\n\n          -- X-axis\n          , T.named Group \"x-axis\" []\n              `T.withChildren`\n                [ T.elem Line\n                    [ evalAttr \"x1\" (lit config.marginLeft)\n                    , evalAttr \"y1\" (lit (config.height - config.marginBottom))\n                    , evalAttr \"x2\" (lit (config.width - config.marginRight))\n                    , evalAttr \"y2\" (lit (config.height - config.marginBottom))\n                    , evalAttrStr \"stroke\" (str \"#333\")\n                    , evalAttr \"stroke-width\" (lit 1.5)\n                    ]\n                ]\n\n          -- X-axis ticks\n          , T.named Group \"x-ticks\" []\n              `T.withChildren` map (xAxisTick config) xTicks\n\n          -- X-axis label\n          , T.elem Text\n              [ evalAttr \"x\" (lit (config.width / 2.0))\n              , evalAttr \"y\" (lit (config.height - 5.0))\n              , evalAttrStr \"text-anchor\" (str \"middle\")\n              , evalAttr \"font-size\" (lit 14.0)\n              , evalAttrStr \"fill\" (str \"#333\")\n              , evalAttrStr \"textContent\" (str \"Income per Person (GDP/capita, PPP$ inflation-adjusted)\")\n              ]\n\n          -- Y-axis\n          , T.named Group \"y-axis\" []\n              `T.withChildren`\n                [ T.elem Line\n                    [ evalAttr \"x1\" (lit config.marginLeft)\n                    , evalAttr \"y1\" (lit config.marginTop)\n                    , evalAttr \"x2\" (lit config.marginLeft)\n                    , evalAttr \"y2\" (lit (config.height - config.marginBottom))\n                    , evalAttrStr \"stroke\" (str \"#333\")\n                    , evalAttr \"stroke-width\" (lit 1.5)\n                    ]\n                ]\n\n          -- Y-axis ticks\n          , T.named Group \"y-ticks\" []\n              `T.withChildren` map (yAxisTick config) yTicks\n\n          -- Y-axis label\n          , T.elem Text\n              [ evalAttr \"x\" (lit 15.0)\n              , evalAttr \"y\" (lit (config.height / 2.0))\n              , evalAttrStr \"text-anchor\" (str \"middle\")\n              , evalAttr \"font-size\" (lit 14.0)\n              , evalAttrStr \"fill\" (str \"#333\")\n              , evalAttrStr \"textContent\" (str \"Life Expectancy (years)\")\n              ]\n\n          -- Empty group for nations (will be populated by update function)\n          , T.named Group \"nations-container\" [ evalAttrStr \"class\" (str \"nations\") ] `T.withChildren` []\n          ]\n\n  -- Render the static structure\n  _ <- renderTree container staticTree\n\n  -- Return the update function using declarative TreeAPI\n  pure $ \\nations -> runD3v2M do\n    -- Select the nations container\n    nationsContainer <- select \"#wealth-health-viz .nations\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n    -- Build nations tree with declarative data join and behaviors\n    -- TreeAPI handles enter/update/exit automatically\n    let\n      nationsTree :: Tree NationPoint\n      nationsTree =\n        T.joinData \"nations\" \"circle\" nations $ \\_ ->\n          T.elem Circle\n            [ fnAttr \"cx\" ((\\n -> scaleX config n.income) :: NationPoint -> Number)\n            , fnAttr \"cy\" ((\\n -> scaleY config n.lifeExpectancy) :: NationPoint -> Number)\n            , fnAttr \"r\" ((\\n -> scaleRadius n.population) :: NationPoint -> Number)\n            , fnAttrStr \"fill\" ((_.regionColor) :: NationPoint -> String)\n            , evalAttr \"fill-opacity\" (lit 0.7)\n            , evalAttrStr \"stroke\" (str \"#333\")\n            , evalAttr \"stroke-width\" (lit 0.5)\n            , evalAttrStr \"class\" (str \"nation-circle\")\n            ]\n            `T.withBehaviors`\n              [ -- Tooltip on mouse enter\n                MouseEnterWithInfo \\(info :: MouseEventInfo NationPoint) -> do\n                  let nation = info.datum\n                  let\n                    content = \"<strong>\" <> nation.name <> \"</strong><br/>\"\n                      <> \"Region: \"\n                      <> nation.region\n                      <> \"<br/>\"\n                      <> \"Income: $\"\n                      <> show (floor nation.income)\n                      <> \"<br/>\"\n                      <> \"Life Expectancy: \"\n                      <> show (floor nation.lifeExpectancy)\n                      <> \" years<br/>\"\n                      <> \"Population: \"\n                      <> formatPopulation nation.population\n                  showTooltip content info.clientX info.clientY\n              , -- Hide tooltip on mouse leave\n                MouseLeaveWithInfo \\(_ :: MouseEventInfo NationPoint) -> hideTooltip\n              ]\n\n    -- Render the tree (handles enter/update/exit internally)\n    _ <- renderTree nationsContainer nationsTree\n\n    pure unit\n\n-- | Format population for display\nformatPopulation :: Number -> String\nformatPopulation n\n  | n >= 1000000000.0 = show (floor (n / 1000000000.0)) <> \"B\"\n  | n >= 1000000.0 = show (floor (n / 1000000.0)) <> \"M\"\n  | n >= 1000.0 = show (floor (n / 1000.0)) <> \"K\"\n  | otherwise = show (floor n)\n"

snippet_splom_content :: String
snippet_splom_content = "-- | SPLOM Visualization\n-- |\n-- | Brushable Scatterplot Matrix using PSD3 library APIs.\n-- | Demonstrates:\n-- | - PSD3.Scale for scales (linear, domain, range, ticks, invert, nice)\n-- | - PSD3.Brush for brush interaction\n-- | - PSD3 Tree API for declarative rendering\n-- |\n-- | This is a pure PureScript implementation with no local FFI.\n-- | State is managed externally (e.g., by a Halogen component).\nmodule D3.Viz.SPLOM.SPLOM\n  ( -- Types\n    SPLOMConfig\n  , SPLOMState\n  , DimensionScale\n  , BrushBounds\n  , Cell\n  -- State management\n  , initialState\n  , defaultConfig\n  -- Rendering\n  , renderSPLOM\n  , updatePointVisibility\n  -- Brush interaction\n  , attachBrushes\n  , clearBrushSelection\n  , isPointSelected\n  -- Queries\n  , getSelectedCount\n  , getTotalCount\n  ) where\n\nimport Prelude\n\nimport Data.Array (filter, length, mapWithIndex, mapMaybe, concat)\nimport Data.Array as Array\nimport Data.Foldable (minimum, maximum, for_)\nimport Data.Traversable (traverse)\nimport Data.Int (toNumber)\nimport Data.Int as Int\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number (floor) as Number\nimport Data.String.CodeUnits as StringCU\nimport Effect (Effect)\nimport Effect.Console as Console\nimport PSD3.Scale as Scale\nimport PSD3.Scale (ContinuousScale, applyScale, ticks, nice)\nimport PSD3.Internal.Attribute (Attribute)\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr)\nimport PSD3.Expr.Expr (lit, str)\nimport PSD3.Brush (attachBrush, clearBrush, BrushHandle, BrushSelection, BrushConfig)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree, clear)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2M)\nimport PSD3.Internal.Selection.Types (ElementType(..)) as ET\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport D3.Viz.SPLOM.Types (Penguin, NumericDimension, dimensionLabel, dimensionKey, getDimensionValue, speciesColor, allDimensions)\nimport Web.DOM.ParentNode (querySelector, QuerySelector(..))\nimport Web.HTML (window)\nimport Web.HTML.Window (document)\nimport Web.HTML.HTMLDocument (toParentNode)\n\n-- | Configuration for SPLOM visualization\ntype SPLOMConfig =\n  { cellSize :: Number\n  , cellPadding :: Number\n  , matrixPadding :: Number\n  , pointRadius :: Number\n  , tickCount :: Int\n  , dimensions :: Array NumericDimension\n  }\n\n-- | Default configuration\ndefaultConfig :: SPLOMConfig\ndefaultConfig =\n  { cellSize: 120.0\n  , cellPadding: 12.0\n  , matrixPadding: 50.0\n  , pointRadius: 2.5\n  , tickCount: 5\n  , dimensions: allDimensions\n  }\n\n-- | Brush selection in data space\ntype BrushBounds =\n  { dimX :: NumericDimension\n  , dimY :: NumericDimension\n  , xMin :: Number\n  , xMax :: Number\n  , yMin :: Number\n  , yMax :: Number\n  }\n\n-- | Cell in the matrix\ntype Cell =\n  { row :: Int\n  , col :: Int\n  , dimX :: NumericDimension\n  , dimY :: NumericDimension\n  }\n\n-- | Scale for a dimension\ntype DimensionScale =\n  { dimension :: NumericDimension\n  , scale :: ContinuousScale\n  }\n\n-- | SPLOM state (managed externally, e.g., by Halogen component)\ntype SPLOMState =\n  { penguins :: Array Penguin\n  , validPenguins :: Array Penguin\n  , config :: SPLOMConfig\n  , scales :: Array DimensionScale\n  , selection :: Maybe BrushBounds\n  , brushHandles :: Array { cell :: Cell, handle :: BrushHandle }\n  , activeBrushCell :: Maybe Cell\n  , containerSelector :: String\n  }\n\n-- | Create initial state from penguins data\ninitialState :: String -> Array Penguin -> SPLOMState\ninitialState containerSelector penguins =\n  let\n    config = defaultConfig\n    validPenguins = filterValidPenguins config.dimensions penguins\n    scales = createScales validPenguins config.dimensions config.cellPadding config.cellSize\n  in\n    { penguins\n    , validPenguins\n    , config\n    , scales\n    , selection: Nothing\n    , brushHandles: []\n    , activeBrushCell: Nothing\n    , containerSelector\n    }\n\n-- | Filter penguins to those with all dimension values\nfilterValidPenguins :: Array NumericDimension -> Array Penguin -> Array Penguin\nfilterValidPenguins dimensions penguins =\n  filter (\\p ->\n    Array.all (\\dim -> case getDimensionValue dim p of\n      Just _ -> true\n      Nothing -> false\n    ) dimensions\n  ) penguins\n\n-- | Create scales for all dimensions\ncreateScales :: Array Penguin -> Array NumericDimension -> Number -> Number -> Array DimensionScale\ncreateScales penguins dimensions cellPadding cellSize =\n  dimensions <#> \\dim ->\n    let\n      values = mapMaybe (getDimensionValue dim) penguins\n      minVal = fromMaybe 0.0 $ minimum values\n      maxVal = fromMaybe 100.0 $ maximum values\n      scale = Scale.linear\n        # Scale.domain [minVal, maxVal]\n        # Scale.range [cellPadding, cellSize - cellPadding]\n        # nice\n    in\n      { dimension: dim, scale }\n\n-- | Find scale for a dimension\nfindScale :: NumericDimension -> Array DimensionScale -> Maybe ContinuousScale\nfindScale dim scales =\n  Array.find (\\s -> s.dimension == dim) scales <#> _.scale\n\n-- | Check if point is within selection\nisPointSelected :: Maybe BrushBounds -> Penguin -> Boolean\nisPointSelected Nothing _ = true\nisPointSelected (Just bounds) penguin =\n  case getDimensionValue bounds.dimX penguin, getDimensionValue bounds.dimY penguin of\n    Just xVal, Just yVal ->\n      xVal >= bounds.xMin && xVal <= bounds.xMax &&\n      yVal >= bounds.yMin && yVal <= bounds.yMax\n    _, _ -> false\n\n-- | Generate cells for matrix\ngenerateCells :: Array NumericDimension -> Array Cell\ngenerateCells dimensions =\n  concat $ mapWithIndex (\\row dimY ->\n    mapWithIndex (\\col dimX ->\n      { row, col, dimX, dimY }\n    ) dimensions\n  ) dimensions\n\n-- | Get off-diagonal cells only\noffDiagonalCells :: Array Cell -> Array Cell\noffDiagonalCells = filter (\\c -> c.row /= c.col)\n\n-- | Get selected count\ngetSelectedCount :: SPLOMState -> Int\ngetSelectedCount state =\n  length $ filter (isPointSelected state.selection) state.validPenguins\n\n-- | Get total count\ngetTotalCount :: SPLOMState -> Int\ngetTotalCount state = length state.validPenguins\n\n-- =============================================================================\n-- Rendering\n-- =============================================================================\n\n-- | Render the SPLOM with current state (full re-render, clears container)\nrenderSPLOM :: SPLOMState -> Effect Unit\nrenderSPLOM state = runD3v2M $ renderSPLOMWithState state\n\n-- | Update point visibility without full re-render\n-- | This is much faster than full re-render and preserves brush elements\nupdatePointVisibility :: SPLOMState -> Effect Unit\nupdatePointVisibility state =\n  case state.selection of\n    Nothing ->\n      -- No selection - show all points\n      updatePointVisibility_ state.containerSelector Nothing state.config.pointRadius\n    Just bounds ->\n      -- Convert to FFI-friendly format with string dimension keys\n      let ffiSelection =\n            { dimX: dimensionKey bounds.dimX\n            , dimY: dimensionKey bounds.dimY\n            , xMin: bounds.xMin\n            , xMax: bounds.xMax\n            , yMin: bounds.yMin\n            , yMax: bounds.yMax\n            }\n      in updatePointVisibility_ state.containerSelector (Just ffiSelection) state.config.pointRadius\n\n-- | FFI-friendly selection bounds (uses string keys instead of ADT)\ntype FFIBrushBounds =\n  { dimX :: String\n  , dimY :: String\n  , xMin :: Number\n  , xMax :: Number\n  , yMin :: Number\n  , yMax :: Number\n  }\n\n-- | FFI for updating point visibility\nforeign import updatePointVisibility_\n  :: String              -- Container selector\n  -> Maybe FFIBrushBounds -- Current selection bounds (with string dimension keys)\n  -> Number              -- Point radius when selected\n  -> Effect Unit\n\n-- | Internal render function\nrenderSPLOMWithState :: SPLOMState -> D3v2M Unit\nrenderSPLOMWithState state = do\n  -- Clear existing content first to avoid duplicate SVGs\n  clear state.containerSelector\n\n  container <- select state.containerSelector\n\n  let n = length state.config.dimensions\n  let totalSize = toNumber n * state.config.cellSize + state.config.matrixPadding * 2.0\n  let cells = generateCells state.config.dimensions\n\n  -- Build tree\n  let tree = buildSPLOMTree state cells totalSize\n\n  -- Render\n  _ <- renderTree container tree\n  pure unit\n\n-- | Build the complete SPLOM tree\nbuildSPLOMTree :: SPLOMState -> Array Cell -> Number -> Tree Penguin\nbuildSPLOMTree state cells totalSize =\n  T.named ET.SVG \"svg\"\n    [ evalAttr \"width\" (lit totalSize)\n    , evalAttr \"height\" (lit totalSize)\n    , evalAttrStr \"viewBox\" (str (\"0 0 \" <> show totalSize <> \" \" <> show totalSize))\n    , evalAttrStr \"class\" (str \"splom-svg\")\n    , evalAttrStr \"id\" (str \"splom-matrix\")\n    ]\n    `T.withChildren`\n      [ -- Background\n        T.elem ET.Rect\n          [ evalAttr \"width\" (lit totalSize)\n          , evalAttr \"height\" (lit totalSize)\n          , evalAttrStr \"fill\" (str \"white\")\n          ]\n\n      , -- All cells\n        T.named ET.Group \"cells\" [] `T.withChildren`\n          (cells <#> buildCell state)\n\n      , -- Axis labels\n        buildAxisLabels state\n      ]\n\n-- | Build a single cell\nbuildCell :: SPLOMState -> Cell -> Tree Penguin\nbuildCell state cell =\n  let\n    cellSize = state.config.cellSize\n    isDiagonal = cell.row == cell.col\n    mXScale = findScale cell.dimX state.scales\n    mYScale = findScale cell.dimY state.scales\n\n    -- Filter penguins valid for this cell\n    cellPenguins = filter (\\p ->\n      case getDimensionValue cell.dimX p, getDimensionValue cell.dimY p of\n        Just _, Just _ -> true\n        _, _ -> false\n    ) state.validPenguins\n\n    cellId = \"cell-\" <> show cell.row <> \"-\" <> show cell.col\n  in\n    T.named ET.Group cellId\n      [ evalAttrStr \"id\" (str cellId)\n      , evalAttrStr \"class\" (str $ if isDiagonal then \"cell diagonal\" else \"cell off-diagonal\")\n      , evalAttrStr \"transform\" (str (\"translate(\" <> show (state.config.matrixPadding + toNumber cell.col * cellSize) <> \",\"\n                               <> show (state.config.matrixPadding + toNumber cell.row * cellSize) <> \")\"))\n      ]\n      `T.withChildren`\n        ([ -- Cell frame\n           T.elem ET.Rect\n             [ evalAttrStr \"class\" (str \"cell-frame\")\n             , evalAttr \"width\" (lit cellSize)\n             , evalAttr \"height\" (lit cellSize)\n             , evalAttrStr \"fill\" (str \"none\")\n             , evalAttrStr \"stroke\" (str \"#aaa\")\n             , evalAttr \"stroke-width\" (lit 0.5)\n             ]\n         ] <> (if isDiagonal\n               then buildDiagonalContent state cellPenguins cell mXScale\n               else buildOffDiagonalContent state cellPenguins cell mXScale mYScale))\n\n-- | Build diagonal cell content (label + scatter)\nbuildDiagonalContent :: SPLOMState -> Array Penguin -> Cell -> Maybe ContinuousScale -> Array (Tree Penguin)\nbuildDiagonalContent state penguins cell mScale =\n  case mScale of\n    Nothing -> []\n    Just scale ->\n      let\n        cellSize = state.config.cellSize\n        padding = state.config.cellPadding\n        tickValues = ticks state.config.tickCount scale\n\n        -- Get domain bounds from the scale\n        -- We use the tick values to find min/max\n        allTicks = ticks 10 scale\n        minVal = fromMaybe 0.0 $ minimum allTicks\n        maxVal = fromMaybe 100.0 $ maximum allTicks\n\n        -- Inverted Y scale for SW-NE diagonal\n        yScaleInverted = Scale.linear\n          # Scale.domain [minVal, maxVal]\n          # Scale.range [cellSize - padding, padding]\n\n        label = dimensionLabel cell.dimX\n        shortLabel = shortenLabel label\n\n      in\n        [ -- Grid lines (vertical)\n          T.named ET.Group \"grid-v\" [] `T.withChildren`\n            (tickValues <#> \\tick ->\n              T.elem ET.Line\n                [ evalAttr \"x1\" (lit (applyScale scale tick))\n                , evalAttr \"x2\" (lit (applyScale scale tick))\n                , evalAttr \"y1\" (lit padding)\n                , evalAttr \"y2\" (lit (cellSize - padding))\n                , evalAttrStr \"stroke\" (str \"#eee\")\n                , evalAttr \"stroke-width\" (lit 0.5)\n                ])\n\n        , -- Grid lines (horizontal)\n          T.named ET.Group \"grid-h\" [] `T.withChildren`\n            (tickValues <#> \\tick ->\n              T.elem ET.Line\n                [ evalAttr \"x1\" (lit padding)\n                , evalAttr \"x2\" (lit (cellSize - padding))\n                , evalAttr \"y1\" (lit (applyScale scale tick))\n                , evalAttr \"y2\" (lit (applyScale scale tick))\n                , evalAttrStr \"stroke\" (str \"#eee\")\n                , evalAttr \"stroke-width\" (lit 0.5)\n                ])\n\n        , -- Label\n          T.elem ET.Text\n            [ evalAttrStr \"class\" (str \"cell-label\")\n            , evalAttr \"x\" (lit (padding + 4.0))\n            , evalAttr \"y\" (lit (padding + 12.0))\n            , evalAttr \"font-size\" (lit 11.0)\n            , evalAttrStr \"font-weight\" (str \"bold\")\n            , evalAttrStr \"fill\" (str \"#333\")\n            , evalAttrStr \"textContent\" (str shortLabel)\n            ]\n\n        , -- Identity line (SW-NE)\n          T.elem ET.Line\n            [ evalAttrStr \"class\" (str \"identity-line\")\n            , evalAttr \"x1\" (lit (applyScale scale minVal))\n            , evalAttr \"y1\" (lit (applyScale yScaleInverted minVal))\n            , evalAttr \"x2\" (lit (applyScale scale maxVal))\n            , evalAttr \"y2\" (lit (applyScale yScaleInverted maxVal))\n            , evalAttrStr \"stroke\" (str \"#333\")\n            , evalAttr \"stroke-width\" (lit 1.0)\n            , evalAttrStr \"stroke-dasharray\" (str \"2,2\")\n            ]\n\n        , -- Diagonal scatter points\n          T.named ET.Group \"diag-points\" [] `T.withChildren`\n            (mapMaybe (\\p ->\n              case getDimensionValue cell.dimX p of\n                Just val -> Just $\n                  T.elem ET.Circle\n                    [ evalAttrStr \"class\" (str \"diag-point\")\n                    , evalAttr \"cx\" (lit (applyScale scale val))\n                    , evalAttr \"cy\" (lit (applyScale yScaleInverted val))\n                    , evalAttr \"r\" (lit 1.5)\n                    , evalAttrStr \"fill\" (str (speciesColor p.species))\n                    , evalAttr \"fill-opacity\" (lit 0.7)\n                    ]\n                Nothing -> Nothing\n            ) penguins)\n        ]\n\n-- | Build off-diagonal cell content (scatter plot)\nbuildOffDiagonalContent :: SPLOMState -> Array Penguin -> Cell -> Maybe ContinuousScale -> Maybe ContinuousScale -> Array (Tree Penguin)\nbuildOffDiagonalContent state penguins cell mXScale mYScale =\n  case mXScale, mYScale of\n    Just xScale, Just yScale ->\n      let\n        cellSize = state.config.cellSize\n        padding = state.config.cellPadding\n        xTicks = ticks state.config.tickCount xScale\n        yTicks = ticks state.config.tickCount yScale\n\n      in\n        [ -- Vertical grid lines\n          T.named ET.Group \"grid-v\" [] `T.withChildren`\n            (xTicks <#> \\tick ->\n              T.elem ET.Line\n                [ evalAttr \"x1\" (lit (applyScale xScale tick))\n                , evalAttr \"x2\" (lit (applyScale xScale tick))\n                , evalAttr \"y1\" (lit padding)\n                , evalAttr \"y2\" (lit (cellSize - padding))\n                , evalAttrStr \"stroke\" (str \"#eee\")\n                , evalAttr \"stroke-width\" (lit 0.5)\n                ])\n\n        , -- Horizontal grid lines\n          T.named ET.Group \"grid-h\" [] `T.withChildren`\n            (yTicks <#> \\tick ->\n              T.elem ET.Line\n                [ evalAttr \"x1\" (lit padding)\n                , evalAttr \"x2\" (lit (cellSize - padding))\n                , evalAttr \"y1\" (lit (applyScale yScale tick))\n                , evalAttr \"y2\" (lit (applyScale yScale tick))\n                , evalAttrStr \"stroke\" (str \"#eee\")\n                , evalAttr \"stroke-width\" (lit 0.5)\n                ])\n\n        , -- Scatter points\n          T.named ET.Group \"points\" [] `T.withChildren`\n            (mapMaybe (\\p ->\n              case getDimensionValue cell.dimX p, getDimensionValue cell.dimY p of\n                Just xVal, Just yVal ->\n                  let\n                    selected = isPointSelected state.selection p\n                    pointOpacity = if selected then 0.7 else 0.1\n                    pointRadius = if selected then state.config.pointRadius else 1.5\n                    -- Store all dimension values as data attributes for FFI access\n                    billLen = fromMaybe 0.0 p.billLength\n                    billDep = fromMaybe 0.0 p.billDepth\n                    flipLen = fromMaybe 0.0 p.flipperLength\n                    bodyMas = fromMaybe 0.0 p.bodyMass\n                  in Just $\n                    T.elem ET.Circle\n                      [ evalAttrStr \"class\" (str \"point\")\n                      , evalAttr \"cx\" (lit (applyScale xScale xVal))\n                      , evalAttr \"cy\" (lit (applyScale yScale yVal))\n                      , evalAttr \"r\" (lit pointRadius)\n                      , evalAttrStr \"fill\" (str (speciesColor p.species))\n                      , evalAttr \"fill-opacity\" (lit pointOpacity)\n                      , evalAttrStr \"stroke\" (str \"none\")\n                      , dataAttr \"bill-length\" billLen\n                      , dataAttr \"bill-depth\" billDep\n                      , dataAttr \"flipper-length\" flipLen\n                      , dataAttr \"body-mass\" bodyMas\n                      ]\n                _, _ -> Nothing\n            ) penguins)\n\n        , -- Brush overlay (empty group for brush attachment)\n          T.named ET.Group \"brush\" [ evalAttrStr \"class\" (str \"brush\") ]\n        ]\n    _, _ -> []\n\n-- | Build axis labels\nbuildAxisLabels :: SPLOMState -> Tree Penguin\nbuildAxisLabels state =\n  let\n    n = length state.scales\n    cellSize = state.config.cellSize\n    padding = state.config.matrixPadding\n  in\n    T.named ET.Group \"axis-labels\" []\n      `T.withChildren`\n        (concat\n          [ -- Bottom axis labels\n            mapWithIndex (\\i dimScale ->\n              let\n                tickValues = ticks state.config.tickCount dimScale.scale\n                xOffset = padding + toNumber i * cellSize\n              in\n                T.named ET.Group (\"axis-bottom-\" <> show i)\n                  [ evalAttrStr \"transform\" (str (\"translate(\" <> show xOffset <> \",\" <> show (padding + toNumber n * cellSize) <> \")\")) ]\n                  `T.withChildren`\n                    (tickValues <#> \\tick ->\n                      T.elem ET.Text\n                        [ evalAttr \"x\" (lit (applyScale dimScale.scale tick))\n                        , evalAttr \"y\" (lit 12.0)\n                        , evalAttrStr \"text-anchor\" (str \"middle\")\n                        , evalAttr \"font-size\" (lit 8.0)\n                        , evalAttrStr \"fill\" (str \"#666\")\n                        , evalAttrStr \"textContent\" (str (formatTick tick))\n                        ])\n            ) state.scales\n\n          , -- Left axis labels\n            mapWithIndex (\\i dimScale ->\n              let\n                tickValues = ticks state.config.tickCount dimScale.scale\n                yOffset = padding + toNumber i * cellSize\n              in\n                T.named ET.Group (\"axis-left-\" <> show i)\n                  [ evalAttrStr \"transform\" (str (\"translate(\" <> show padding <> \",\" <> show yOffset <> \")\")) ]\n                  `T.withChildren`\n                    (tickValues <#> \\tick ->\n                      T.elem ET.Text\n                        [ evalAttr \"x\" (lit (-4.0))\n                        , evalAttr \"y\" (lit (applyScale dimScale.scale tick))\n                        , evalAttrStr \"text-anchor\" (str \"end\")\n                        , evalAttrStr \"dominant-baseline\" (str \"middle\")\n                        , evalAttr \"font-size\" (lit 8.0)\n                        , evalAttrStr \"fill\" (str \"#666\")\n                        , evalAttrStr \"textContent\" (str (formatTick tick))\n                        ])\n            ) state.scales\n          ])\n\n-- =============================================================================\n-- Brush Interaction\n-- =============================================================================\n\n-- | Brush event callback type\ntype BrushCallback = BrushSelection -> Cell -> Effect Unit\n\n-- | Attach brushes to all off-diagonal cells\n-- | Returns the brush handles for storage in component state\nattachBrushes\n  :: SPLOMState\n  -> BrushCallback      -- Called on brush move\n  -> BrushCallback      -- Called on brush end\n  -> Effect (Array { cell :: Cell, handle :: BrushHandle })\nattachBrushes state onBrush onEnd = do\n  let cells = offDiagonalCells $ generateCells state.config.dimensions\n  let padding = state.config.cellPadding\n  let cellSize = state.config.cellSize\n\n  -- Attach brush to each off-diagonal cell\n  handles <- Array.catMaybes <$> (traverse (attachBrushToCell padding cellSize onBrush onEnd) cells)\n  pure handles\n\n-- | Attach brush to a single cell\nattachBrushToCell\n  :: Number\n  -> Number\n  -> BrushCallback\n  -> BrushCallback\n  -> Cell\n  -> Effect (Maybe { cell :: Cell, handle :: BrushHandle })\nattachBrushToCell padding cellSize onBrush onEnd cell = do\n  let cellSelector = \"#splom-matrix #cell-\" <> show cell.row <> \"-\" <> show cell.col <> \" .brush\"\n\n  -- Find the brush group element\n  doc <- window >>= document\n  mElement <- querySelector (QuerySelector cellSelector) (toParentNode doc)\n\n  case mElement of\n    Nothing -> do\n      Console.log $ \"Brush element not found for cell \" <> show cell.row <> \"-\" <> show cell.col\n      pure Nothing\n    Just element -> do\n      -- Create brush config\n      let brushConfig :: BrushConfig\n          brushConfig =\n            { extent:\n                { x0: padding\n                , y0: padding\n                , x1: cellSize - padding\n                , y1: cellSize - padding\n                }\n            , onStart: Nothing  -- Don't use onStart - causes event cascades when clearing other brushes\n            , onBrush: Just \\event -> onBrush event.selection cell\n            , onEnd: Just \\event -> onEnd event.selection cell\n            }\n\n      -- Attach brush\n      handle <- attachBrush element brushConfig\n      pure $ Just { cell, handle }\n\n-- | Clear all brush selections\nclearBrushSelection :: Array { cell :: Cell, handle :: BrushHandle } -> Effect Unit\nclearBrushSelection handles =\n  for_ handles \\bh -> clearBrush bh.handle\n\n-- =============================================================================\n-- Helpers\n-- =============================================================================\n\n-- | Create a data-* attribute for storing values on DOM elements\ndataAttr :: forall datum. String -> Number -> Attribute datum\ndataAttr name value = evalAttr (\"data-\" <> name) (lit value)\n\n-- | Format tick value for display\nformatTick :: Number -> String\nformatTick value\n  | value >= 1000.0 = show (Number.floor (value / 100.0) / 10.0) <> \"k\"\n  | value == Number.floor value = show (fromMaybe 0 $ Int.fromNumber value)\n  | otherwise = show (Number.floor (value * 10.0) / 10.0)\n\n-- | Shorten dimension label\nshortenLabel :: String -> String\nshortenLabel label =\n  replaceSubstring \" (mm)\" \"\" (replaceSubstring \" (g)\" \"\" label)\n\n-- | Simple substring replacement\nreplaceSubstring :: String -> String -> String -> String\nreplaceSubstring search replacement str =\n  go 0 str\n  where\n    searchLen = StringCU.length search\n    go idx s\n      | idx > StringCU.length s - searchLen = s\n      | StringCU.take searchLen (StringCU.drop idx s) == search =\n          StringCU.take idx s <> replacement <> StringCU.drop (idx + searchLen) s\n      | otherwise = go (idx + 1) s\n"

snippet_treeViz_content :: String
snippet_treeViz_content = "module D3.Viz.TreeAPI.TreeViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Control.Comonad.Cofree (head, tail)\nimport Data.Tree (Tree, mkTree)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (loadFlareData)\nimport DataViz.Layout.Hierarchy.Tree (tree, defaultTreeConfig)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, fontSize, textAnchor, textContent, path)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Hierarchy node type (matches loadFlareData output)\ntype HierNode = { name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int }\n\n-- | Link data type\ntype LinkDatum = { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n\n-- | Create links from parent to children\nmakeLinks\n  :: forall r\n   . Tree { x :: Number, y :: Number | r }\n  -> Array { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\nmakeLinks tree' = Array.fromFoldable $ makeLinksList tree'\n  where\n  makeLinksList\n    :: Tree { x :: Number, y :: Number | r }\n    -> List { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n  makeLinksList t =\n    let\n      val = head t\n      children = tail t\n      childLinks = children >>= \\child ->\n        let childVal = head child\n        in Cons { source: { x: val.x, y: val.y }, target: { x: childVal.x, y: childVal.y } } Nil\n      grandchildLinks = children >>= makeLinksList\n    in\n      childLinks <> grandchildLinks\n\n-- | Link path generator (curved links)\nlinkPath :: Number -> Number -> Number -> Number -> String\nlinkPath x1' y1' x2' y2' =\n  \"M\" <> show x1' <> \",\" <> show y1'\n    <> \"C\"\n    <> show x1'\n    <> \",\"\n    <> show ((y1' + y2') / 2.0)\n    <> \" \"\n    <> show x2'\n    <> \",\"\n    <> show ((y1' + y2') / 2.0)\n    <> \" \"\n    <> show x2'\n    <> \",\"\n    <> show y2'\n\n-- | Draw tree hierarchy with loaded data\ndrawTree :: String -> Tree HierNode -> Effect Unit\ndrawTree selector flareTree = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let chartWidth = 800.0\n  let chartHeight = 600.0\n  let padding = 40.0\n\n  -- Apply Tree layout\n  let\n    config = defaultTreeConfig\n      { size =\n          { width: chartWidth - (2.0 * padding)\n          , height: chartHeight - (2.0 * padding)\n          }\n      }\n  let positioned = tree config flareTree\n\n  -- Flatten to arrays\n  let nodes = Array.fromFoldable positioned\n  let links = makeLinks positioned\n\n  liftEffect $ Console.log $ \"Rendering \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n\n  -- First tree: SVG container with links (datum type: link data)\n  let\n    linksTree :: T.Tree LinkDatum\n    linksTree =\n      T.named SVG \"svg\"\n        [ width $ num chartWidth\n        , height $ num chartHeight\n        , viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"simple-hierarchy-tree\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"tree-content\" ]\n              `T.withChild`\n                ( T.named Group \"linksGroup\"\n                    [ attr \"class\" $ text \"links\" ]\n                    `T.withChild`\n                      ( T.joinData \"links\" \"path\" links $ \\link ->\n                          T.elem Path\n                            [ path $ text ( linkPath\n                                    (link.source.x + padding)\n                                    (link.source.y + padding)\n                                    (link.target.x + padding)\n                                    (link.target.y + padding)\n                                )\n                            , fill $ text \"none\"\n                            , stroke $ text \"#999\"\n                            , strokeWidth $ num 1.5\n                            , attr \"class\" $ text \"link\"\n                            ]\n                      )\n                )\n          )\n\n  -- Render links first (underlaying)\n  linksSelections <- renderTree container linksTree\n\n  -- Second tree: Nodes on top (datum type: HierNode)\n  -- Reselect the chartGroup from rendered selections (not global CSS selector!)\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" linksSelections\n\n  let\n    nodesTree :: T.Tree HierNode\n    nodesTree =\n      T.named Group \"nodesGroup\"\n        [ attr \"class\" $ text \"nodes\" ]\n        `T.withChild`\n          ( T.joinData \"nodeGroups\" \"g\" nodes $ \\node ->\n              T.named Group (\"node-\" <> node.name)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Circle\n                      [ cx $ num (node.x + padding)\n                      , cy $ num (node.y + padding)\n                      , r $ num 6.0\n                      , fill $ text \"#69b3a2\"\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 2.0\n                      ]\n                  , T.elem Text\n                      [ x $ num (node.x + padding + 10.0)\n                      , y $ num (node.y + padding + 4.0)\n                      , textContent $ text node.name\n                      , fontSize $ num 12.0\n                      , textAnchor $ text \"start\"\n                      ]\n                  ]\n          )\n\n  -- Render nodes on top (overlaying)\n  nodesSelections <- renderTree chartGroupSel nodesTree\n\n  liftEffect do\n    Console.log \"=== Tree Layout (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n    Console.log \"Flare visualization toolkit hierarchy\"\n    Console.log \"\"\n\n-- | Main entry point - loads Flare data then renders\ntreeViz :: String -> Effect Unit\ntreeViz selector = launchAff_ do\n  result <- loadFlareData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right flareTree -> liftEffect $ drawTree selector flareTree\n"

snippet_radialTree_content :: String
snippet_radialTree_content = "module D3.Viz.TreeAPI.RadialTreeViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Data.Number (pi, cos, sin)\nimport DataViz.Layout.Hierarchy.Link (linkBezierRadialCartesian)\nimport Control.Comonad.Cofree (head, tail)\nimport Data.Tree (Tree, mkTree)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (loadFlareData)\nimport DataViz.Layout.Hierarchy.Tree (tree, defaultTreeConfig)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, transform, path, textAnchor, fontSize, textContent)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Hierarchy node type (matches loadFlareData output)\ntype HierNode = { name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int }\n\n-- | Link data type\ntype LinkDatum = { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n\n-- | Radial projection: convert (x, y) to polar coordinates\n-- | x is mapped to angle, y (depth) is mapped to radius\nradialPoint :: forall r. { x :: Number, y :: Number | r } -> Number -> Number -> { x :: Number, y :: Number }\nradialPoint node w h =\n  let\n    -- Map x to angle (0 to 2π)\n    angle = (node.x / w) * 2.0 * pi - (pi / 2.0) -- Start at top (-π/2)\n    -- Map y (depth) to radius\n    minDim = if w < h then w else h\n    rad = (node.y / h) * (minDim / 2.0) * 0.85 -- Scale to 85% of radius\n  in\n    { x: rad * cos angle\n    , y: rad * sin angle\n    }\n\n-- | Apply radial projection to a tree\nprojectRadial :: forall r. Number -> Number -> Tree { x :: Number, y :: Number | r } -> Tree { x :: Number, y :: Number | r }\nprojectRadial w h t =\n  let\n    val = head t\n    children = tail t\n    projected = radialPoint val w h\n    projectedChildren = map (projectRadial w h) children\n  in\n    mkTree (val { x = projected.x, y = projected.y }) projectedChildren\n\n-- | Create links from parent to children\nmakeLinks\n  :: forall r\n   . Tree { x :: Number, y :: Number | r }\n  -> Array { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\nmakeLinks tree' = Array.fromFoldable $ makeLinksList tree'\n  where\n  makeLinksList\n    :: Tree { x :: Number, y :: Number | r }\n    -> List { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n  makeLinksList t =\n    let\n      val = head t\n      children = tail t\n      childLinks = children >>= \\child ->\n        let childVal = head child\n        in Cons { source: { x: val.x, y: val.y }, target: { x: childVal.x, y: childVal.y } } Nil\n      grandchildLinks = children >>= makeLinksList\n    in\n      childLinks <> grandchildLinks\n\n-- | Radial link path generator (re-export from library)\nradialLinkPath :: Number -> Number -> Number -> Number -> String\nradialLinkPath = linkBezierRadialCartesian\n\n-- | Draw radial tree hierarchy with loaded data\ndrawRadialTree :: String -> Tree HierNode -> Effect Unit\ndrawRadialTree selector flareTree = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 1000 to fit within tutorial-section max-width (832px)\n  let chartSize = 700.0\n  let centerX = chartSize / 2.0\n  let centerY = chartSize / 2.0\n\n  -- Apply Tree layout\n  let\n    config = defaultTreeConfig\n      { size = { width: chartSize, height: chartSize } }\n  let positioned = tree config flareTree\n\n  -- Apply radial projection to all nodes\n  let radialTree = projectRadial chartSize chartSize positioned\n\n  -- Flatten to arrays\n  let nodes = Array.fromFoldable radialTree\n  let links = makeLinks radialTree\n\n  liftEffect $ Console.log $ \"Rendering radial tree: \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n\n  -- First tree: SVG container with links (datum type: link data)\n  let\n    linksTree :: T.Tree LinkDatum\n    linksTree =\n      T.named SVG \"svg\"\n        [ width $ num chartSize\n        , height $ num chartSize\n        , viewBox 0.0 0.0 chartSize chartSize\n        , attr \"class\" $ text \"radial-tree-viz\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"tree-content\"\n              , transform $ text (\"translate(\" <> show centerX <> \",\" <> show centerY <> \")\")\n              ]\n              `T.withChild`\n                ( T.named Group \"linksGroup\"\n                    [ attr \"class\" $ text \"links\" ]\n                    `T.withChild`\n                      ( T.joinData \"links\" \"path\" links $ \\link ->\n                          T.elem Path\n                            [ path $ text ( radialLinkPath\n                                    link.source.x\n                                    link.source.y\n                                    link.target.x\n                                    link.target.y\n                                )\n                            , fill $ text \"none\"\n                            , stroke $ text \"#999\"\n                            , strokeWidth $ num 1.5\n                            , attr \"class\" $ text \"link\"\n                            ]\n                      )\n                )\n          )\n\n  -- Render links first (underlaying)\n  linksSelections <- renderTree container linksTree\n\n  -- Second tree: Nodes on top (datum type: HierNode)\n  -- Reselect the chartGroup from rendered selections (not global CSS selector!)\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" linksSelections\n\n  let\n    nodesTree :: T.Tree HierNode\n    nodesTree =\n      T.named Group \"nodesGroup\"\n        [ attr \"class\" $ text \"nodes\" ]\n        `T.withChild`\n          ( T.joinData \"nodeGroups\" \"g\" nodes $ \\node ->\n              T.named Group (\"node-\" <> node.name)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Circle\n                      [ cx $ num node.x\n                      , cy $ num node.y\n                      , r $ num 3.0\n                      , fill $ text \"#69b3a2\"\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 1.5\n                      ]\n                  , T.elem Text\n                      [ x $ num node.x\n                      , y $ num node.y\n                      , textContent $ text node.name\n                      , fontSize $ num 9.0\n                      , textAnchor $ text \"start\"\n                      , transform $ text \"translate(6, 3)\"\n                      ]\n                  ]\n          )\n\n  -- Render nodes on top (overlaying)\n  _ <- renderTree chartGroupSel nodesTree\n\n  liftEffect do\n    Console.log \"=== Radial Tree Layout (Tree API) ===\"\n    Console.log \"\"\n    Console.log \"Flare visualization toolkit hierarchy (radial)\"\n    Console.log \"\"\n\n-- | Main entry point - loads Flare data then renders\nradialTreeViz :: String -> Effect Unit\nradialTreeViz selector = launchAff_ do\n  result <- loadFlareData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right flareTree -> liftEffect $ drawRadialTree selector flareTree\n"

snippet_horizontalTree_content :: String
snippet_horizontalTree_content = "module D3.Viz.TreeAPI.HorizontalTreeViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Control.Comonad.Cofree (head, tail)\nimport Data.Tree (Tree, mkTree)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (loadFlareData)\nimport DataViz.Layout.Hierarchy.Tree (tree, defaultTreeConfig)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, path, textAnchor, fontSize, textContent)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Hierarchy node type (matches loadFlareData output)\ntype HierNode = { name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int }\n\n-- | Link data type\ntype LinkDatum = { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n\n-- | Swap x and y coordinates for horizontal orientation\nswapXY :: forall r. Tree { x :: Number, y :: Number | r } -> Tree { x :: Number, y :: Number | r }\nswapXY t =\n  let\n    val = head t\n    children = tail t\n    swappedChildren = map swapXY children\n  in\n    mkTree (val { x = val.y, y = val.x }) swappedChildren\n\n-- | Create links from parent to children\nmakeLinks\n  :: forall r\n   . Tree { x :: Number, y :: Number | r }\n  -> Array { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\nmakeLinks tree' = Array.fromFoldable $ makeLinksList tree'\n  where\n  makeLinksList\n    :: Tree { x :: Number, y :: Number | r }\n    -> List { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n  makeLinksList t =\n    let\n      val = head t\n      children = tail t\n      childLinks = children >>= \\child ->\n        let childVal = head child\n        in Cons { source: { x: val.x, y: val.y }, target: { x: childVal.x, y: childVal.y } } Nil\n      grandchildLinks = children >>= makeLinksList\n    in\n      childLinks <> grandchildLinks\n\n-- | Horizontal link path generator (draws from left to right)\nlinkPath :: Number -> Number -> Number -> Number -> String\nlinkPath x1' y1' x2' y2' =\n  \"M\" <> show x1' <> \",\" <> show y1'\n    <> \"C\"\n    <> show ((x1' + x2') / 2.0)\n    <> \",\"\n    <> show y1'\n    <> \" \"\n    <> show ((x1' + x2') / 2.0)\n    <> \",\"\n    <> show y2'\n    <> \" \"\n    <> show x2'\n    <> \",\"\n    <> show y2'\n\n-- | Draw horizontal tree hierarchy with loaded data\ndrawHorizontalTree :: String -> Tree HierNode -> Effect Unit\ndrawHorizontalTree selector flareTree = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 1200x800 to fit within tutorial-section max-width (832px)\n  let chartWidth = 750.0\n  let chartHeight = 500.0\n  let padding = 40.0\n\n  -- Apply Tree layout with swapped dimensions\n  -- For horizontal tree, we swap width/height so the tree grows left-to-right\n  let\n    config = defaultTreeConfig\n      { size =\n          { width: chartHeight - (2.0 * padding)\n          , height: chartWidth - (2.0 * padding)\n          }\n      }\n  let positioned = tree config flareTree\n\n  -- Swap x and y for horizontal orientation\n  let horizontalTree = swapXY positioned\n\n  -- Flatten to arrays\n  let nodes = Array.fromFoldable horizontalTree\n  let links = makeLinks horizontalTree\n\n  liftEffect $ Console.log $ \"Rendering horizontal tree: \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n\n  -- First tree: SVG container with links (datum type: link data)\n  let\n    linksTree :: T.Tree LinkDatum\n    linksTree =\n      T.named SVG \"svg\"\n        [ width $ num chartWidth\n        , height $ num chartHeight\n        , viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"horizontal-tree-viz\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"tree-content\" ]\n              `T.withChild`\n                ( T.named Group \"linksGroup\"\n                    [ attr \"class\" $ text \"links\" ]\n                    `T.withChild`\n                      ( T.joinData \"links\" \"path\" links $ \\link ->\n                          T.elem Path\n                            [ path $ text ( linkPath\n                                    (link.source.x + padding)\n                                    (link.source.y + padding)\n                                    (link.target.x + padding)\n                                    (link.target.y + padding)\n                                )\n                            , fill $ text \"none\"\n                            , stroke $ text \"#999\"\n                            , strokeWidth $ num 1.5\n                            , attr \"class\" $ text \"link\"\n                            ]\n                      )\n                )\n          )\n\n  -- Render links first (underlaying)\n  linksSelections <- renderTree container linksTree\n\n  -- Second tree: Nodes on top (datum type: HierNode)\n  -- Reselect the chartGroup from rendered selections (not global CSS selector!)\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" linksSelections\n\n  let\n    nodesTree :: T.Tree HierNode\n    nodesTree =\n      T.named Group \"nodesGroup\"\n        [ attr \"class\" $ text \"nodes\" ]\n        `T.withChild`\n          ( T.joinData \"nodeGroups\" \"g\" nodes $ \\node ->\n              T.named Group (\"node-\" <> node.name)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Circle\n                      [ cx $ num (node.x + padding)\n                      , cy $ num (node.y + padding)\n                      , r $ num 4.0\n                      , fill $ text \"#69b3a2\"\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 1.5\n                      ]\n                  , T.elem Text\n                      [ x $ num (node.x + padding + 8.0)\n                      , y $ num (node.y + padding + 4.0)\n                      , textContent $ text node.name\n                      , fontSize $ num 10.0\n                      , textAnchor $ text \"start\"\n                      ]\n                  ]\n          )\n\n  -- Render nodes on top (overlaying)\n  _ <- renderTree chartGroupSel nodesTree\n\n  liftEffect do\n    Console.log \"=== Horizontal Tree Layout (Tree API) ===\"\n    Console.log \"\"\n    Console.log \"Flare visualization toolkit hierarchy (horizontal)\"\n    Console.log \"\"\n\n-- | Main entry point - loads Flare data then renders\nhorizontalTreeViz :: String -> Effect Unit\nhorizontalTreeViz selector = launchAff_ do\n  result <- loadFlareData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right flareTree -> liftEffect $ drawHorizontalTree selector flareTree\n"

snippet_cluster_content :: String
snippet_cluster_content = "module D3.Viz.TreeAPI.ClusterViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Control.Comonad.Cofree (head, tail)\nimport Data.Tree (Tree, mkTree)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (loadFlareData)\nimport DataViz.Layout.Hierarchy.Cluster (cluster, defaultClusterConfig)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, fontSize, textAnchor, textContent, path)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Hierarchy node type (matches loadFlareData output)\ntype HierNode = { name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int }\n\n-- | Link data type\ntype LinkDatum = { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n\n-- | Create links from parent to children\nmakeLinks\n  :: forall r\n   . Tree { x :: Number, y :: Number | r }\n  -> Array { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\nmakeLinks tree' = Array.fromFoldable $ makeLinksList tree'\n  where\n  makeLinksList\n    :: Tree { x :: Number, y :: Number | r }\n    -> List { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n  makeLinksList t =\n    let\n      val = head t\n      children = tail t\n      childLinks = children >>= \\child ->\n        let childVal = head child\n        in Cons { source: { x: val.x, y: val.y }, target: { x: childVal.x, y: childVal.y } } Nil\n      grandchildLinks = children >>= makeLinksList\n    in\n      childLinks <> grandchildLinks\n\n-- | Dendrogram link path generator (vertical with stepped Bezier)\n-- | Creates orthogonal \"elbow\" connectors\nlinkPath :: Number -> Number -> Number -> Number -> String\nlinkPath x1' y1' x2' y2' =\n  let\n    midY = (y1' + y2') / 2.0\n  in\n    \"M\" <> show x1' <> \",\" <> show y1'\n      <> \" C\"\n      <> show x1'\n      <> \",\"\n      <> show midY\n      <> \" \"\n      <> show x2'\n      <> \",\"\n      <> show midY\n      <> \" \"\n      <> show x2'\n      <> \",\"\n      <> show y2'\n\n-- | Draw cluster (dendrogram) hierarchy with loaded data\ndrawCluster :: String -> Tree HierNode -> Effect Unit\ndrawCluster selector flareTree = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 1200x800 to fit within tutorial-section max-width (832px)\n  let chartWidth = 750.0\n  let chartHeight = 500.0\n  let padding = 40.0\n\n  -- Apply Cluster layout (height field already computed by data loader)\n  let\n    config = defaultClusterConfig\n      { size =\n          { width: chartWidth - (2.0 * padding)\n          , height: chartHeight - (2.0 * padding)\n          }\n      }\n  let positioned = cluster config flareTree\n\n  -- Flatten to arrays\n  let nodes = Array.fromFoldable positioned\n  let links = makeLinks positioned\n\n  liftEffect $ Console.log $ \"Rendering cluster (dendrogram): \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n\n  -- First tree: SVG container with links (datum type: link data)\n  let\n    linksTree :: T.Tree LinkDatum\n    linksTree =\n      T.named SVG \"svg\"\n        [ width $ num chartWidth\n        , height $ num chartHeight\n        , viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"cluster-viz\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"tree-content\" ]\n              `T.withChild`\n                ( T.named Group \"linksGroup\"\n                    [ attr \"class\" $ text \"links\" ]\n                    `T.withChild`\n                      ( T.joinData \"links\" \"path\" links $ \\link ->\n                          T.elem Path\n                            [ path $ text ( linkPath\n                                    (link.source.x + padding)\n                                    (link.source.y + padding)\n                                    (link.target.x + padding)\n                                    (link.target.y + padding)\n                                )\n                            , fill $ text \"none\"\n                            , stroke $ text \"#999\"\n                            , strokeWidth $ num 1.5\n                            , attr \"class\" $ text \"link\"\n                            ]\n                      )\n                )\n          )\n\n  -- Render links first (underlaying)\n  linksSelections <- renderTree container linksTree\n\n  -- Second tree: Nodes on top (datum type: HierNode)\n  -- Reselect the chartGroup from rendered selections (not global CSS selector!)\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" linksSelections\n\n  let\n    nodesTree :: T.Tree HierNode\n    nodesTree =\n      T.named Group \"nodesGroup\"\n        [ attr \"class\" $ text \"nodes\" ]\n        `T.withChild`\n          ( T.joinData \"nodeGroups\" \"g\" nodes $ \\node ->\n              T.named Group (\"node-\" <> node.name)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Circle\n                      [ cx $ num (node.x + padding)\n                      , cy $ num (node.y + padding)\n                      , r $ num 4.0\n                      , fill $ text \"#69b3a2\"\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 1.5\n                      ]\n                  , T.elem Text\n                      [ x $ num (node.x + padding + 8.0)\n                      , y $ num (node.y + padding + 4.0)\n                      , textContent $ text node.name\n                      , fontSize $ num 10.0\n                      , textAnchor $ text \"start\"\n                      ]\n                  ]\n          )\n\n  -- Render nodes on top (overlaying)\n  _ <- renderTree chartGroupSel nodesTree\n\n  liftEffect do\n    Console.log \"=== Cluster Layout (Dendrogram, Tree API) ===\"\n    Console.log \"\"\n    Console.log \"Flare visualization toolkit hierarchy (cluster/dendrogram)\"\n    Console.log \"\"\n\n-- | Main entry point - loads Flare data then renders\nclusterViz :: String -> Effect Unit\nclusterViz selector = launchAff_ do\n  result <- loadFlareData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right flareTree -> liftEffect $ drawCluster selector flareTree\n"

snippet_treemap_content :: String
snippet_treemap_content = "module D3.Viz.TreeAPI.TreemapViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (HierData, getName, getValue, getChildren, loadDataFile, DataFile(..), parseFlareJson)\nimport DataViz.Layout.Hierarchy.Core (hierarchy, sum) as H\nimport DataViz.Layout.Hierarchy.Types (ValuedNode(..))\nimport DataViz.Layout.Hierarchy.Treemap (TreemapNode(..), defaultTreemapConfig, treemap, squarify, phi)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, strokeWidth, textAnchor, fontSize, textContent)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Color palette\ncolors :: Array String\ncolors = [ \"#e7ba52\", \"#c7c7c7\", \"#aec7e8\", \"#1f77b4\", \"#9467bd\" ]\n\ngetColor :: Int -> String\ngetColor depth = case colors Array.!! (depth `mod` Array.length colors) of\n  Just c -> c\n  Nothing -> \"#cccccc\"\n\n-- | Get all leaves\ngetLeaves :: forall a. TreemapNode a -> Array (TreemapNode a)\ngetLeaves node@(TNode n) =\n  if Array.length n.children == 0 then [ node ]\n  else n.children >>= getLeaves\n\n-- | Map over ValuedNode to transform the data type\nmapValuedNode :: forall a b. (a -> b) -> ValuedNode a -> ValuedNode b\nmapValuedNode f (VNode n) =\n  VNode\n    { data_: f n.data_\n    , depth: n.depth\n    , height: n.height\n    , parent: Nothing -- Parent references are dropped\n    , children: map (mapValuedNode f) n.children\n    , value: n.value\n    }\n\n-- | Draw treemap\ndrawTreemap :: String -> HierData -> Effect Unit\ndrawTreemap selector flareData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 900x600 to fit within tutorial-section max-width (832px)\n  let chartWidth = 750.0\n  let chartHeight = 500.0\n\n  -- Build hierarchy using HierData directly, then map to extract names\n  let h = H.hierarchy flareData getChildren\n  let valued = H.sum h getValue\n\n  -- Map to convert HierData to String (just the name)\n  let stringValued = mapValuedNode getName valued\n\n  -- Apply treemap layout\n  let\n    config = defaultTreemapConfig\n      { size = { width: chartWidth, height: chartHeight }\n      , tile = squarify phi\n      }\n  let layout = treemap config stringValued\n  let leaves = getLeaves layout\n\n  liftEffect $ Console.log $ \"Rendering treemap: \" <> show (Array.length leaves) <> \" rectangles\"\n\n  -- Build tree\n  let\n    tree :: T.Tree (TreemapNode String)\n    tree =\n      T.named SVG \"svg\"\n        [ width $ num chartWidth\n        , height $ num chartHeight\n        , viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"treemap-viz\"\n        ]\n        `T.withChild`\n          ( T.joinData \"rects\" \"g\" leaves $ \\(TNode node) ->\n              T.named Group (\"rect-\" <> node.data_)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Rect\n                      [ x $ num node.x0\n                      , y $ num node.y0\n                      , width $ num (node.x1 - node.x0)\n                      , height $ num (node.y1 - node.y0)\n                      , fill $ text (getColor node.depth)\n                      , attr \"fill-opacity\" $ num 0.6\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 1.0\n                      ]\n                  , T.elem Text\n                      [ x $ num ((node.x0 + node.x1) / 2.0)\n                      , y $ num ((node.y0 + node.y1) / 2.0)\n                      , textContent $ text node.data_\n                      , textAnchor $ text \"middle\"\n                      , fontSize $ num 9.0\n                      , attr \"fill-opacity\" $ num (if (node.x1 - node.x0) > 30.0 && (node.y1 - node.y0) > 15.0 then 1.0 else 0.0)\n                      ]\n                  ]\n          )\n\n  _ <- renderTree container tree\n\n  liftEffect $ Console.log \"=== Treemap Layout (Tree API) ===\"\n\n-- | Main entry point\ntreemapViz :: String -> Effect Unit\ntreemapViz selector = launchAff_ do\n  result <- loadDataFile FlareJSON\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right jsonString -> liftEffect $ drawTreemap selector (parseFlareJson jsonString)\n"

snippet_sunburst_content :: String
snippet_sunburst_content = "module D3.Viz.TreeAPI.SunburstViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Number (pi, cos, sin)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (HierData, getName, getValue, getChildren, loadDataFile, DataFile(..), parseFlareJson)\nimport DataViz.Layout.Hierarchy.Partition (HierarchyData(..), PartitionNode(..), defaultPartitionConfig, hierarchy, partition)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, fill, stroke, strokeWidth, opacity, path)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Convert HierData to Partition's HierarchyData\n-- | Non-leaf nodes use Nothing for value so hierarchy computes sum of children\ntoHierarchyData :: HierData -> HierarchyData String\ntoHierarchyData node =\n  let\n    children = getChildren node\n    -- Only leaf nodes have explicit values; non-leaf nodes sum children\n    nodeValue = case children of\n      Nothing -> Just (getValue node)\n      Just _ -> Nothing\n  in\n    HierarchyData\n      { data_: getName node\n      , value: nodeValue\n      , children: map (map toHierarchyData) children\n      }\n\n-- | Color palette\ncolors :: Array String\ncolors = [ \"#e7ba52\", \"#c7c7c7\", \"#aec7e8\", \"#1f77b4\", \"#9467bd\" ]\n\ngetColor :: Int -> String\ngetColor depth = case colors Array.!! (depth `mod` Array.length colors) of\n  Just c -> c\n  Nothing -> \"#cccccc\"\n\n-- | Get all nodes (recursive traversal)\ngetAllNodes :: forall a. PartitionNode a -> Array (PartitionNode a)\ngetAllNodes node@(PartNode n) =\n  if Array.length n.children == 0 then [ node ]\n  else [ node ] <> (n.children >>= getAllNodes)\n\n-- | Convert partition coordinates to sunburst arc path\n-- | x0, x1 are normalized [0,1] representing angles around the circle\n-- | y0, y1 are normalized [0,1] representing radius from center\narcPath :: Number -> Number -> Number -> Number -> Number -> String\narcPath x0_ y0_ x1_ y1_ radius =\n  let\n    -- Convert normalized x to angles (0 to 2π)\n    startAngle = x0_ * 2.0 * pi\n    endAngle = x1_ * 2.0 * pi\n\n    -- Convert normalized y to radius\n    innerRadius = y0_ * radius\n    outerRadius = y1_ * radius\n\n    -- Calculate arc points\n    x00 = cos startAngle * innerRadius\n    y00 = sin startAngle * innerRadius\n    x01 = cos endAngle * innerRadius\n    y01 = sin endAngle * innerRadius\n    x10 = cos startAngle * outerRadius\n    y10 = sin startAngle * outerRadius\n    x11 = cos endAngle * outerRadius\n    y11 = sin endAngle * outerRadius\n\n    -- Large arc flag: 1 if angle > π, 0 otherwise\n    largeArc = if (endAngle - startAngle) > pi then 1 else 0\n  in\n    -- SVG path for arc segment\n    \"M\" <> show x10 <> \",\" <> show y10\n      <> \"A\"\n      <> show outerRadius\n      <> \",\"\n      <> show outerRadius\n      <> \" 0 \"\n      <> show largeArc\n      <> \" 1 \"\n      <> show x11\n      <> \",\"\n      <> show y11\n      <> \"L\"\n      <> show x01\n      <> \",\"\n      <> show y01\n      <> \"A\"\n      <> show innerRadius\n      <> \",\"\n      <> show innerRadius\n      <> \" 0 \"\n      <> show largeArc\n      <> \" 0 \"\n      <> show x00\n      <> \",\"\n      <> show y00\n      <>\n        \"Z\"\n\n-- | Draw sunburst diagram\ndrawSunburst :: String -> HierData -> Effect Unit\ndrawSunburst selector flareData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 900 to fit within tutorial-section max-width (832px)\n  let chartSize = 700.0\n  let radius = chartSize / 2.0\n\n  -- Convert to HierarchyData\n  let hierData = toHierarchyData flareData\n\n  -- Convert to PartitionNode hierarchy\n  let partRoot = hierarchy hierData\n\n  -- Apply partition layout (creates normalized coordinates)\n  let\n    config = defaultPartitionConfig\n      { size = { width: 1.0, height: 1.0 } -- Normalized for conversion to polar\n      , padding = 0.001 -- Small padding for visibility\n      }\n  let partitioned = partition config partRoot\n\n  -- Get all nodes except root (root would be full circle)\n  let allNodes = getAllNodes partitioned\n  let nodes = Array.filter (\\(PartNode n) -> n.depth > 0) allNodes\n\n  liftEffect $ Console.log $ \"Rendering sunburst: \" <> show (Array.length nodes) <> \" arcs\"\n\n  -- Build tree using TreeAPI\n  let\n    tree :: T.Tree (PartitionNode String)\n    tree =\n      T.named SVG \"svg\"\n        [ width $ num chartSize\n        , height $ num chartSize\n        , viewBox (-radius) (-radius) chartSize chartSize\n        , attr \"class\" $ text \"sunburst-viz\"\n        ]\n        `T.withChild`\n          ( T.joinData \"arcs\" \"g\" nodes $ \\(PartNode node) ->\n              T.named Group (\"arc-\" <> node.data_)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChild`\n                  ( T.elem Path\n                      [ path $ text (arcPath node.x0 node.y0 node.x1 node.y1 radius)\n                      , fill $ text (getColor node.depth)\n                      , attr \"fill-opacity\" $ num 0.7\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 1.0\n                      ]\n                  )\n          )\n\n  _ <- renderTree container tree\n\n  liftEffect $ Console.log \"=== Sunburst Diagram ====\"\n\n-- | Main entry point\nsunburstViz :: String -> Effect Unit\nsunburstViz selector = launchAff_ do\n  result <- loadDataFile FlareJSON\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right jsonString -> liftEffect $ drawSunburst selector (parseFlareJson jsonString)\n"

snippet_pack_content :: String
snippet_pack_content = "module D3.Viz.TreeAPI.PackViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (HierData, getName, getValue, getChildren, loadDataFile, DataFile(..), parseFlareJson)\nimport DataViz.Layout.Hierarchy.Pack (HierarchyData(..), PackNode(..), defaultPackConfig, hierarchy, pack)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, r, y, fill, stroke, strokeWidth, fontSize, textAnchor, transform)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Convert HierData to Pack's HierarchyData\ntoHierarchyData :: HierData -> HierarchyData String\ntoHierarchyData node = HierarchyData\n  { data_: getName node\n  , value: Just (getValue node)\n  , children: map (map toHierarchyData) (getChildren node)\n  }\n\n-- | Simple color palette for depth-based coloring\ncolors :: Array String\ncolors =\n  [ \"#e7ba52\"\n  , \"#c7c7c7\"\n  , \"#aec7e8\"\n  , \"#1f77b4\"\n  , \"#9467bd\"\n  , \"#8c564b\"\n  , \"#e377c2\"\n  , \"#7f7f7f\"\n  , \"#bcbd22\"\n  , \"#17becf\"\n  ]\n\n-- | Get color by depth\ngetColor :: Int -> String\ngetColor depth =\n  let\n    idx = depth `mod` (Array.length colors)\n  in\n    case colors Array.!! idx of\n      Just c -> c\n      Nothing -> \"#cccccc\"\n\n-- | Get all nodes (recursive traversal)\ngetAllNodes :: forall a. PackNode a -> Array (PackNode a)\ngetAllNodes node@(PackNode n) =\n  if Array.length n.children == 0 then [ node ]\n  else [ node ] <> (n.children >>= getAllNodes)\n\n-- | Draw circle packing with loaded data\ndrawPack :: String -> HierData -> Effect Unit\ndrawPack selector flareData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 1000 to fit within tutorial-section max-width (832px)\n  let chartSize = 700.0\n  let centerX = chartSize / 2.0\n  let centerY = chartSize / 2.0\n\n  -- Convert to HierarchyData\n  let hierData = toHierarchyData flareData\n\n  -- Convert to PackNode hierarchy\n  let packRoot = hierarchy hierData\n\n  -- Apply pack layout\n  let\n    config = defaultPackConfig\n      { size = { width: chartSize, height: chartSize }\n      , padding = 2.0\n      }\n  let packed = pack config packRoot\n\n  -- Get all nodes\n  let nodes = getAllNodes packed\n\n  liftEffect $ Console.log $ \"Rendering circle pack: \" <> show (Array.length nodes) <> \" circles\"\n\n  -- Build tree using TreeAPI\n  let\n    tree :: T.Tree (PackNode String)\n    tree =\n      T.named SVG \"svg\"\n        [ width $ num chartSize\n        , height $ num chartSize\n        , viewBox 0.0 0.0 chartSize chartSize\n        , attr \"class\" $ text \"pack-viz\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"pack-content\" ]\n              `T.withChild`\n                ( T.joinData \"circles\" \"g\" nodes $ \\(PackNode node) ->\n                    T.named Group (\"circle-\" <> node.data_)\n                      [ attr \"class\" $ text \"node\"\n                      , transform $ text (\"translate(\" <> show node.x <> \",\" <> show node.y <> \")\")\n                      ]\n                      `T.withChildren`\n                        [ T.elem Circle\n                            [ r $ num node.r\n                            , fill $ text (getColor node.depth)\n                            , attr \"fill-opacity\" $ num 0.7\n                            , stroke $ text \"#fff\"\n                            , strokeWidth $ num 1.0\n                            ]\n                        , T.elem Text\n                            [ attr \"text-content\" $ text node.data_\n                            , textAnchor $ text \"middle\"\n                            , y $ num 4.0\n                            , fontSize $ num (if node.r > 20.0 then 10.0 else 8.0)\n                            , attr \"fill-opacity\" $ num (if node.r > 15.0 then 1.0 else 0.0) -- Hide text in small circles\n                            ]\n                        ]\n                )\n          )\n\n  -- Render\n  _ <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Circle Packing Layout (Tree API) ===\"\n    Console.log \"\"\n    Console.log \"Flare visualization toolkit hierarchy (circle packing)\"\n    Console.log \"\"\n\n-- | Main entry point - loads Flare data then renders\npackViz :: String -> Effect Unit\npackViz selector = launchAff_ do\n  result <- loadDataFile FlareJSON\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right jsonString -> do\n      let hierData = parseFlareJson jsonString\n      liftEffect $ drawPack selector hierData\n"

snippet_partition_content :: String
snippet_partition_content = "module D3.Viz.TreeAPI.PartitionViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (HierData, getName, getValue, getChildren, loadDataFile, DataFile(..), parseFlareJson)\nimport DataViz.Layout.Hierarchy.Partition (HierarchyData(..), PartitionNode(..), defaultPartitionConfig, hierarchy, partition)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, strokeWidth, textAnchor, fontSize, textContent)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Convert HierData to Partition's HierarchyData\n-- | Non-leaf nodes use Nothing for value so hierarchy computes sum of children\ntoHierarchyData :: HierData -> HierarchyData String\ntoHierarchyData node =\n  let\n    children = getChildren node\n    -- Only leaf nodes have explicit values; non-leaf nodes sum children\n    nodeValue = case children of\n      Nothing -> Just (getValue node)\n      Just _ -> Nothing\n  in\n    HierarchyData\n      { data_: getName node\n      , value: nodeValue\n      , children: map (map toHierarchyData) children\n      }\n\n-- | Color palette\ncolors :: Array String\ncolors = [ \"#e7ba52\", \"#c7c7c7\", \"#aec7e8\", \"#1f77b4\", \"#9467bd\" ]\n\ngetColor :: Int -> String\ngetColor depth = case colors Array.!! (depth `mod` Array.length colors) of\n  Just c -> c\n  Nothing -> \"#cccccc\"\n\n-- | Get all nodes (recursive traversal)\ngetAllNodes :: forall a. PartitionNode a -> Array (PartitionNode a)\ngetAllNodes node@(PartNode n) =\n  if Array.length n.children == 0 then [ node ]\n  else [ node ] <> (n.children >>= getAllNodes)\n\n-- | Draw partition (icicle diagram)\ndrawPartition :: String -> HierData -> Effect Unit\ndrawPartition selector flareData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Reduced from 900x600 to fit within tutorial-section max-width (832px)\n  let chartWidth = 750.0\n  let chartHeight = 500.0\n\n  -- Convert to HierarchyData\n  let hierData = toHierarchyData flareData\n\n  -- Convert to PartitionNode hierarchy\n  let partRoot = hierarchy hierData\n\n  -- Apply partition layout\n  let\n    config = defaultPartitionConfig\n      { size = { width: chartWidth, height: chartHeight }\n      , padding = 1.0\n      }\n  let partitioned = partition config partRoot\n\n  -- Get all nodes\n  let nodes = getAllNodes partitioned\n\n  liftEffect $ Console.log $ \"Rendering partition: \" <> show (Array.length nodes) <> \" rectangles\"\n\n  -- Build tree using TreeAPI\n  let\n    tree :: T.Tree (PartitionNode String)\n    tree =\n      T.named SVG \"svg\"\n        [ width $ num chartWidth\n        , height $ num chartHeight\n        , viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"partition-viz\"\n        ]\n        `T.withChild`\n          ( T.joinData \"rects\" \"g\" nodes $ \\(PartNode node) ->\n              T.named Group (\"rect-\" <> node.data_)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Rect\n                      [ x $ num node.x0\n                      , y $ num node.y0\n                      , width $ num (node.x1 - node.x0)\n                      , height $ num (node.y1 - node.y0)\n                      , fill $ text (getColor node.depth)\n                      , attr \"fill-opacity\" $ num 0.7\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 1.0\n                      ]\n                  , T.elem Text\n                      [ x $ num ((node.x0 + node.x1) / 2.0)\n                      , y $ num ((node.y0 + node.y1) / 2.0)\n                      , textContent $ text node.data_\n                      , textAnchor $ text \"middle\"\n                      , fontSize $ num 9.0\n                      , attr \"fill-opacity\" $ num (if (node.x1 - node.x0) > 30.0 && (node.y1 - node.y0) > 15.0 then 1.0 else 0.0)\n                      ]\n                  ]\n          )\n\n  _ <- renderTree container tree\n\n  liftEffect $ Console.log \"=== Partition Layout (Icicle) ====\"\n\n-- | Main entry point\npartitionViz :: String -> Effect Unit\npartitionViz selector = launchAff_ do\n  result <- loadDataFile FlareJSON\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right jsonString -> liftEffect $ drawPartition selector (parseFlareJson jsonString)\n"

snippet_animatedTreeCluster_content :: String
snippet_animatedTreeCluster_content = "module D3.Viz.TreeAPI.AnimatedTreeCluster where\n\n-- | Animated transition between Tree (Reingold-Tilford) and Cluster (dendrogram) layouts\n-- | TreeAPI implementation using sceneJoin for declarative enter/update/exit\n\nimport Prelude hiding (add, sub, mul)\n\nimport Data.Array as Array\nimport Data.List (List(..), fromFoldable)\nimport Data.Maybe (Maybe(..))\nimport Data.Time.Duration (Milliseconds(..))\nimport Control.Comonad.Cofree (head, tail)\nimport Data.Tree (Tree, mkTree)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\nimport PSD3.Shared.FlareData (HierData, getName, getValue, getChildren)\nimport PSD3.Internal.Capabilities.Selection (renderTree, select)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.Internal.Transition.Types (TransitionConfig, transition)\nimport PSD3.AST as T\nimport DataViz.Layout.Hierarchy.Cluster (cluster, defaultClusterConfig)\nimport DataViz.Layout.Hierarchy.Tree (treeWithSorting, defaultTreeConfig)\nimport Web.DOM.Element (Element)\n\n-- v3 DSL imports\nimport PSD3.Expr.Expr (class NumExpr)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Path (linkVertical)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, fill, stroke, strokeWidth, path)\n\n-- | Layout type\ndata LayoutType = TreeLayout | ClusterLayout\n\nderive instance Eq LayoutType\n\ninstance Show LayoutType where\n  show TreeLayout = \"Tree (Reingold-Tilford)\"\n  show ClusterLayout = \"Cluster (Dendrogram)\"\n\n-- | Toggle between layouts\ntoggleLayout :: LayoutType -> LayoutType\ntoggleLayout TreeLayout = ClusterLayout\ntoggleLayout ClusterLayout = TreeLayout\n\n-- | Tree model with position data\ntype TreeModel = { name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int }\ntype TreeModelRow = (name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int)\n\n-- | Link data with source/target positions\ntype LinkData =\n  { name :: String  -- Unique key: \"source->target\"\n  , sourceX :: Number\n  , sourceY :: Number\n  , targetX :: Number\n  , targetY :: Number\n  }\ntype LinkRow = (name :: String, sourceX :: Number, sourceY :: Number, targetX :: Number, targetY :: Number)\n\n-- =============================================================================\n-- v3 Expressions\n-- =============================================================================\n\n-- | Node X position\nnodeX :: forall repr. NumExpr repr => DatumExpr repr TreeModelRow => repr Number\nnodeX = field (Proxy :: Proxy \"x\")\n\n-- | Node Y position\nnodeY :: forall repr. NumExpr repr => DatumExpr repr TreeModelRow => repr Number\nnodeY = field (Proxy :: Proxy \"y\")\n\n-- | Link path using v3 PathExpr\n-- | linkVertical creates a smooth bezier curve between source and target\nlinkSourceX :: forall repr. NumExpr repr => DatumExpr repr LinkRow => repr Number\nlinkSourceX = field (Proxy :: Proxy \"sourceX\")\n\nlinkSourceY :: forall repr. NumExpr repr => DatumExpr repr LinkRow => repr Number\nlinkSourceY = field (Proxy :: Proxy \"sourceY\")\n\nlinkTargetX :: forall repr. NumExpr repr => DatumExpr repr LinkRow => repr Number\nlinkTargetX = field (Proxy :: Proxy \"targetX\")\n\nlinkTargetY :: forall repr. NumExpr repr => DatumExpr repr LinkRow => repr Number\nlinkTargetY = field (Proxy :: Proxy \"targetY\")\n\n-- | Evaluate v3 expressions\nevalNode :: forall a. EvalD TreeModel a -> TreeModel -> a\nevalNode expr datum = runEvalD expr datum 0\n\nevalLink :: forall a. EvalD LinkData a -> LinkData -> a\nevalLink expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- Data Conversion\n-- =============================================================================\n\n-- | Convert HierData to Data.Tree with both depth and height fields\nhierDataToTree :: HierData -> Tree TreeModel\nhierDataToTree hierData =\n  let\n    name = getName hierData\n    value = getValue hierData\n    childrenMaybe = getChildren hierData\n    childrenList = case childrenMaybe of\n      Nothing -> Nil\n      Just childrenArray -> fromFoldable $ map hierDataToTree childrenArray\n  in\n    mkTree { name, value, x: 0.0, y: 0.0, depth: 0, height: 0 } childrenList\n\n-- | Flatten tree to array\nflattenTree :: forall r. Tree { name :: String | r } -> Array { name :: String | r }\nflattenTree = Array.fromFoldable\n\n-- | Create links from tree structure\nmakeLinks :: forall r. Tree { name :: String, x :: Number, y :: Number | r } -> Array LinkData\nmakeLinks t =\n  let\n    val = head t\n    children = tail t\n    childLinks = Array.fromFoldable children >>= \\child ->\n      let childVal = head child\n      in [ { name: val.name <> \"->\" <> childVal.name\n           , sourceX: val.x\n           , sourceY: val.y\n           , targetX: childVal.x\n           , targetY: childVal.y\n           } ]\n    grandchildLinks = Array.fromFoldable children >>= makeLinks\n  in\n    childLinks <> grandchildLinks\n\n-- | Vertical link path using v3 PathExpr\nverticalLinkPathV3 :: LinkData -> String\nverticalLinkPathV3 link = runEvalD (linkVertical linkSourceX linkSourceY linkTargetX linkTargetY) link 0\n\n-- | Key functions for sceneJoin\nnodeKey :: TreeModel -> String\nnodeKey node = node.name\n\nlinkKey :: LinkData -> String\nlinkKey link = link.name\n\n-- | Transition config for animations\ntransitionConfig :: TransitionConfig\ntransitionConfig = transition (Milliseconds 1500.0)\n\n-- =============================================================================\n-- TreeAPI Implementation\n-- =============================================================================\n\n-- | Viz state returned from draw\ntype VizState =\n  { dataTree :: Tree TreeModel\n  , chartWidth :: Number\n  , chartHeight :: Number\n  }\n\n-- | Draw the animated tree/cluster visualization using TreeAPI with sceneJoin\n-- | Uses the two-phase approach: render structure first, then data-driven subtrees\ndraw :: HierData -> String -> LayoutType -> Effect VizState\ndraw flareData selector currentLayout = runD3v2M do\n  let chartWidth = 1200.0\n  let chartHeight = 900.0\n\n  liftEffect $ Console.log $ \"=== Drawing AnimatedTreeCluster with TreeAPI (sceneJoin) ===\"\n  liftEffect $ Console.log $ \"Layout: \" <> show currentLayout\n\n  -- Convert to Data.Tree\n  let dataTree = hierDataToTree flareData\n\n  -- Apply layout\n  let positioned = case currentLayout of\n        TreeLayout ->\n          let config = defaultTreeConfig { size = { width: chartWidth, height: chartHeight } }\n          in treeWithSorting config dataTree\n        ClusterLayout ->\n          let config = defaultClusterConfig { size = { width: chartWidth, height: chartHeight } }\n          in cluster config dataTree\n\n  -- Flatten nodes and create links\n  let nodes = flattenTree positioned\n  let links = makeLinks positioned\n\n  liftEffect $ Console.log $ \"Nodes: \" <> show (Array.length nodes) <> \", Links: \" <> show (Array.length links)\n\n  -- Select container\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Phase 1: Build the structure tree (no data joins yet)\n  let\n    structureTree :: T.Tree Unit\n    structureTree =\n      T.named SVG \"svg\"\n        [ viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"animated-tree-cluster\"\n        , width $ num chartWidth\n        , height $ num chartHeight\n        ]\n        `T.withChildren`\n          [ T.named Group \"linksGroup\" [ attr \"class\" $ text \"links\" ]\n          , T.named Group \"nodesGroup\" [ attr \"class\" $ text \"nodes\" ]\n          ]\n\n  -- Render structure\n  selections <- renderTree container structureTree\n\n  -- Reselect groups for data rendering\n  linksGroupSel <- liftEffect $ reselectD3v2 \"linksGroup\" selections\n  nodesGroupSel <- liftEffect $ reselectD3v2 \"nodesGroup\" selections\n\n  -- Phase 2: Render links with sceneJoin\n  let\n    linksTree :: T.Tree LinkData\n    linksTree =\n      T.sceneJoin \"linkElements\" \"path\" links\n        (\\link -> T.elem Path\n          [ attr \"class\" $ text \"link\"\n          , path $ text (verticalLinkPathV3 link)\n          , fill $ text \"none\"\n          , stroke $ text \"#555\"\n          , strokeWidth $ num 1.5\n          ])\n        { keyFn: Just linkKey\n        , enterBehavior: Just\n            { initialAttrs: []  -- Start with correct path (no position animation on enter)\n            , transition: Nothing  -- Instant enter\n            }\n        , updateBehavior: Just\n            { attrs: []\n            , transition: Just transitionConfig  -- Animate path changes\n            }\n        , exitBehavior: Just\n            { attrs: []\n            , transition: Nothing  -- Instant exit\n            }\n        }\n\n  _ <- renderTree linksGroupSel linksTree\n\n  -- Phase 3: Render nodes with sceneJoin\n  let\n    nodesTree :: T.Tree TreeModel\n    nodesTree =\n      T.sceneJoin \"nodeElements\" \"circle\" nodes\n        (\\node -> T.elem Circle\n          [ attr \"class\" $ text \"node\"\n          , cx $ num (evalNode nodeX node)  -- v3: node.x\n          , cy $ num (evalNode nodeY node)  -- v3: node.y\n          , r $ num 4.0\n          , fill $ text \"#999\"\n          , stroke $ text \"#555\"\n          , strokeWidth $ num 1.5\n          ])\n        { keyFn: Just nodeKey\n        , enterBehavior: Just\n            { initialAttrs: []  -- Start at final position (no animation on enter)\n            , transition: Nothing\n            }\n        , updateBehavior: Just\n            { attrs: []\n            , transition: Just transitionConfig  -- Animate position changes\n            }\n        , exitBehavior: Just\n            { attrs: []\n            , transition: Nothing\n            }\n        }\n\n  _ <- renderTree nodesGroupSel nodesTree\n\n  liftEffect $ Console.log \"Rendered with TreeAPI sceneJoin\"\n\n  pure { dataTree, chartWidth, chartHeight }\n\n-- | Update existing visualization with new layout\n-- | This re-renders with new positions, and sceneJoin handles the transitions\nupdate :: Tree TreeModel -> String -> Number -> Number -> LayoutType -> Effect Unit\nupdate dataTree selector chartWidth chartHeight currentLayout = runD3v2M do\n  liftEffect $ Console.log $ \"=== Updating AnimatedTreeCluster to \" <> show currentLayout <> \" ===\"\n\n  -- Apply layout\n  let positioned = case currentLayout of\n        TreeLayout ->\n          let config = defaultTreeConfig { size = { width: chartWidth, height: chartHeight } }\n          in treeWithSorting config dataTree\n        ClusterLayout ->\n          let config = defaultClusterConfig { size = { width: chartWidth, height: chartHeight } }\n          in cluster config dataTree\n\n  -- Flatten nodes and create links\n  let nodes = flattenTree positioned\n  let links = makeLinks positioned\n\n  -- Select existing groups (structure already rendered)\n  linksGroupSel <- select (selector <> \" .links\") :: _ (D3v2Selection_ SEmpty Element Unit)\n  nodesGroupSel <- select (selector <> \" .nodes\") :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Re-render links with new positions - sceneJoin's updateBehavior handles transitions\n  let\n    linksTree :: T.Tree LinkData\n    linksTree =\n      T.sceneJoin \"linkElements\" \"path\" links\n        (\\link -> T.elem Path\n          [ attr \"class\" $ text \"link\"\n          , path $ text (verticalLinkPathV3 link)\n          , fill $ text \"none\"\n          , stroke $ text \"#555\"\n          , strokeWidth $ num 1.5\n          ])\n        { keyFn: Just linkKey\n        , enterBehavior: Nothing\n        , updateBehavior: Just\n            { attrs: []\n            , transition: Just transitionConfig\n            }\n        , exitBehavior: Nothing\n        }\n\n  _ <- renderTree linksGroupSel linksTree\n\n  -- Re-render nodes with new positions\n  let\n    nodesTree :: T.Tree TreeModel\n    nodesTree =\n      T.sceneJoin \"nodeElements\" \"circle\" nodes\n        (\\node -> T.elem Circle\n          [ attr \"class\" $ text \"node\"\n          , cx $ num (evalNode nodeX node)\n          , cy $ num (evalNode nodeY node)\n          , r $ num 4.0\n          , fill $ text \"#999\"\n          , stroke $ text \"#555\"\n          , strokeWidth $ num 1.5\n          ])\n        { keyFn: Just nodeKey\n        , enterBehavior: Nothing\n        , updateBehavior: Just\n            { attrs: []\n            , transition: Just transitionConfig\n            }\n        , exitBehavior: Nothing\n        }\n\n  _ <- renderTree nodesGroupSel nodesTree\n\n  liftEffect $ Console.log \"Update complete with sceneJoin transitions\"\n\n  pure unit\n"

snippet_sankey_content :: String
snippet_sankey_content = "module D3.Viz.TreeAPI.SankeyDiagram where\n\n-- | Sankey diagram visualization using TreeAPI\n-- | Pure PureScript layout with declarative TreeAPI rendering\n-- | Uses v3 expressions for computed attributes\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Maybe (Maybe(..))\nimport Data.String.CodeUnits (indexOf)\nimport Data.String.Pattern (Pattern(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\nimport DataViz.Layout.Sankey.CSV (parseSankeyCSV)\nimport DataViz.Layout.Sankey.Compute (computeLayout)\nimport DataViz.Layout.Sankey.Path (generateLinkPath)\nimport DataViz.Layout.Sankey.Types (SankeyLink, SankeyNode, NodeID(..), LinkID(..))\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, strokeWidth, opacity, path)\nimport PSD3.Internal.Capabilities.Selection (renderTree, select)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL imports\nimport PSD3.Expr.Expr (class NumExpr, class BoolExpr, class CompareExpr, class StringExpr, ifThenElse, add)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((+:), (-:), (/:), (<.), s)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- | Indexed link for data join (ensures unique keys)\nnewtype IndexedLink = IndexedLink { index :: Int, link :: SankeyLink }\n\ninstance Eq IndexedLink where\n  eq (IndexedLink a) (IndexedLink b) = a.index == b.index\n\ninstance Ord IndexedLink where\n  compare (IndexedLink a) (IndexedLink b) = compare a.index b.index\n\n-- | Indexed node for data join\nnewtype IndexedNode = IndexedNode { index :: Int, node :: SankeyNode }\n\ninstance Eq IndexedNode where\n  eq (IndexedNode a) (IndexedNode b) = a.index == b.index\n\ninstance Ord IndexedNode where\n  compare (IndexedNode a) (IndexedNode b) = compare a.index b.index\n\n-- =============================================================================\n-- v3 Expressions for Label Positioning\n-- =============================================================================\n\n-- | Flattened node data for v3 expression access\n-- | We add chartWidth to the datum so conditional positioning works\ntype LabelDatum =\n  { name :: String\n  , x0 :: Number\n  , x1 :: Number\n  , y0 :: Number\n  , y1 :: Number\n  , color :: String\n  , chartWidth :: Number  -- Baked in for conditional positioning\n  }\n\n-- Row type for v3 DatumExpr\ntype LabelRow = (name :: String, x0 :: Number, x1 :: Number, y0 :: Number, y1 :: Number, color :: String, chartWidth :: Number)\n\n-- | Convert SankeyNode to LabelDatum with chart width\ntoLabelDatum :: Number -> SankeyNode -> LabelDatum\ntoLabelDatum chartWidth node =\n  { name: node.name\n  , x0: node.x0\n  , x1: node.x1\n  , y0: node.y0\n  , y1: node.y1\n  , color: node.color\n  , chartWidth\n  }\n\n-- Field accessors for v3\nlabelX0 :: forall repr. DatumExpr repr LabelRow => repr Number\nlabelX0 = field (Proxy :: Proxy \"x0\")\n\nlabelX1 :: forall repr. DatumExpr repr LabelRow => repr Number\nlabelX1 = field (Proxy :: Proxy \"x1\")\n\nlabelY0 :: forall repr. DatumExpr repr LabelRow => repr Number\nlabelY0 = field (Proxy :: Proxy \"y0\")\n\nlabelY1 :: forall repr. DatumExpr repr LabelRow => repr Number\nlabelY1 = field (Proxy :: Proxy \"y1\")\n\nlabelChartWidth :: forall repr. DatumExpr repr LabelRow => repr Number\nlabelChartWidth = field (Proxy :: Proxy \"chartWidth\")\n\n-- | v3 expression: Label X position\n-- | If node is on left half, position right of node; otherwise left\nlabelXExpr :: forall repr. NumExpr repr => BoolExpr repr => CompareExpr repr => DatumExpr repr LabelRow => repr Number\nlabelXExpr = ifThenElse\n  (labelX0 <. (labelChartWidth /: 2.0))  -- If on left half of chart\n  (labelX1 +: 6.0)                        -- Position to the right of node\n  (labelX0 -: 6.0)                        -- Position to the left of node\n\n-- | v3 expression: Label Y position (vertically centered on node)\nlabelYExpr :: forall repr. NumExpr repr => DatumExpr repr LabelRow => repr Number\nlabelYExpr = add labelY0 labelY1 /: 2.0\n\n-- | v3 expression: Text anchor based on node position\nlabelAnchorExpr :: forall repr. NumExpr repr => BoolExpr repr => CompareExpr repr => StringExpr repr => DatumExpr repr LabelRow => repr String\nlabelAnchorExpr = ifThenElse\n  (labelX0 <. (labelChartWidth /: 2.0))\n  (s \"start\")\n  (s \"end\")\n\n-- | Evaluate v3 expression for label datum\nevalLabelNum :: EvalD LabelDatum Number -> LabelDatum -> Number\nevalLabelNum expr datum = runEvalD expr datum 0\n\nevalLabelStr :: EvalD LabelDatum String -> LabelDatum -> String\nevalLabelStr expr datum = runEvalD expr datum 0\n\n-- | Check if a color string is a gradient URL reference\nisGradientColor :: String -> Boolean\nisGradientColor color = case indexOf (Pattern \"url(#sankey-gradient-\") color of\n  Just _ -> true\n  Nothing -> false\n\n-- | Newtype for gradient data\nnewtype GradientSpec = GradientSpec\n  { id :: String\n  , sourceColor :: String\n  , targetColor :: String\n  , sourceX :: Number\n  , targetX :: Number\n  }\n\n-- | Look up node by ID\nfindNodeById :: Array SankeyNode -> NodeID -> Maybe SankeyNode\nfindNodeById nodes nodeId = Array.find (\\n -> n.index == nodeId) nodes\n\n-- | Create gradient specs for links that need gradients\ncreateGradientSpecs :: Array SankeyNode -> Array SankeyLink -> Array GradientSpec\ncreateGradientSpecs nodes links = Array.mapMaybe mkGradientSpec links\n  where\n    mkGradientSpec :: SankeyLink -> Maybe GradientSpec\n    mkGradientSpec link =\n      if isGradientColor link.color then do\n        sourceNode <- findNodeById nodes link.sourceIndex\n        targetNode <- findNodeById nodes link.targetIndex\n        let (LinkID idx) = link.index\n        pure $ GradientSpec\n          { id: \"sankey-gradient-\" <> show idx\n          , sourceColor: sourceNode.color\n          , targetColor: targetNode.color\n          , sourceX: sourceNode.x1  -- Right edge of source\n          , targetX: targetNode.x0  -- Left edge of target\n          }\n      else Nothing\n\n-- | Draw Sankey diagram with TreeAPI\ndrawSankey\n  :: String\n  -> String\n  -> Number\n  -> Number\n  -> Effect Unit\ndrawSankey csvData containerSelector w h = runD3v2M do\n  liftEffect $ Console.log \"=== Drawing Sankey with TreeAPI ===\"\n\n  -- Select container\n  container <- select containerSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Parse CSV and compute layout (pure PureScript!)\n  let linkInputs = parseSankeyCSV csvData\n  liftEffect $ Console.log $ \"Parsed \" <> show (Array.length linkInputs) <> \" links from CSV\"\n\n  let layoutResult = computeLayout linkInputs w h\n  liftEffect $ Console.log $ \"Layout computed: \" <> show (Array.length layoutResult.nodes) <> \" nodes, \"\n    <> show (Array.length layoutResult.links)\n    <> \" links\"\n\n  -- Wrap nodes and links with indices for unique keys\n  let indexedNodes = Array.mapWithIndex (\\i node -> IndexedNode { index: i, node }) layoutResult.nodes\n  let indexedLinks = Array.mapWithIndex (\\i link -> IndexedLink { index: i, link }) layoutResult.links\n\n  -- Create gradient definitions for links that use SourceTargetGradient\n  let gradientSpecs = createGradientSpecs layoutResult.nodes layoutResult.links\n  liftEffect $ Console.log $ \"Created \" <> show (Array.length gradientSpecs) <> \" gradient definitions\"\n\n  -- Build gradient trees (each gradient is a linearGradient element with two stops)\n  let\n    mkGradientTree :: GradientSpec -> T.Tree Unit\n    mkGradientTree (GradientSpec spec) =\n      T.named LinearGradient spec.id\n        [ attr \"id\" $ text spec.id\n        , attr \"gradientUnits\" $ text \"userSpaceOnUse\"  -- Use absolute pixel coordinates\n        , attr \"x1\" $ num spec.sourceX\n        , attr \"x2\" $ num spec.targetX\n        , attr \"y1\" $ num 0.0  -- Horizontal gradient\n        , attr \"y2\" $ num 0.0\n        ]\n        `T.withChildren`\n          [ T.elem Stop [ attr \"offset\" $ text \"0%\", attr \"stop-color\" $ text spec.sourceColor ]\n          , T.elem Stop [ attr \"offset\" $ text \"100%\", attr \"stop-color\" $ text spec.targetColor ]\n          ]\n\n    -- Build defs children (empty if no gradients needed)\n    defsChildren :: Array (T.Tree Unit)\n    defsChildren = map mkGradientTree gradientSpecs\n\n  -- Declarative tree structure (SVG groups only, no data)\n  let\n    sankeyTree :: T.Tree Unit\n    sankeyTree =\n      T.named SVG \"svg\"\n        [ width $ num w\n        , height $ num h\n        , viewBox 0.0 0.0 w h\n        , attr \"id\" $ text \"sankey-svg\"\n        , attr \"class\" $ text \"sankey\"\n        ]\n        `T.withChildren`\n          ( [ T.named Defs \"defs\" [] `T.withChildren` defsChildren\n            , T.named Group \"linksGroup\" [ attr \"class\" $ text \"links\" ]\n            , T.named Group \"nodesGroup\" [ attr \"class\" $ text \"nodes\" ]\n            , T.named Group \"labelsGroup\" [ attr \"class\" $ text \"labels\" ]\n            ]\n          )\n\n  -- Render structure\n  selections <- renderTree container sankeyTree\n\n  -- Reselect groups for data rendering\n  linksGroupSel <- liftEffect $ reselectD3v2 \"linksGroup\" selections\n  nodesGroupSel <- liftEffect $ reselectD3v2 \"nodesGroup\" selections\n  labelsGroupSel <- liftEffect $ reselectD3v2 \"labelsGroup\" selections\n\n  -- Render links (filled paths - ribbons)\n  let\n    linksTree :: T.Tree IndexedLink\n    linksTree =\n      T.joinData \"linkElements\" \"path\" indexedLinks $ \\(IndexedLink il) ->\n        let\n          link = il.link\n        in\n          T.elem Path\n            [ attr \"class\" $ text \"sankey-link\"\n            , path $ text $ generateLinkPath layoutResult.nodes link\n            , fill $ text link.color\n            , opacity $ num 0.5\n            ]\n\n  _ <- renderTree linksGroupSel linksTree\n\n  -- Render nodes (rectangles)\n  let\n    nodesTree :: T.Tree IndexedNode\n    nodesTree =\n      T.joinData \"nodeElements\" \"rect\" indexedNodes $ \\(IndexedNode in_) ->\n        let\n          node = in_.node\n        in\n          T.elem Rect\n            [ attr \"class\" $ text \"sankey-node\"\n            , x $ num node.x0\n            , y $ num node.y0\n            , width $ num (node.x1 - node.x0)\n            , height $ num (node.y1 - node.y0)\n            , fill $ text node.color\n            , stroke $ text \"#000\"\n            , strokeWidth $ num 1.0\n            , opacity $ num 0.3\n            ]\n\n  _ <- renderTree nodesGroupSel nodesTree\n\n  -- Render labels using v3 expressions for conditional positioning\n  -- Convert nodes to LabelDatum with chartWidth baked in\n  let labelData = map (\\(IndexedNode in_) -> toLabelDatum w in_.node) indexedNodes\n\n  let\n    labelsTree :: T.Tree LabelDatum\n    labelsTree =\n      T.joinData \"labelElements\" \"text\" labelData $ \\datum ->\n        -- v3 expressions evaluate the conditional positioning logic\n        T.elem Text\n          [ attr \"class\" $ text \"sankey-label\"\n          , x $ num (evalLabelNum labelXExpr datum)      -- v3: if x0 < w/2 then x1+6 else x0-6\n          , y $ num (evalLabelNum labelYExpr datum)      -- v3: (y0 + y1) / 2\n          , attr \"text-anchor\" $ text (evalLabelStr labelAnchorExpr datum)  -- v3: if x0 < w/2 then \"start\" else \"end\"\n          , fill $ text \"#000\"\n          , attr \"text-content\" $ text datum.name\n          ]\n\n  _ <- renderTree labelsGroupSel labelsTree\n\n  liftEffect $ Console.log \"Sankey diagram rendered with TreeAPI\"\n\n  pure unit\n\n-- | Entry point with fixed dimensions for Tour page\nstartSankey :: String -> String -> Effect Unit\nstartSankey csvData containerSelector = do\n  -- Fixed dimensions for embedded view\n  -- Reduced from 900 to 750 to fit within tutorial-section max-width (52rem = 832px)\n  let w = 750.0\n  let h = 500.0\n\n  drawSankey csvData containerSelector w h\n"

snippet_chord_content :: String
snippet_chord_content = "module D3.Viz.TreeAPI.ChordDiagram where\n\n-- | Chord diagram visualization using TreeAPI\n-- | Based on Baton Rouge bridge traffic analysis example\n-- | Inspired by: https://www.streetlightdata.com/planning-bridges-louisiana/\n-- | Uses v3 expressions for label positioning with trig functions\n\nimport Prelude hiding (add, sub, mul)\n\nimport Data.Array (index, length, mapWithIndex, (!!))\nimport Data.Either (Either(..))\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\nimport PSD3.Shared.Data (loadBridgesData)\nimport PSD3.Internal.FFI (arcGenerator_, arcPath_, chordArray_, chordGroups_, chordLayoutWithPadAngle_, ribbonGenerator_, ribbonPath_, setArcInnerRadius_, setArcOuterRadius_, setRibbonRadius_)\nimport PSD3.Internal.Types (Datum_)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, strokeWidth, opacity, path, fontSize)\nimport PSD3.Internal.Capabilities.Selection (renderTree, select)\nimport PSD3.Interpreter.D3 (D3v2Selection_, reselectD3v2, runD3v2M)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\n\n-- v3 DSL imports\nimport PSD3.Expr.Expr (class NumExpr, class BoolExpr, class CompareExpr, class StringExpr, class TrigExpr, ifThenElse, add, sub, mul)\nimport PSD3.Expr.Expr (pi, cos, sin) as V3\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((/:), (>.), s)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- | Traffic flow matrix (11 regions of Baton Rouge)\ntype TrafficMatrix = Array (Array Number)\n\n-- | Region labels for Baton Rouge traffic analysis\ntype RegionLabels = Array String\n\n-- | Baton Rouge regions\nbatonRougeRegions :: RegionLabels\nbatonRougeRegions =\n  [ \"WBR\" -- West Baton Rouge\n  , \"Pointe Coupee\"\n  , \"Iberville\"\n  , \"EBR - M\" -- East Baton Rouge - Main\n  , \"EBR - S\" -- East Baton Rouge - South\n  , \"Ascension\"\n  , \"Livingston\"\n  , \"I-10 Lafayette\"\n  , \"US 190 Opelousas\"\n  , \"I-10 NOLA\"\n  , \"I-12\"\n  ]\n\n-- | Color palette for regions (color-by-origin like the example)\n-- | This is keyed by region name, not index, to handle alphabetical sorting\nregionColorMap :: Map.Map String String\nregionColorMap = Map.fromFoldable\n  [ Tuple \"WBR\" \"#d62728\" -- Red (dominant in image)\n  , Tuple \"Pointe Coupee\" \"#ff9896\" -- Light red\n  , Tuple \"Point Coupe\" \"#ff9896\" -- Light red (alternate spelling)\n  , Tuple \"Iberville\" \"#e7969c\" -- Pink red\n  , Tuple \"EBR-M\" \"#5ab4ac\" -- Teal\n  , Tuple \"EBR - M\" \"#5ab4ac\" -- Teal (with spaces)\n  , Tuple \"EBR-S\" \"#c7eae5\" -- Light teal\n  , Tuple \"EBR - S\" \"#c7eae5\" -- Light teal (with spaces)\n  , Tuple \"Ascension\" \"#80cdc1\" -- Medium teal\n  , Tuple \"Livingston\" \"#d8daeb\" -- Light purple\n  , Tuple \"I-10 Lafayette\" \"#b2abd2\" -- Purple\n  , Tuple \"US-190 Opelousas\" \"#ff7f0e\" -- Orange\n  , Tuple \"US 190 Opelousas\" \"#ff7f0e\" -- Orange (alternate)\n  , Tuple \"I-10 NOLA\" \"#ffbb78\" -- Light orange\n  , Tuple \"I-12\" \"#98df8a\" -- Light green\n  ]\n\n-- | Get color for a region by name\ngetRegionColor :: RegionLabels -> Int -> String\ngetRegionColor labels idx = case index labels idx of\n  Just label -> case Map.lookup label regionColorMap of\n    Just color -> color\n    Nothing -> \"#999999\" -- Default gray for unknown regions\n  Nothing -> \"#999999\"\n\n-- | Sample traffic matrix (values guesstimated from image, original data not available)\nbatonRougeTraffic :: TrafficMatrix\nbatonRougeTraffic =\n  [ [ 0.0, 10.0, 5.0, 80.0, 20.0, 15.0, 8.0, 12.0, 6.0, 4.0, 3.0 ] -- WBR\n  , [ 10.0, 0.0, 3.0, 15.0, 8.0, 5.0, 2.0, 4.0, 1.0, 1.0, 1.0 ] -- Pointe Coupee\n  , [ 5.0, 3.0, 0.0, 20.0, 12.0, 8.0, 4.0, 3.0, 2.0, 1.0, 1.0 ] -- Iberville\n  , [ 80.0, 15.0, 20.0, 0.0, 40.0, 30.0, 25.0, 18.0, 15.0, 10.0, 8.0 ] -- EBR - M (main hub)\n  , [ 20.0, 8.0, 12.0, 40.0, 0.0, 35.0, 20.0, 15.0, 10.0, 8.0, 6.0 ] -- EBR - S\n  , [ 15.0, 5.0, 8.0, 30.0, 35.0, 0.0, 18.0, 12.0, 8.0, 6.0, 4.0 ] -- Ascension\n  , [ 8.0, 2.0, 4.0, 25.0, 20.0, 18.0, 0.0, 10.0, 6.0, 4.0, 3.0 ] -- Livingston\n  , [ 12.0, 4.0, 3.0, 18.0, 15.0, 12.0, 10.0, 0.0, 5.0, 3.0, 2.0 ] -- I-10 Lafayette\n  , [ 6.0, 1.0, 2.0, 15.0, 10.0, 8.0, 6.0, 5.0, 0.0, 2.0, 1.0 ] -- US 190\n  , [ 4.0, 1.0, 1.0, 10.0, 8.0, 6.0, 4.0, 3.0, 2.0, 0.0, 1.0 ] -- I-10 NOLA\n  , [ 3.0, 1.0, 1.0, 8.0, 6.0, 4.0, 3.0, 2.0, 1.0, 1.0, 0.0 ] -- I-12\n  ]\n\n-- | Accessor helpers for chord data\ngetSourceIndex :: Datum_ -> Int\ngetSourceIndex d = (unsafeCoerce d).source.index\n\ngetTargetIndex :: Datum_ -> Int\ngetTargetIndex d = (unsafeCoerce d).target.index\n\ngetSourceValue :: Datum_ -> Number\ngetSourceValue d = (unsafeCoerce d).source.value\n\ngetTargetValue :: Datum_ -> Number\ngetTargetValue d = (unsafeCoerce d).target.value\n\ngetGroupIndex :: Datum_ -> Int\ngetGroupIndex d = (unsafeCoerce d).index\n\n-- | Get the index of the dominant flow direction (larger value)\n-- | This colors ribbons by where the larger flow originates\ngetDominantFlowIndex :: Datum_ -> Int\ngetDominantFlowIndex d =\n  let\n    sourceVal = getSourceValue d\n    targetVal = getTargetValue d\n  in\n    if sourceVal >= targetVal then getSourceIndex d\n    else getTargetIndex d\n\n-- | Indexed arc for data join\nnewtype IndexedArc = IndexedArc { index :: Int, datum :: Datum_ }\n\ninstance Eq IndexedArc where\n  eq (IndexedArc a) (IndexedArc b) = a.index == b.index\n\ninstance Ord IndexedArc where\n  compare (IndexedArc a) (IndexedArc b) = compare a.index b.index\n\n-- | Indexed ribbon for data join\nnewtype IndexedRibbon = IndexedRibbon { index :: Int, datum :: Datum_ }\n\ninstance Eq IndexedRibbon where\n  eq (IndexedRibbon a) (IndexedRibbon b) = a.index == b.index\n\ninstance Ord IndexedRibbon where\n  compare (IndexedRibbon a) (IndexedRibbon b) = compare a.index b.index\n\n-- =============================================================================\n-- v3 Expressions for Chord Label Positioning\n-- =============================================================================\n\n-- | Flattened label data for v3 expression access\n-- | Contains the angle (midpoint of arc) and radius for positioning\ntype ChordLabelDatum =\n  { label :: String\n  , startAngle :: Number\n  , endAngle :: Number\n  , labelRadius :: Number  -- outerR + offset\n  }\n\n-- Row type for v3 DatumExpr\ntype ChordLabelRow = (label :: String, startAngle :: Number, endAngle :: Number, labelRadius :: Number)\n\n-- Field accessors\nchordStartAngle :: forall repr. DatumExpr repr ChordLabelRow => repr Number\nchordStartAngle = field (Proxy :: Proxy \"startAngle\")\n\nchordEndAngle :: forall repr. DatumExpr repr ChordLabelRow => repr Number\nchordEndAngle = field (Proxy :: Proxy \"endAngle\")\n\nchordLabelRadius :: forall repr. DatumExpr repr ChordLabelRow => repr Number\nchordLabelRadius = field (Proxy :: Proxy \"labelRadius\")\n\n-- | v3 expression: Angle at midpoint of arc\nchordMidAngle :: forall repr. NumExpr repr => DatumExpr repr ChordLabelRow => repr Number\nchordMidAngle = add chordStartAngle chordEndAngle /: 2.0\n\n-- | v3 expression: Label X position using trig\n-- | X = labelRadius * cos(angle - π/2)\n-- | The -π/2 rotates from D3's \"12 o'clock = 0\" to standard \"3 o'clock = 0\"\nchordLabelX :: forall repr. NumExpr repr => TrigExpr repr => DatumExpr repr ChordLabelRow => repr Number\nchordLabelX = mul chordLabelRadius (V3.cos (sub chordMidAngle (V3.pi /: 2.0)))\n\n-- | v3 expression: Label Y position using trig\n-- | Y = labelRadius * sin(angle - π/2)\nchordLabelY :: forall repr. NumExpr repr => TrigExpr repr => DatumExpr repr ChordLabelRow => repr Number\nchordLabelY = mul chordLabelRadius (V3.sin (sub chordMidAngle (V3.pi /: 2.0)))\n\n-- | v3 expression: Text anchor based on angle\n-- | Right side (angle < π): \"start\", Left side (angle > π): \"end\"\nchordLabelAnchor :: forall repr. NumExpr repr => BoolExpr repr => CompareExpr repr => StringExpr repr => TrigExpr repr => DatumExpr repr ChordLabelRow => repr String\nchordLabelAnchor = ifThenElse\n  (chordMidAngle >. V3.pi)\n  (s \"end\")\n  (s \"start\")\n\n-- | Evaluate v3 expressions\nevalChordNum :: EvalD ChordLabelDatum Number -> ChordLabelDatum -> Number\nevalChordNum expr datum = runEvalD expr datum 0\n\nevalChordStr :: EvalD ChordLabelDatum String -> ChordLabelDatum -> String\nevalChordStr expr datum = runEvalD expr datum 0\n\n-- | Convert IndexedArc to ChordLabelDatum for v3 expression evaluation\ntoChordLabelDatum :: RegionLabels -> Number -> IndexedArc -> ChordLabelDatum\ntoChordLabelDatum labels outerR (IndexedArc ia) =\n  let\n    idx = getGroupIndex ia.datum\n    label = fromMaybe \"\" (labels !! idx)\n    groupData = unsafeCoerce ia.datum :: { startAngle :: Number, endAngle :: Number }\n  in\n    { label\n    , startAngle: groupData.startAngle\n    , endAngle: groupData.endAngle\n    , labelRadius: outerR + 8.0  -- Close to the arc\n    }\n\n-- | Draw Chord diagram with TreeAPI\ndrawChord\n  :: TrafficMatrix\n  -> RegionLabels\n  -> String\n  -> Number\n  -> Number\n  -> Effect Unit\ndrawChord matrix labels containerSelector w h = runD3v2M do\n  liftEffect $ Console.log \"=== Drawing Chord Diagram with TreeAPI ===\"\n\n  -- Select container\n  container <- select containerSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Dimensions\n  let outerR = 280.0\n  let innerR = 270.0\n  let centerX = w / 2.0\n  let centerY = h / 2.0\n\n  -- Create chord layout with padding between arcs (like the example)\n  -- padAngle of 0.05 radians (~3 degrees) creates nice visual separation\n  let chordData = chordLayoutWithPadAngle_ matrix 0.05\n  let groups = chordGroups_ chordData\n  let chords = chordArray_ chordData\n\n  liftEffect $ Console.log $ \"Chord layout: \" <> show (length groups) <> \" groups, \" <> show (length chords) <> \" chords\"\n\n  -- Wrap data with indices\n  let indexedGroups = mapWithIndex (\\i d -> IndexedArc { index: i, datum: d }) groups\n  let indexedChords = mapWithIndex (\\i d -> IndexedRibbon { index: i, datum: d }) chords\n\n  -- Create generators\n  let ribbonGen = setRibbonRadius_ (ribbonGenerator_ unit) innerR\n  let\n    arcGen = setArcOuterRadius_\n      (setArcInnerRadius_ (arcGenerator_ unit) innerR)\n      outerR\n\n  -- Declarative tree structure\n  let\n    chordTree :: T.Tree Unit\n    chordTree =\n      T.named SVG \"svg\"\n        [ width $ num w\n        , height $ num h\n        , viewBox 0.0 0.0 w h\n        , attr \"id\" $ text \"chord-svg\"\n        , attr \"class\" $ text \"chord-diagram\"\n        ]\n        `T.withChild`\n          ( T.named Group \"centerGroup\"\n              [ attr \"transform\" $ text (\"translate(\" <> show centerX <> \",\" <> show centerY <> \")\")\n              , attr \"class\" $ text \"chord-group\"\n              ]\n              `T.withChildren`\n                [ T.named Group \"ribbonsGroup\" [ attr \"class\" $ text \"ribbons\" ]\n                , T.named Group \"arcsGroup\" [ attr \"class\" $ text \"arcs\" ]\n                , T.named Group \"labelsGroup\" [ attr \"class\" $ text \"labels\" ]\n                ]\n          )\n\n  -- Render structure\n  selections <- renderTree container chordTree\n\n  -- Reselect groups\n  ribbonsGroupSel <- liftEffect $ reselectD3v2 \"ribbonsGroup\" selections\n  arcsGroupSel <- liftEffect $ reselectD3v2 \"arcsGroup\" selections\n  labelsGroupSel <- liftEffect $ reselectD3v2 \"labelsGroup\" selections\n\n  -- Render ribbons (colored by dominant flow direction)\n  let\n    ribbonsTree :: T.Tree IndexedRibbon\n    ribbonsTree =\n      T.joinData \"ribbonElements\" \"path\" indexedChords $ \\(IndexedRibbon ir) ->\n        let\n          dominantIdx = getDominantFlowIndex ir.datum\n          color = getRegionColor labels dominantIdx\n        in\n          T.elem Path\n            [ attr \"class\" $ text \"ribbon\"\n            , path $ text (ribbonPath_ ribbonGen ir.datum)\n            , fill $ text color\n            , opacity $ num 0.67\n            , stroke $ text \"#000000\"\n            , strokeWidth $ num 0.5\n            ]\n\n  _ <- renderTree ribbonsGroupSel ribbonsTree\n\n  -- Render arcs (outer segments)\n  let\n    arcsTree :: T.Tree IndexedArc\n    arcsTree =\n      T.joinData \"arcElements\" \"path\" indexedGroups $ \\(IndexedArc ia) ->\n        let\n          idx = getGroupIndex ia.datum\n          color = getRegionColor labels idx\n        in\n          T.elem Path\n            [ attr \"class\" $ text \"arc\"\n            , path $ text (arcPath_ arcGen ia.datum)\n            , fill $ text color\n            , stroke $ text \"#ffffff\"\n            , strokeWidth $ num 2.0\n            ]\n\n  _ <- renderTree arcsGroupSel arcsTree\n\n  -- Render labels using v3 expressions for polar positioning\n  -- Convert arcs to ChordLabelDatum with labelRadius baked in\n  let chordLabelData = map (toChordLabelDatum labels outerR) indexedGroups\n\n  let\n    labelsTree :: T.Tree ChordLabelDatum\n    labelsTree =\n      T.joinData \"labelElements\" \"text\" chordLabelData $ \\datum ->\n        -- v3 expressions with TrigExpr calculate polar coordinates\n        T.elem Text\n          [ attr \"class\" $ text \"chord-label\"\n          , x $ num (evalChordNum chordLabelX datum)      -- v3: labelRadius * cos(midAngle - π/2)\n          , y $ num (evalChordNum chordLabelY datum)      -- v3: labelRadius * sin(midAngle - π/2)\n          , attr \"text-anchor\" $ text (evalChordStr chordLabelAnchor datum)  -- v3: if midAngle > π then \"end\" else \"start\"\n          , fill $ text \"#000\"\n          , attr \"text-content\" $ text datum.label\n          , fontSize $ num 10.0\n          ]\n\n  _ <- renderTree labelsGroupSel labelsTree\n\n  liftEffect $ Console.log \"Chord diagram rendered with TreeAPI\"\n\n  pure unit\n\n-- | Entry point with fixed dimensions for Tour page\n-- | Loads data from bridges.csv\nstartChord :: String -> Effect Unit\nstartChord containerSelector = launchAff_ do\n  let w = 700.0\n  let h = 700.0\n\n  -- Load bridges data from CSV\n  result <- loadBridgesData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load bridges data: \" <> err\n    Right bridgeData -> liftEffect $ drawChord bridgeData.matrix bridgeData.labels containerSelector w h\n"

snippet_edgeBundle_content :: String
snippet_edgeBundle_content = "module D3.Viz.TreeAPI.EdgeBundleViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Number (cos, sin, pi)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (loadFlareImportsData, FlareImportRecord)\nimport DataViz.Layout.Hierarchy.EdgeBundle as EdgeBundle\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, opacity, path, fontSize, transform)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Link data type for rendering\ntype LinkDatum = { path :: String, source :: String, target :: String }\n\n-- | Node data type for rendering\ntype NodeDatum =\n  { fullName :: String\n  , shortName :: String\n  , cartX :: Number\n  , cartY :: Number\n  , isLeaf :: Boolean\n  , outgoingCount :: Int\n  , incomingCount :: Int\n  }\n\n-- | Draw edge bundle visualization\ndrawEdgeBundle :: String -> Array FlareImportRecord -> Effect Unit\ndrawEdgeBundle selector importData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Layout parameters\n  let chartSize = 700.0\n  let centerX = chartSize / 2.0\n  let centerY = chartSize / 2.0\n  let outerRadius = 300.0\n  let innerRadius = 50.0\n\n  -- Compute edge bundle layout using our PureScript implementation\n  let\n    config =\n      { getName: _.name\n      , getImports: _.imports\n      , beta: 0.85\n      , innerRadius: innerRadius\n      , outerRadius: outerRadius\n      }\n\n  let result = EdgeBundle.edgeBundle config importData\n\n  -- Convert to rendering types\n  let nodes = Array.filter _.isLeaf result.nodes\n  let links = result.links\n\n  liftEffect $ Console.log $ \"Edge bundle: \" <> show (Array.length nodes) <> \" leaf nodes, \" <> show (Array.length links) <> \" links\"\n\n  -- Create links tree\n  let\n    linksTree :: T.Tree LinkDatum\n    linksTree =\n      T.named SVG \"svg\"\n        [ width $ num chartSize\n        , height $ num chartSize\n        , viewBox 0.0 0.0 chartSize chartSize\n        , attr \"class\" $ text \"edge-bundle-viz\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"edge-bundle-content\"\n              , transform $ text (\"translate(\" <> show centerX <> \",\" <> show centerY <> \")\")\n              ]\n              `T.withChild`\n                ( T.named Group \"linksGroup\"\n                    [ attr \"class\" $ text \"links\" ]\n                    `T.withChild`\n                      ( T.joinData \"links\" \"path\" links $ \\link ->\n                          T.elem Path\n                            [ path $ text link.path\n                            , fill $ text \"none\"\n                            , stroke $ text \"steelblue\"\n                            , opacity $ num 0.4\n                            , attr \"stroke-width\" $ num 1.5\n                            , attr \"class\" $ text \"link\"\n                            ]\n                      )\n                )\n          )\n\n  -- Render links first\n  linksSelections <- renderTree container linksTree\n\n  -- Reselect chartGroup for nodes\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" linksSelections\n\n  -- Convert nodes to rendering format\n  let\n    nodeData = map\n      ( \\n ->\n          { fullName: n.fullName\n          , shortName: n.shortName\n          , cartX: n.cartX\n          , cartY: n.cartY\n          , isLeaf: n.isLeaf\n          , outgoingCount: n.outgoingCount\n          , incomingCount: n.incomingCount\n          }\n      )\n      nodes\n\n  -- Calculate text rotation for radial labels\n  let\n    getTextRotation node =\n      let\n        angle = radiansToDegrees (atan2 node.cartY node.cartX)\n      in\n        if angle > 90.0 || angle < -90.0 then angle + 180.0\n        else angle\n\n  let\n    getTextAnchor node =\n      let\n        angle = radiansToDegrees (atan2 node.cartY node.cartX)\n      in\n        if angle > 90.0 || angle < -90.0 then \"end\"\n        else \"start\"\n\n  let\n    getTextOffset node =\n      let\n        angle = radiansToDegrees (atan2 node.cartY node.cartX)\n      in\n        if angle > 90.0 || angle < -90.0 then -6.0\n        else 6.0\n\n  -- Create nodes tree\n  let\n    nodesTree :: T.Tree NodeDatum\n    nodesTree =\n      T.named Group \"nodesGroup\"\n        [ attr \"class\" $ text \"nodes\" ]\n        `T.withChild`\n          ( T.joinData \"nodeLabels\" \"text\" nodeData $ \\node ->\n              T.elem Text\n                [ x $ num node.cartX\n                , y $ num node.cartY\n                , attr \"text-content\" $ text node.shortName\n                , fontSize $ num 8.0\n                , attr \"text-anchor\" $ text (getTextAnchor node)\n                , transform $ text (\"rotate(\" <> show (getTextRotation node) <> \",\" <> show node.cartX <> \",\" <> show node.cartY <> \") translate(\" <> show (getTextOffset node) <> \", 3)\")\n                , attr \"class\" $ text \"node-label\"\n                ]\n          )\n\n  -- Render nodes\n  _ <- renderTree chartGroupSel nodesTree\n\n  liftEffect do\n    Console.log \"=== Hierarchical Edge Bundling (PureScript) ===\"\n    Console.log \"Flare library class dependencies\"\n\n-- | Helper: convert radians to degrees\nradiansToDegrees :: Number -> Number\nradiansToDegrees rad = rad * 180.0 / pi\n\n-- | Helper: atan2 (using Math)\nforeign import atan2 :: Number -> Number -> Number\n\n-- | Main entry point\nedgeBundleViz :: String -> Effect Unit\nedgeBundleViz selector = launchAff_ do\n  result <- loadFlareImportsData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load flare-imports data: \" <> err\n    Right importData -> liftEffect $ drawEdgeBundle selector importData\n"

snippet_simpleForce_content :: String
snippet_simpleForce_content = "-- | Simplest Force Graph Example\n-- |\n-- | A minimal force-directed graph with hardcoded data.\n-- | Uses TreeAPI with declarative behaviors.\nmodule D3.Viz.SimpleForceGraph\n  ( simpleForceGraph\n  ) where\n\nimport Prelude\n\nimport Data.Nullable (null)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Ref as Ref\nimport PSD3.ForceEngine.Simulation as Sim\nimport PSD3.ForceEngine.Simulation (SimulationNode, SwizzledLink)\nimport PSD3.ForceEngine.Types (ForceSpec(..), defaultManyBody, defaultCollide, defaultCenter, defaultLink)\nimport PSD3.ForceEngine.Links (swizzleLinks)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, r, fill, stroke, strokeWidth, from)\nimport PSD3.Internal.Behavior.Types (Behavior(..), DragConfig(..), ScaleExtent(..), defaultZoom)\nimport PSD3.Internal.Behavior.FFI as BehaviorFFI\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- =============================================================================\n-- Types\n-- =============================================================================\n\n-- SimulationNode already includes id :: Int, so just add name for display\ntype Node = SimulationNode (name :: String)\ntype Link = { source :: Int, target :: Int }\ntype SLink = SwizzledLink (name :: String) (index :: Int)\n\n-- =============================================================================\n-- Data\n-- =============================================================================\n\nnodes :: Array Node\nnodes =\n  [ { id: 0, name: \"A\", x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, fx: null, fy: null }\n  , { id: 1, name: \"B\", x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, fx: null, fy: null }\n  , { id: 2, name: \"C\", x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, fx: null, fy: null }\n  , { id: 3, name: \"D\", x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, fx: null, fy: null }\n  , { id: 4, name: \"E\", x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, fx: null, fy: null }\n  ]\n\nlinks :: Array Link\nlinks =\n  [ { source: 0, target: 1 }\n  , { source: 0, target: 2 }\n  , { source: 1, target: 2 }\n  , { source: 2, target: 3 }\n  , { source: 3, target: 4 }\n  , { source: 4, target: 0 }\n  ]\n\n-- =============================================================================\n-- Constants\n-- =============================================================================\n\nsimulationId :: String\nsimulationId = \"simple-force\"\n\n-- =============================================================================\n-- Visualization\n-- =============================================================================\n\nsimpleForceGraph :: String -> Effect (Effect Unit)\nsimpleForceGraph selector = do\n  let swizzled = swizzleLinks nodes links \\src tgt i _ -> { source: src, target: tgt, index: i }\n\n  -- Create simulation\n  sim <- Sim.create Sim.defaultConfig\n  Sim.setNodes nodes sim\n  Sim.setLinks links sim\n  Sim.addForce (ManyBody \"charge\" defaultManyBody { strength = -200.0 }) sim\n  Sim.addForce (Collide \"collide\" defaultCollide { radius = 20.0 }) sim\n  Sim.addForce (Center \"center\" defaultCenter) sim\n  Sim.addForce (Link \"links\" defaultLink { distance = 50.0 }) sim\n\n  -- Register simulation for declarative drag\n  BehaviorFFI.registerSimulation_ simulationId (Sim.reheat sim)\n\n  -- Create state ref for tick updates\n  stateRef <- Ref.new { nodes, swizzled }\n\n  -- Render initial DOM structure using TreeAPI\n  runD3v2M do\n    container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n    let\n      containerTree :: T.Tree Unit\n      containerTree =\n        T.named SVG \"svg\"\n          [ width $ num 400.0, height $ num 300.0, viewBox (-200.0) (-150.0) 400.0 300.0, attr \"id\" $ text \"simple-force-svg\" ]\n          `T.withBehaviors` [ Zoom $ defaultZoom (ScaleExtent 0.5 4.0) \"#simple-force-zoom-group\" ]\n          `T.withChildren`\n            [ T.named Group \"zoom-group\" [ attr \"id\" $ text \"simple-force-zoom-group\" ]\n                `T.withChildren`\n                  [ T.named Group \"links-group\" [ attr \"id\" $ text \"simple-force-links\" ]\n                  , T.named Group \"nodes-group\" [ attr \"id\" $ text \"simple-force-nodes\" ]\n                  ]\n            ]\n    _ <- renderTree container containerTree\n    pure unit\n\n  -- Tick handler renders with TreeAPI\n  Sim.onTick (tick stateRef selector) sim\n  Sim.start sim\n\n  -- Return cleanup\n  pure do\n    Sim.stop sim\n    BehaviorFFI.unregisterSimulation_ simulationId\n\n-- | Tick handler - renders nodes and links with current positions\ntick :: Ref.Ref { nodes :: Array Node, swizzled :: Array SLink } -> String -> Effect Unit\ntick stateRef _selector = runD3v2M do\n  state <- liftEffect $ Ref.read stateRef\n\n  -- Select the groups\n  linksGroup <- select \"#simple-force-links\" :: _ (D3v2Selection_ SEmpty Element Unit)\n  nodesGroup <- select \"#simple-force-nodes\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Render links\n  let\n    linksTree = T.joinData \"links\" \"line\" state.swizzled $ \\_ ->\n      T.elem Line\n        [ from \"x1\" (_.source.x :: SLink -> Number)\n        , from \"y1\" (_.source.y :: SLink -> Number)\n        , from \"x2\" (_.target.x :: SLink -> Number)\n        , from \"y2\" (_.target.y :: SLink -> Number)\n        , stroke $ text \"#999\"\n        , strokeWidth $ num 2.0\n        ]\n  _ <- renderTree linksGroup linksTree\n\n  -- Render nodes with drag behavior\n  let\n    nodesTree = T.joinData \"nodes\" \"circle\" state.nodes $ \\_ ->\n      T.elem Circle\n        [ from \"cx\" (_.x :: Node -> Number)\n        , from \"cy\" (_.y :: Node -> Number)\n        , r $ num 10.0\n        , fill $ text \"#69b3a2\"\n        , stroke $ text \"#fff\"\n        , strokeWidth $ num 2.0\n        ]\n        `T.withBehaviors` [ Drag (SimulationDrag simulationId) ]\n  _ <- renderTree nodesGroup nodesTree\n\n  pure unit\n"

snippet_lesMis_content :: String
snippet_lesMis_content = "-- | Les Misérables Force-Directed Graph (V3 Architecture)\n-- |\n-- | A clean, simple force-directed graph using the ForceEngine library.\n-- | Uses TreeAPI with declarative behaviors for rendering.\n-- |\n-- | NO FFI in this demo - all D3 interaction goes through library modules.\nmodule D3.Viz.LesMisV3.Draw\n  ( startLesMis\n  ) where\n\nimport Prelude\n\nimport D3.Viz.LesMisV3.Model (LesMisModel, LesMisNode)\nimport Data.Number (sqrt)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Ref as Ref\nimport PSD3.ForceEngine.Simulation as Sim\nimport PSD3.ForceEngine.Types (ForceSpec(..), defaultManyBody, defaultCollide, defaultLink, defaultCenter)\nimport PSD3.ForceEngine.Links (swizzleLinks)\nimport PSD3.Scale (schemeCategory10At)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, r, stroke, strokeWidth, opacity, from, fromStr)\nimport PSD3.Internal.Behavior.FFI as BehaviorFFI\nimport PSD3.Internal.Behavior.Types (Behavior(..), DragConfig(..), ScaleExtent(..), defaultZoom)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- =============================================================================\n-- Types\n-- =============================================================================\n\n-- | Swizzled link (source/target are node references, not indices)\ntype SwizzledLink =\n  { source :: LesMisNode\n  , target :: LesMisNode\n  , value :: Number\n  , index :: Int\n  }\n\n-- =============================================================================\n-- Constants\n-- =============================================================================\n\nsvgWidth :: Number\nsvgWidth = 900.0\n\nsvgHeight :: Number\nsvgHeight = 600.0\n\n-- | Simulation ID for the registry\n-- | Separate from GUPDemo to avoid interference\nsimulationId :: String\nsimulationId = \"lesmis-main\"\n\n-- =============================================================================\n-- Entry Point\n-- =============================================================================\n\n-- | Clone a node to create an independent copy\n-- | This prevents mutations (like fx/fy from drag) from affecting other simulations\ncloneNode :: LesMisNode -> LesMisNode\ncloneNode n = { id: n.id, name: n.name, group: n.group, x: n.x, y: n.y, vx: n.vx, vy: n.vy, fx: n.fx, fy: n.fy }\n\n-- | Start the Les Misérables force-directed graph\n-- | Returns a cleanup function to stop the simulation\nstartLesMis :: LesMisModel -> String -> Effect (Effect Unit)\nstartLesMis model containerSelector = do\n  -- Clone nodes to have independent data from other visualizations\n  let clonedNodes = map cloneNode model.nodes\n\n  -- Swizzle links using cloned nodes\n  let swizzledLinks = swizzleLinks clonedNodes model.links \\src tgt i link ->\n        { source: src, target: tgt, index: i, value: link.value }\n\n  -- Create simulation using library API\n  sim <- Sim.create Sim.defaultConfig\n  Sim.setNodes clonedNodes sim\n  Sim.setLinks model.links sim\n\n  -- Register simulation for declarative drag\n  BehaviorFFI.registerSimulation_ simulationId (Sim.reheat sim)\n\n  -- Add forces using declarative ForceSpec\n  Sim.addForce (ManyBody \"charge\" defaultManyBody { strength = -100.0, distanceMax = 500.0 }) sim\n  Sim.addForce (Collide \"collision\" defaultCollide { radius = 5.0, strength = 1.0, iterations = 1 }) sim\n  Sim.addForce (Center \"center\" defaultCenter { x = 0.0, y = 0.0, strength = 0.1 }) sim\n  Sim.addForce (Link \"links\" defaultLink { distance = 30.0, strength = 0.5, iterations = 1 }) sim\n\n  -- Create state ref for tick updates\n  stateRef <- Ref.new { nodes: clonedNodes, links: swizzledLinks }\n\n  -- Render initial SVG structure using TreeAPI\n  runD3v2M do\n    container <- select containerSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n    let containerTree :: T.Tree Unit\n        containerTree =\n          T.named SVG \"svg\"\n            [ width $ num svgWidth\n            , height $ num svgHeight\n            , viewBox ((-svgWidth) / 2.0) ((-svgHeight) / 2.0) svgWidth svgHeight\n            , attr \"id\" $ text \"lesmis-v3-svg\"\n            , attr \"class\" $ text \"lesmis-v3\"\n            ]\n            `T.withBehaviors` [ Zoom $ defaultZoom (ScaleExtent 0.1 10.0) \"#lesmis-zoom-group\" ]\n            `T.withChildren`\n              [ T.named Group \"zoom-group\" [ attr \"id\" $ text \"lesmis-zoom-group\", attr \"class\" $ text \"zoom-group\" ]\n                  `T.withChildren`\n                    [ T.named Group \"links\" [ attr \"id\" $ text \"lesmis-links\", attr \"class\" $ text \"links\" ]\n                    , T.named Group \"nodes\" [ attr \"id\" $ text \"lesmis-nodes\", attr \"class\" $ text \"nodes\" ]\n                    ]\n              ]\n    _ <- renderTree container containerTree\n    pure unit\n\n  -- Set tick callback to update DOM using TreeAPI\n  Sim.onTick (updateDOM stateRef) sim\n\n  -- Start simulation\n  Sim.start sim\n\n  -- Return cleanup function (also unregisters simulation)\n  pure do\n    Sim.stop sim\n    BehaviorFFI.unregisterSimulation_ simulationId\n\n-- =============================================================================\n-- DOM Updates (on each tick) - using TreeAPI\n-- =============================================================================\n\n-- | Update DOM positions based on current node positions\n-- | Called on each simulation tick\nupdateDOM :: Ref.Ref { nodes :: Array LesMisNode, links :: Array SwizzledLink } -> Effect Unit\nupdateDOM stateRef = runD3v2M do\n  state <- liftEffect $ Ref.read stateRef\n\n  -- Select the groups\n  linksGroup <- select \"#lesmis-links\" :: _ (D3v2Selection_ SEmpty Element Unit)\n  nodesGroup <- select \"#lesmis-nodes\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Render links\n  let linksTree = T.joinData \"links\" \"line\" state.links $ \\_ ->\n        T.elem Line\n          [ from \"x1\" (_.source.x :: SwizzledLink -> Number)\n          , from \"y1\" (_.source.y :: SwizzledLink -> Number)\n          , from \"x2\" (_.target.x :: SwizzledLink -> Number)\n          , from \"y2\" (_.target.y :: SwizzledLink -> Number)\n          , from \"stroke-width\" ((\\link -> sqrt link.value) :: SwizzledLink -> Number)\n          , stroke $ text \"#999\"\n          , opacity $ num 0.6\n          ]\n  _ <- renderTree linksGroup linksTree\n\n  -- Render nodes with drag behavior\n  let nodesTree = T.joinData \"nodes\" \"circle\" state.nodes $ \\_ ->\n        T.elem Circle\n          [ from \"cx\" (_.x :: LesMisNode -> Number)\n          , from \"cy\" (_.y :: LesMisNode -> Number)\n          , r $ num 5.0\n          , fromStr \"fill\" ((\\node -> schemeCategory10At node.group) :: LesMisNode -> String)\n          , stroke $ text \"#fff\"\n          , strokeWidth $ num 1.5\n          ]\n          `T.withBehaviors` [ Drag (SimulationDrag simulationId) ]\n  _ <- renderTree nodesGroup nodesTree\n\n  pure unit\n"

snippet_v3Parabola_content :: String
snippet_v3Parabola_content = "-- | Expression DSL Parabola Demo - Live Browser Rendering\n-- |\n-- | This demonstrates the v3 \"Finally Tagless\" DSL rendering to actual DOM via D3.\n-- |\n-- | The same polymorphic expressions produce:\n-- |   - Runtime values for D3 (EvalD)\n-- |   - Source code for display (CodeGen)\n-- |   - SVG strings for server-side (SVGD) - not shown here\n-- |\n-- | This is the \"money shot\" - same expression, three different outputs!\nmodule D3.Viz.TreeAPI.V3ParabolaDemo where\n\nimport Prelude hiding (add)\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\n\n-- v2 infrastructure for D3 rendering\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr, fnAttr, fnAttrStr)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL imports\nimport PSD3.Expr.Expr (class NumExpr, lit, add, str)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((*:), (+:))\nimport PSD3.Expr.Interpreter.CodeGen (CodeGen, runCodeGen)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- =============================================================================\n-- Data Type\n-- =============================================================================\n\ntype ParabolaPoint = { x :: Number, y :: Number }\n\ntype ParabolaRow = ( x :: Number, y :: Number )\n\n-- Sample data: y = x²\nparabolaData :: Array ParabolaPoint\nparabolaData =\n  [ { x: -10.0, y: 100.0 }\n  , { x: -7.5, y: 56.25 }\n  , { x: -5.0, y: 25.0 }\n  , { x: -2.5, y: 6.25 }\n  , { x: 0.0, y: 0.0 }\n  , { x: 2.5, y: 6.25 }\n  , { x: 5.0, y: 25.0 }\n  , { x: 7.5, y: 56.25 }\n  , { x: 10.0, y: 100.0 }\n  ]\n\n-- =============================================================================\n-- v3 Expressions (Polymorphic!)\n-- =============================================================================\n\n-- | Scale X coordinate: (x + 5) * 30 + 50\n-- |\n-- | This expression is polymorphic over ANY repr that implements the typeclasses.\n-- | It can produce: Number (EvalD), String (CodeGen), String (SVGD)\nscaleX :: forall repr. NumExpr repr => DatumExpr repr ParabolaRow => repr Number\nscaleX = (xField +: 5.0) *: 30.0 +: 50.0\n  where\n    xField = field (Proxy :: Proxy \"x\")\n\n-- | Scale Y coordinate: 200 - (y * 1.8)\nscaleY :: forall repr. NumExpr repr => DatumExpr repr ParabolaRow => repr Number\nscaleY = add (lit 200.0) (yField *: (-1.8))\n  where\n    yField = field (Proxy :: Proxy \"y\")\n\n-- | Point radius based on distance from origin\n-- | Larger radius for points near the vertex\npointRadius :: forall repr. NumExpr repr => DatumExpr repr ParabolaRow => repr Number\npointRadius = add (lit 6.0) (yField *: (-0.05))\n  where\n    yField = field (Proxy :: Proxy \"y\")\n\n-- =============================================================================\n-- v3→v2 Integration: Evaluate expressions with datum\n-- =============================================================================\n\n-- | Evaluate a v3 expression with a datum to get a concrete value\n-- | This bridges v3 polymorphic expressions → v2 static attributes\nevalExpr :: forall a. EvalD ParabolaPoint a -> ParabolaPoint -> a\nevalExpr expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- Browser Demo\n-- =============================================================================\n\nv3ParabolaDemo :: Effect Unit\nv3ParabolaDemo = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define the visualization tree using v3 expressions\n  -- The template callback receives each datum, we evaluate v3 expressions with it\n  let tree :: Tree ParabolaPoint\n      tree =\n        T.named SVG \"svg\"\n          [ evalAttr \"width\" (lit 400.0)\n          , evalAttr \"height\" (lit 250.0)\n          , evalAttrStr \"viewBox\" (str \"0 0 400 250\")\n          , evalAttrStr \"id\" (str \"v3-parabola-svg\")\n          , evalAttrStr \"class\" (str \"v3-demo\")\n          ]\n          `T.withChild`\n            (T.joinData \"points\" \"circle\" parabolaData $ \\d ->\n              -- v3 expressions are evaluated with datum → static v2 attributes\n              T.elem Circle\n                [ evalAttr \"cx\" (lit (evalExpr scaleX d))       -- v3 expression evaluated!\n                , evalAttr \"cy\" (lit (evalExpr scaleY d))       -- v3 expression evaluated!\n                , evalAttr \"r\" (lit (evalExpr pointRadius d))  -- v3 expression evaluated!\n                , evalAttrStr \"fill\" (str \"#3498db\")\n                , evalAttrStr \"stroke\" (str \"white\")\n                , evalAttr \"stroke-width\" (lit 2.0)\n                ])\n\n  -- Render to DOM via D3!\n  selections <- renderTree container tree\n\n  -- Log the \"money shot\" - same expressions, different outputs\n  liftEffect do\n    Console.log \"=== Expression DSL Parabola Demo: Live D3 Rendering ===\"\n    Console.log \"\"\n    Console.log \"v3 Expressions (polymorphic definitions):\"\n    Console.log \"  scaleX = (x + 5) * 30 + 50\"\n    Console.log \"  scaleY = 200 + (y * -1.8)\"\n    Console.log \"\"\n    Console.log \"CodeGen output (PureScript source):\"\n    Console.log $ \"  scaleX → \" <> runCodeGen (scaleX :: CodeGen Number)\n    Console.log $ \"  scaleY → \" <> runCodeGen (scaleY :: CodeGen Number)\n    Console.log \"\"\n    Console.log \"EvalD output (D3 runtime values for sample point):\"\n    let pt = { x: -10.0, y: 100.0 }  -- Sample point\n    let cxVal = runEvalD scaleX pt 0\n    let cyVal = runEvalD scaleY pt 0\n    Console.log $ \"  { x: \" <> show pt.x <> \", y: \" <> show pt.y <> \" } → cx=\" <> show cxVal <> \", cy=\" <> show cyVal\n    Console.log \"\"\n    Console.log \"Same expression, three outputs:\"\n    Console.log \"  • CodeGen: produces PureScript source code\"\n    Console.log \"  • EvalD: produces runtime Number values for D3\"\n    Console.log \"  • SVGD: produces SVG attribute strings (server-side)\"\n    Console.log \"\"\n\n    case Map.lookup \"points\" selections of\n      Just _ -> Console.log \"✓ Points rendered to DOM via D3 (check browser!)\"\n      Nothing -> Console.log \"✗ No points selection found\"\n"

snippet_v3Transition_content :: String
snippet_v3Transition_content = "-- | Expression Transition Demo - Declarative Transitions with v3 Expressions\n-- |\n-- | This demonstrates the fully declarative approach to transitions:\n-- | - sceneJoin defines enter behavior with initial state + transition\n-- | - Template defines final state using v3 expressions\n-- | - No Map lookup, no unsafeCoerce - type flows through the tree\n-- |\n-- | Key insight: Transitions belong IN the tree structure, not after it.\n-- | This keeps the datum type chain intact.\nmodule D3.Viz.TreeAPI.V3TransitionDemo where\n\nimport Prelude hiding (add)\n\nimport Data.Maybe (Maybe(..))\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\n\n-- v2 infrastructure\nimport PSD3.Expr.Integration (evalAttr, evalAttrStr, fnAttr, fnAttrStr)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.Internal.Transition.Types (staggeredTransition)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL\nimport PSD3.Expr.Expr (class NumExpr, lit, str)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((*:), (+:))\nimport PSD3.Expr.Interpreter.CodeGen (CodeGen, runCodeGen)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- =============================================================================\n-- Data Type\n-- =============================================================================\n\ntype CircleData =\n  { id :: Int\n  , x :: Number -- X position\n  , y :: Number -- Y position\n  , value :: Number -- 0 to 100 (affects radius and color)\n  }\n\ntype CircleRow = (id :: Int, x :: Number, y :: Number, value :: Number)\n\n-- Circle data with positions spread out\ncircleData :: Array CircleData\ncircleData =\n  [ { id: 1, x: 80.0, y: 80.0, value: 30.0 }\n  , { id: 2, x: 160.0, y: 220.0, value: 60.0 }\n  , { id: 3, x: 250.0, y: 60.0, value: 90.0 }\n  , { id: 4, x: 340.0, y: 200.0, value: 45.0 }\n  , { id: 5, x: 420.0, y: 100.0, value: 75.0 }\n  ]\n\n-- =============================================================================\n-- v3 Expressions (Polymorphic!)\n-- =============================================================================\n\n-- | X position from datum\nposX :: forall repr. NumExpr repr => DatumExpr repr CircleRow => repr Number\nposX = field (Proxy :: Proxy \"x\")\n\n-- | Y position from datum\nposY :: forall repr. NumExpr repr => DatumExpr repr CircleRow => repr Number\nposY = field (Proxy :: Proxy \"y\")\n\n-- | Radius based on value: (value * 0.2) + 8\n-- | Higher values = larger circles\ncircleRadius :: forall repr. NumExpr repr => DatumExpr repr CircleRow => repr Number\ncircleRadius = valueField *: 0.2 +: 8.0\n  where\n  valueField = field (Proxy :: Proxy \"value\")\n\n-- =============================================================================\n-- v3→v2 Integration\n-- =============================================================================\n\n-- | Evaluate v3 expression with datum (for templates)\nevalExpr :: forall a. EvalD CircleData a -> CircleData -> a\nevalExpr expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- Browser Demo\n-- =============================================================================\n\nv3TransitionDemo :: Effect Unit\nv3TransitionDemo = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Fully declarative tree with transitions INSIDE the structure\n  -- No Map lookup needed - type flows through the entire tree\n  let\n    tree :: Tree CircleData\n    tree =\n      T.named SVG \"svg\"\n        [ evalAttr \"width\" (lit 500.0)\n        , evalAttr \"height\" (lit 300.0)\n        , evalAttrStr \"viewBox\" (str \"0 0 500 300\")\n        , evalAttrStr \"id\" (str \"v3-transition-svg\")\n        , evalAttrStr \"class\" (str \"v3-demo\")\n        ]\n        `T.withChild`\n          -- sceneJoin: template = final state, enterBehavior = initial state + transition\n          ( T.sceneJoin \"circles\" \"circle\" circleData\n              -- Template defines FINAL state (where elements end up)\n              ( \\d -> T.elem Circle\n                  [ evalAttr \"cx\" (lit (evalExpr posX d)) -- v3: final X position\n                  , evalAttr \"cy\" (lit (evalExpr posY d)) -- v3: final Y position\n                  , evalAttr \"r\" (lit (evalExpr circleRadius d)) -- v3: radius from value\n                  , evalAttrStr \"fill\" (str \"#e67e22\") -- final color (orange)\n                  , evalAttrStr \"stroke\" (str \"white\")\n                  , evalAttr \"stroke-width\" (lit 2.0)\n                  ]\n              )\n              -- Behaviors: enter starts at center, transitions to final with stagger\n              { keyFn: Nothing  -- No updates in this demo\n              , enterBehavior: Just\n                  { initialAttrs:\n                      [ evalAttr \"cx\" (lit 250.0) -- start at center X\n                      , evalAttr \"cy\" (lit 150.0) -- start at center Y\n                      , evalAttrStr \"fill\" (str \"#3498db\") -- start color (blue)\n                      ]\n                  , transition: Just (staggeredTransition (Milliseconds 600.0) 100.0)\n                  -- Each element delays 100ms more than previous\n                  }\n              , updateBehavior: Nothing\n              , exitBehavior: Nothing\n              }\n          )\n\n  -- Log what we're demonstrating\n  liftEffect do\n    Console.log \"=== Expression Declarative Staggered Transition Demo ===\"\n    Console.log \"\"\n    Console.log \"v3 Expressions (final positions):\"\n    Console.log $ \"  posX         → \" <> runCodeGen (posX :: CodeGen Number)\n    Console.log $ \"  posY         → \" <> runCodeGen (posY :: CodeGen Number)\n    Console.log $ \"  circleRadius → \" <> runCodeGen (circleRadius :: CodeGen Number)\n    Console.log \"\"\n    Console.log \"Approach: Fully declarative with sceneJoin + staggeredTransition\"\n    Console.log \"  • Template defines final state (v3 expressions)\"\n    Console.log \"  • enterBehavior defines initial state + staggered transition\"\n    Console.log \"  • staggeredTransition: 600ms duration, 100ms stagger per element\"\n    Console.log \"  • No Map lookup, no unsafeCoerce - type flows through tree\"\n    Console.log \"\"\n\n  -- Render - transitions happen automatically!\n  _ <- renderTree container tree\n\n  liftEffect do\n    Console.log \"Staggered transition triggered by renderTree!\"\n    Console.log \"\"\n    Console.log \"Key insights:\"\n    Console.log \"  1. Transitions belong IN the tree structure\"\n    Console.log \"  2. staggerDelay in TransitionConfig handles per-element delays\"\n    Console.log \"  3. The datum type chain stays intact from definition to render\"\n"

snippet_v3GUP_content :: String
snippet_v3GUP_content = "-- | Expression DSL General Update Pattern Demo\n-- |\n-- | The classic D3 \"letters\" example reimagined with:\n-- | - v3 polymorphic expressions for computed attributes\n-- | - sceneJoin with declarative enter/update/exit behaviors\n-- | - Staggered transitions for visual appeal\n-- |\n-- | Data changes trigger the full GUP cycle:\n-- | - ENTER: New letters fade in from above\n-- | - UPDATE: Existing letters slide to new positions\n-- | - EXIT: Removed letters fade out and drop\nmodule D3.Viz.TreeAPI.V3GUPDemo\n  ( v3GUPDemo\n  , updateWithLetters\n  , initV3GUP\n  , LetterDatum\n  ) where\n\nimport Prelude hiding (add)\n\nimport Data.Array as Array\nimport Data.Int (toNumber)\nimport Data.Maybe (Maybe(..))\nimport Data.String.CodeUnits as SCU\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\n\n-- v2 infrastructure\nimport PSD3.Internal.Attribute (Attribute)\nimport PSD3.Expr.Friendly (num, text, attr, from, viewBox, width, height, x, y, fill, opacity, fontSize, textAnchor, dominantBaseline, textContent)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.Internal.Transition.Types (Easing(..), transitionWith)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL\nimport PSD3.Expr.Expr (class NumExpr)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((*:), (+:))\nimport PSD3.Expr.Interpreter.CodeGen (CodeGen, runCodeGen)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- =============================================================================\n-- Data Type\n-- =============================================================================\n\n-- | Each letter has an index (for positioning) and the character\ntype LetterDatum =\n  { letter :: String\n  , index :: Number  -- Number for v3 expression compatibility\n  }\n\ntype LetterRow = (letter :: String, index :: Number)\n\n-- =============================================================================\n-- v3 Expressions (Polymorphic!)\n-- =============================================================================\n\n-- | X position based on index: index * 40 + 50\nletterX :: forall repr. NumExpr repr => DatumExpr repr LetterRow => repr Number\nletterX = indexField *: 40.0 +: 50.0\n  where\n    indexField = field (Proxy :: Proxy \"index\")\n\n-- | Y position (constant for update state)\nletterY :: Number\nletterY = 100.0\n\n-- =============================================================================\n-- v3 -> v2 Integration\n-- =============================================================================\n\n-- | Evaluate v3 expression with datum\nevalExpr :: forall a. EvalD LetterDatum a -> LetterDatum -> a\nevalExpr expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- GUP Tree with Full Enter/Update/Exit\n-- =============================================================================\n\n-- | Create the GUP tree for letters\n-- |\n-- | ENTER: Letters start above (y=20), invisible, then fade in and drop to y=100\n-- | UPDATE: Letters slide horizontally to new positions\n-- | EXIT: Letters fade out and drop below (y=180)\ncreateLettersTree :: Array LetterDatum -> Tree LetterDatum\ncreateLettersTree letters =\n  T.sceneJoin \"letters\" \"text\" letters\n    -- Template: FINAL state for each letter (where they end up after enter/update)\n    (\\d -> T.elem Text\n      [ x $ num (evalExpr letterX d)   -- v3: computed X position\n      , y $ num letterY                -- Final Y position\n      , fontSize $ num 32.0\n      , textAnchor $ text \"middle\"\n      , dominantBaseline $ text \"middle\"\n      , fill $ text \"#2c3e50\"\n      , opacity $ num 1.0\n      -- The text content is set via a special TextContent attribute\n      , textContent $ text d.letter\n      ])\n    -- Behaviors for enter/update/exit\n    { keyFn: Just _.letter       -- Identity by letter, not by index!\n    , enterBehavior: Just\n        { initialAttrs:\n            [ y $ num 20.0              -- Start above\n            , opacity $ num 0.0         -- Start invisible\n            , fill $ text \"#27ae60\"      -- Green for entering\n            ]\n        , transition: Just $ transitionWith\n            { duration: Milliseconds 750.0\n            , delay: Nothing\n            , staggerDelay: Just 50.0  -- Stagger enter\n            , easing: Just BounceOut   -- Bouncy entrance!\n            }\n        }\n    , updateBehavior: Just\n        { attrs:\n            -- Update attributes (slide to new position)\n            [ from \"x\" (\\d' -> evalExpr letterX d')\n            , y $ num letterY\n            , fill $ text \"#2c3e50\"  -- Dark for stable\n            , opacity $ num 1.0\n            ]\n        , transition: Just $ transitionWith\n            { duration: Milliseconds 500.0\n            , delay: Nothing\n            , staggerDelay: Just 30.0  -- Stagger update\n            , easing: Just CubicInOut\n            }\n        }\n    , exitBehavior: Just\n        { attrs:\n            [ y $ num 180.0             -- Drop below\n            , opacity $ num 0.0         -- Fade out\n            , fill $ text \"#e74c3c\"      -- Red for exiting\n            ]\n        , transition: Just $ transitionWith\n            { duration: Milliseconds 500.0\n            , delay: Nothing\n            , staggerDelay: Just 40.0  -- Stagger exit\n            , easing: Just CubicIn\n            }\n        }\n    }\n\n-- =============================================================================\n-- Public API\n-- =============================================================================\n\n-- | Initialize the GUP demo - creates SVG container and renders initial letters\nv3GUPDemo :: Effect Unit\nv3GUPDemo = do\n  Console.log \"=== Expression DSL General Update Pattern Demo ===\"\n  Console.log \"\"\n  Console.log \"v3 Expression for X position:\"\n  Console.log $ \"  letterX = \" <> runCodeGen (letterX :: CodeGen Number)\n  Console.log \"\"\n  Console.log \"Starting with: A B C D E F G\"\n  Console.log \"\"\n\n  -- Create the SVG container first\n  runD3v2M do\n    container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n    let svgTree :: Tree Unit\n        svgTree =\n          T.named SVG \"svg\"\n            [ width $ num 600.0\n            , height $ num 200.0\n            , viewBox 0.0 0.0 600.0 200.0\n            , attr \"id\" $ text \"v3-gup-svg\"\n            , attr \"class\" $ text \"v3-gup-demo\"\n            ]\n            `T.withChild`\n              T.elem Group []  -- Empty group placeholder\n    _ <- renderTree container svgTree\n    pure unit\n\n  -- Initial render with ABCDEFG\n  updateWithLetters \"ABCDEFG\"\n\n-- | Update the visualization with a new set of letters\n-- |\n-- | This triggers the full GUP cycle:\n-- | - Letters not in old set: ENTER (fade in from above)\n-- | - Letters in both sets: UPDATE (slide to new position)\n-- | - Letters not in new set: EXIT (fade out and drop)\nupdateWithLetters :: String -> Effect Unit\nupdateWithLetters letterString = runD3v2M do\n  -- Select into the existing SVG (not #viz)\n  svg <- select \"#v3-gup-svg\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Convert string to array of LetterDatum with indices\n  let letters = Array.mapWithIndex\n        (\\i c -> { letter: SCU.singleton c, index: toNumber i })\n        (SCU.toCharArray letterString)\n\n  liftEffect $ Console.log $ \"Updating to: \" <> letterString <> \" (\" <> show (Array.length letters) <> \" letters)\"\n\n  -- Just the letters tree - renders INTO the existing SVG\n  let tree :: Tree LetterDatum\n      tree = createLettersTree letters\n\n  -- Render - sceneJoin handles enter/update/exit automatically!\n  _ <- renderTree svg tree\n\n  liftEffect do\n    Console.log \"GUP cycle complete!\"\n    Console.log \"  - New letters entered (green, bounced in from above)\"\n    Console.log \"  - Existing letters updated (slid to new positions)\"\n    Console.log \"  - Removed letters exited (red, faded and dropped)\"\n\n-- | Initialize the V3 GUP demo in a given container\n-- | Returns an update function that accepts an array of characters\n-- | Compatible with the GUPv2 API for drop-in replacement\ninitV3GUP :: String -> Effect (Array Char -> Effect Unit)\ninitV3GUP containerSelector = do\n  -- Create unique SVG ID based on selector\n  let svgId = \"v3-gup-svg-\" <> filterAlphaNum containerSelector\n      svgSelector = \"#\" <> svgId\n\n  -- Create the SVG container\n  runD3v2M do\n    container <- select containerSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n    let svgTree :: Tree Unit\n        svgTree =\n          T.named SVG \"svg\"\n            [ width $ num 800.0\n            , height $ num 500.0\n            , viewBox 0.0 (-50.0) 800.0 500.0\n            , attr \"id\" $ text svgId\n            , attr \"class\" $ text \"v3-gup-demo d3svg gup\"\n            ]\n            `T.withChild`\n              T.elem Group []  -- Empty group placeholder\n    _ <- renderTree container svgTree\n    pure unit\n\n  -- Return update function\n  pure \\letters -> runD3v2M do\n    svg <- select svgSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n    -- Convert Char array to LetterDatum array with indices\n    let letterData = Array.mapWithIndex\n          (\\i c -> { letter: SCU.singleton c, index: toNumber i })\n          letters\n\n    -- Render the letters tree\n    let tree :: Tree LetterDatum\n        tree = createLettersTree letterData\n\n    _ <- renderTree svg tree\n    pure unit\n\n-- | Filter string to alphanumeric characters only (for ID generation)\nfilterAlphaNum :: String -> String\nfilterAlphaNum s = SCU.fromCharArray $ Array.filter isAlphaNum (SCU.toCharArray s)\n  where\n    isAlphaNum c =\n      (c >= 'a' && c <= 'z') ||\n      (c >= 'A' && c <= 'Z') ||\n      (c >= '0' && c <= '9')\n"

-- | Look up a snippet by name
getSnippet :: String -> String
getSnippet name = case name of
  "threeLittleCircles" -> snippet_threeLittleCircles_content
  "threeLittleCirclesTransition" -> snippet_threeLittleCirclesTransition_content
  "simpleTree" -> snippet_simpleTree_content
  "nestedElements" -> snippet_nestedElements_content
  "threeLittleDimensions" -> snippet_threeLittleDimensions_content
  "barChart" -> snippet_barChart_content
  "scatterPlot" -> snippet_scatterPlot_content
  "lineChart" -> snippet_lineChart_content
  "groupedBarChart" -> snippet_groupedBarChart_content
  "multiLineChart" -> snippet_multiLineChart_content
  "radialStackedBar" -> snippet_radialStackedBar_content
  "anscombesQuartet" -> snippet_anscombesQuartet_content
  "wealthHealth" -> snippet_wealthHealth_content
  "splom" -> snippet_splom_content
  "treeViz" -> snippet_treeViz_content
  "radialTree" -> snippet_radialTree_content
  "horizontalTree" -> snippet_horizontalTree_content
  "cluster" -> snippet_cluster_content
  "treemap" -> snippet_treemap_content
  "sunburst" -> snippet_sunburst_content
  "pack" -> snippet_pack_content
  "partition" -> snippet_partition_content
  "animatedTreeCluster" -> snippet_animatedTreeCluster_content
  "sankey" -> snippet_sankey_content
  "chord" -> snippet_chord_content
  "edgeBundle" -> snippet_edgeBundle_content
  "simpleForce" -> snippet_simpleForce_content
  "lesMis" -> snippet_lesMis_content
  "v3Parabola" -> snippet_v3Parabola_content
  "v3Transition" -> snippet_v3Transition_content
  "v3GUP" -> snippet_v3GUP_content
  _ -> "Snippet not found: " <> name

-- | Get snippet info by name
getSnippetInfo :: String -> SnippetInfo
getSnippetInfo name = case name of
  "threeLittleCircles" ->
    { name: "threeLittleCircles"
    , content: snippet_threeLittleCircles_content
    , source: "demo-website/src/Viz/TreeAPI/ThreeLittleCircles.purs"
    , lines: "1-88"
    }
  "threeLittleCirclesTransition" ->
    { name: "threeLittleCirclesTransition"
    , content: snippet_threeLittleCirclesTransition_content
    , source: "demo-website/src/Viz/TreeAPI/ThreeLittleCirclesTransition.purs"
    , lines: "1-163"
    }
  "simpleTree" ->
    { name: "simpleTree"
    , content: snippet_simpleTree_content
    , source: "demo-website/src/Viz/TreeAPI/SimpleTreeExample.purs"
    , lines: "1-66"
    }
  "nestedElements" ->
    { name: "nestedElements"
    , content: snippet_nestedElements_content
    , source: "demo-website/src/Viz/TreeAPI/NestedElementsExample.purs"
    , lines: "1-150"
    }
  "threeLittleDimensions" ->
    { name: "threeLittleDimensions"
    , content: snippet_threeLittleDimensions_content
    , source: "demo-website/src/Viz/TreeAPI/ThreeLittleDimensionsExample.purs"
    , lines: "1-80"
    }
  "barChart" ->
    { name: "barChart"
    , content: snippet_barChart_content
    , source: "demo-website/src/Viz/TreeAPI/BarChartExample.purs"
    , lines: "1-192"
    }
  "scatterPlot" ->
    { name: "scatterPlot"
    , content: snippet_scatterPlot_content
    , source: "demo-website/src/Viz/TreeAPI/ScatterPlotExample.purs"
    , lines: "1-134"
    }
  "lineChart" ->
    { name: "lineChart"
    , content: snippet_lineChart_content
    , source: "demo-website/src/Viz/TreeAPI/LineChartExample.purs"
    , lines: "1-142"
    }
  "groupedBarChart" ->
    { name: "groupedBarChart"
    , content: snippet_groupedBarChart_content
    , source: "demo-website/src/Viz/TreeAPI/GroupedBarChartExample.purs"
    , lines: "1-267"
    }
  "multiLineChart" ->
    { name: "multiLineChart"
    , content: snippet_multiLineChart_content
    , source: "demo-website/src/Viz/TreeAPI/MultiLineChartExample.purs"
    , lines: "1-264"
    }
  "radialStackedBar" ->
    { name: "radialStackedBar"
    , content: snippet_radialStackedBar_content
    , source: "demo-website/src/Viz/TreeAPI/RadialStackedBarExample.purs"
    , lines: "1-420"
    }
  "anscombesQuartet" ->
    { name: "anscombesQuartet"
    , content: snippet_anscombesQuartet_content
    , source: "demo-website/src/Viz/TreeAPI/AnscombesQuartet.purs"
    , lines: "1-271"
    }
  "wealthHealth" ->
    { name: "wealthHealth"
    , content: snippet_wealthHealth_content
    , source: "demo-website/src/Viz/TreeAPI/WealthHealthDraw.purs"
    , lines: "1-308"
    }
  "splom" ->
    { name: "splom"
    , content: snippet_splom_content
    , source: "demo-website/src/Viz/SPLOM/SPLOM.purs"
    , lines: "1-640"
    }
  "treeViz" ->
    { name: "treeViz"
    , content: snippet_treeViz_content
    , source: "demo-website/src/Viz/TreeAPI/TreeViz.purs"
    , lines: "1-178"
    }
  "radialTree" ->
    { name: "radialTree"
    , content: snippet_radialTree_content
    , source: "demo-website/src/Viz/TreeAPI/RadialTreeViz.purs"
    , lines: "1-195"
    }
  "horizontalTree" ->
    { name: "horizontalTree"
    , content: snippet_horizontalTree_content
    , source: "demo-website/src/Viz/TreeAPI/HorizontalTreeViz.purs"
    , lines: "1-192"
    }
  "cluster" ->
    { name: "cluster"
    , content: snippet_cluster_content
    , source: "demo-website/src/Viz/TreeAPI/ClusterViz.purs"
    , lines: "1-182"
    }
  "treemap" ->
    { name: "treemap"
    , content: snippet_treemap_content
    , source: "demo-website/src/Viz/TreeAPI/TreemapViz.purs"
    , lines: "1-124"
    }
  "sunburst" ->
    { name: "sunburst"
    , content: snippet_sunburst_content
    , source: "demo-website/src/Viz/TreeAPI/SunburstViz.purs"
    , lines: "1-175"
    }
  "pack" ->
    { name: "pack"
    , content: snippet_pack_content
    , source: "demo-website/src/Viz/TreeAPI/PackViz.purs"
    , lines: "1-145"
    }
  "partition" ->
    { name: "partition"
    , content: snippet_partition_content
    , source: "demo-website/src/Viz/TreeAPI/PartitionViz.purs"
    , lines: "1-128"
    }
  "animatedTreeCluster" ->
    { name: "animatedTreeCluster"
    , content: snippet_animatedTreeCluster_content
    , source: "demo-website/src/Viz/TreeAPI/AnimatedTreeCluster.purs"
    , lines: "1-352"
    }
  "sankey" ->
    { name: "sankey"
    , content: snippet_sankey_content
    , source: "demo-website/src/Viz/TreeAPI/SankeyDiagram.purs"
    , lines: "1-313"
    }
  "chord" ->
    { name: "chord"
    , content: snippet_chord_content
    , source: "demo-website/src/Viz/TreeAPI/ChordDiagram.purs"
    , lines: "1-366"
    }
  "edgeBundle" ->
    { name: "edgeBundle"
    , content: snippet_edgeBundle_content
    , source: "demo-website/src/Viz/TreeAPI/EdgeBundleViz.purs"
    , lines: "1-183"
    }
  "simpleForce" ->
    { name: "simpleForce"
    , content: snippet_simpleForce_content
    , source: "demo-website/src/Viz/SimpleForceGraph.purs"
    , lines: "1-155"
    }
  "lesMis" ->
    { name: "lesMis"
    , content: snippet_lesMis_content
    , source: "demo-website/src/Viz/LesMisV3/Draw.purs"
    , lines: "1-170"
    }
  "v3Parabola" ->
    { name: "v3Parabola"
    , content: snippet_v3Parabola_content
    , source: "demo-website/src/Viz/TreeAPI/V3ParabolaDemo.purs"
    , lines: "1-156"
    }
  "v3Transition" ->
    { name: "v3Transition"
    , content: snippet_v3Transition_content
    , source: "demo-website/src/Viz/TreeAPI/V3TransitionDemo.purs"
    , lines: "1-163"
    }
  "v3GUP" ->
    { name: "v3GUP"
    , content: snippet_v3GUP_content
    , source: "demo-website/src/Viz/TreeAPI/V3GUPDemo.purs"
    , lines: "1-268"
    }
  _ ->
    { name: "not-found"
    , content: "Snippet not found: " <> name
    , source: ""
    , lines: "1-1"
    }
