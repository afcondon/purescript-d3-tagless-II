-- | Auto-generated module containing code snippets
-- | Generated by scripts/generate-code-snippets.js
-- | DO NOT EDIT THIS FILE MANUALLY
module CodeSnippets where

import Prelude

-- | Snippet metadata
type SnippetInfo =
  { name :: String
  , content :: String
  , source :: String
  , lines :: String
  }

-- ** Snippet Content Constants **

snippet_threeLittleCircles_content :: String
snippet_threeLittleCircles_content = "module D3.Viz.TreeAPI.ThreeLittleCircles where\n\nimport Prelude\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, fill)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree, joinData)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Three Little Circles - The classic D3 example using declarative tree API\n-- |\n-- | This demonstrates:\n-- | - Data joins with the declarative API\n-- | - Template functions that customize each element based on datum\n-- | - Polymorphic attributes (functions of datum)\n\ntype CircleData =\n  { x :: Number\n  , y :: Number\n  , r :: Number\n  , color :: String\n  }\n\ncircleData :: Array CircleData\ncircleData =\n  [ { x: 100.0, y: 100.0, r: 40.0, color: \"red\" }\n  , { x: 200.0, y: 100.0, r: 30.0, color: \"green\" }\n  , { x: 300.0, y: 100.0, r: 50.0, color: \"blue\" }\n  ]\n\nthreeLittleCircles :: Effect Unit\nthreeLittleCircles = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define the tree with a DATA JOIN\n  -- Note: The datum type is CircleData because we're using joinData with CircleData\n  let tree :: Tree CircleData\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num 400.0\n          , height $ num 200.0\n          , viewBox 0.0 0.0 400.0 200.0\n          , attr \"id\" $ text \"three-circles-svg\"\n          , attr \"class\" $ text \"tree-api-example\"\n          ]\n          `T.withChild`\n            -- Here's the magic: joinData creates N copies of the template\n            (joinData \"circles\" \"circle\" circleData $ \\d ->\n              T.elem Circle\n                [ cx $ num d.x\n                , cy $ num d.y\n                , r $ num d.r\n                , fill $ text d.color\n                ])\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Three Little Circles (Declarative API) ===\"\n    Console.log \"\"\n    Console.log \"Structure: SVG → [Circle × 3] (via joinData)\"\n    Console.log \"\"\n\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"circles\" selections of\n      Just _ -> Console.log \"✓ Circles collection created (3 circles via data join)\"\n      Nothing -> Console.log \"✗ Missing circles collection\"\n\n    Console.log \"\"\n    Console.log \"Expected result:\"\n    Console.log \"  - Red circle (r=40) at (100, 100)\"\n    Console.log \"  - Green circle (r=30) at (200, 100)\"\n    Console.log \"  - Blue circle (r=50) at (300, 100)\"\n    Console.log \"\"\n    Console.log \"Check the browser to verify!\"\n"

snippet_threeLittleCirclesTransition_content :: String
snippet_threeLittleCirclesTransition_content = "module D3.Viz.TreeAPI.ThreeLittleCirclesTransition where\n\n-- | Three Little Circles with Transitions using Tree API\n-- |\n-- | Demonstrates:\n-- | - Initial render with Tree API\n-- | - Re-rendering with updated data\n-- | - Transitions between states\n-- | - Click handlers with onClick behavior\n-- |\n-- | Based on Mike Bostock's \"Three Little Circles\" (https://bost.ocks.org/mike/circles/)\n\nimport Prelude\n\nimport Data.Int (toNumber)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Console (log)\nimport Effect.Ref as Ref\nimport PSD3.Expr.Friendly (num, text, attr, from, fromStr, viewBox, width, height, cx, cy, r, fill, opacity)\nimport PSD3.Internal.Capabilities.Selection (renderTree, select)\nimport PSD3.Internal.Capabilities.Transition (withTransition)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SBoundOwns, SEmpty)\nimport PSD3.Internal.Transition.Types (transitionWith)\nimport PSD3.AST as T\nimport Partial.Unsafe (unsafePartial, unsafeCrashWith)\nimport Web.DOM.Element (Element)\n\n-- | Circle data type\ntype CircleData = Int\n\n-- | State of the circles visualization\ndata CircleState = StateGreen | StateRGB\n\nderive instance Eq CircleState\n\ninstance Show CircleState where\n  show StateGreen = \"StateGreen\"\n  show StateRGB = \"StateRGB\"\n\n-- | Toggle between states\ntoggleState :: CircleState -> CircleState\ntoggleState StateGreen = StateRGB\ntoggleState StateRGB = StateRGB -- Stay in RGB state once shown\n\n-- | Transition circles to a given state\ntransitionToState :: D3v2Selection_ SBoundOwns Element CircleData -> CircleState -> Effect Unit\ntransitionToState circlesSel state = runD3v2M do\n  let\n    transitionConfig = transitionWith\n      { duration: Milliseconds 1000.0\n      , delay: Nothing\n      , staggerDelay: Nothing\n      , easing: Nothing\n      }\n\n  case state of\n    StateGreen ->\n      -- Three green circles in a row\n      withTransition transitionConfig circlesSel\n        [ fromStr \"fill\" colorFnGreen\n        , from \"cx\" cxFnGreen\n        , from \"cy\" cyFnGreen\n        , r $ num 40.0\n        , attr \"fill-opacity\" $ num 1.0 -- Fully opaque\n        ]\n    StateRGB ->\n      withTransition transitionConfig circlesSel\n        [ fromStr \"fill\" colorFnRGB\n        , from \"cx\" cxFnRGB\n        , from \"cy\" cyFnRGB\n        , r $ num 60.0 -- Increased from 30 to 60 for proper overlap and color mixing\n        , attr \"fill-opacity\" $ num 0.5 -- Semi-transparent for color mixing\n        ]\n\n  pure unit\n  where\n  -- Green state: all circles green\n  colorFnGreen :: CircleData -> String\n  colorFnGreen _ = \"#00ff00\"\n\n  cxFnGreen :: CircleData -> Number\n  cxFnGreen d = 100.0 + toNumber d * 100.0 -- Spaced 100px apart\n\n  cyFnGreen :: CircleData -> Number\n  cyFnGreen _ = 125.0 -- All at same height\n\n  -- RGB colors: Red, Green, Blue\n  colorFnRGB :: CircleData -> String\n  colorFnRGB d = case d of\n    0 -> \"#ff0000\" -- Red\n    1 -> \"#00ff00\" -- Green\n    _ -> \"#0000ff\" -- Blue\n\n  -- RGB X positions: form triangle with overlap\n  cxFnRGB :: CircleData -> Number\n  cxFnRGB d = case d of\n    0 -> 150.0 -- Red on left\n    1 -> 250.0 -- Green on right\n    _ -> 200.0 -- Blue in center\n\n  -- RGB Y positions: red/green at bottom, blue at top\n  cyFnRGB :: CircleData -> Number\n  cyFnRGB d = case d of\n    0 -> 130.0 -- Red at bottom\n    1 -> 130.0 -- Green at bottom\n    _ -> 70.0 -- Blue at top\n\n-- | Draw three circles with visible initial state\nthreeLittleCirclesTransition :: String -> Effect { stateRef :: Ref.Ref CircleState, circlesSel :: D3v2Selection_ SBoundOwns Element CircleData }\nthreeLittleCirclesTransition selector = do\n  -- Create state ref - start with green circles\n  stateRef <- Ref.new StateGreen\n\n  runD3v2M do\n    container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n    -- Initial tree: three green circles in a row\n    let\n      initialTree :: T.Tree CircleData\n      initialTree =\n        T.named SVG \"svg\"\n          [ width $ num 400.0\n          , height $ num 250.0\n          , viewBox 0.0 0.0 400.0 250.0\n          , attr \"id\" $ text \"three-circles-transition-tree\"\n          ]\n          `T.withChild`\n            ( T.joinData \"circles\" \"circle\" [ 0, 1, 2 ] $ \\d ->\n                T.elem Circle\n                  [ fill $ text \"#00ff00\" -- Start green\n                  , cx $ num (100.0 + toNumber d * 100.0) -- Three in a row\n                  , cy $ num 125.0\n                  , r $ num 40.0\n                  , attr \"fill-opacity\" $ num 1.0\n                  ]\n            )\n\n    -- Render initial state\n    selections <- renderTree container initialTree\n\n    -- Extract the circles selection for transitions\n    let\n      circlesSel = case Map.lookup \"circles\" selections of\n        Just sel -> sel\n        Nothing -> unsafePartial $ unsafeCrashWith \"circles selection not found\"\n\n    -- Return the state ref and selection so external button can trigger transition\n    pure { stateRef, circlesSel }\n\n-- | Helper to create transition function for a button\n-- | Call this after threeLittleCirclesTransition to get a function to attach to a button\ncreateTransitionTrigger :: { stateRef :: Ref.Ref CircleState, circlesSel :: D3v2Selection_ SBoundOwns Element CircleData } -> Effect Unit\ncreateTransitionTrigger { stateRef, circlesSel } = do\n  currentState <- Ref.read stateRef\n  let newState = toggleState currentState\n  Ref.write newState stateRef\n  log $ \"Transitioning to: \" <> show newState\n  transitionToState circlesSel newState\n"

snippet_simpleTree_content :: String
snippet_simpleTree_content = "module D3.Viz.TreeAPI.SimpleTreeExample where\n\nimport Prelude\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, textAnchor, textContent)\nimport Web.DOM.Element (Element)\n\n-- | Simple test: Render a basic tree structure without data joins\n-- |\n-- | Structure:\n-- | ```\n-- | div#viz\n-- |   └─ svg (800x600)\n-- |      └─ g.container\n-- |         ├─ circle (at 100, 100)\n-- |         └─ text (at 100, 130)\n-- | ```\ntestSimpleTree :: Effect Unit\ntestSimpleTree = runD3v2M do\n  -- Select the container\n  container <- select \"#viz\" :: _  (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define the tree structure using the declarative API\n  let tree :: Tree Unit\n      tree =\n        T.named SVG \"svg\" [width $ num 800.0, height $ num 600.0, viewBox 0.0 0.0 800.0 600.0, attr \"id\" $ text \"simple-tree-svg\"]\n          `T.withChild`\n            (T.named Group \"container\" [attr \"class\" $ text \"container\"]\n              `T.withChildren`\n                [ T.named Circle \"circle\" [cx $ num 100.0, cy $ num 100.0, r $ num 20.0, fill $ text \"steelblue\"]\n                , T.named Text \"text\" [x $ num 100.0, y $ num 130.0, textContent $ text \"Hello Tree API!\", textAnchor $ text \"middle\"]\n                ])\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  -- Log what we got back\n  liftEffect do\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ Found svg selection\"\n      Nothing -> Console.log \"✗ Missing svg selection\"\n\n    case Map.lookup \"container\" selections of\n      Just _ -> Console.log \"✓ Found container selection\"\n      Nothing -> Console.log \"✗ Missing container selection\"\n\n    case Map.lookup \"circle\" selections of\n      Just _ -> Console.log \"✓ Found circle selection\"\n      Nothing -> Console.log \"✗ Missing circle selection\"\n\n    case Map.lookup \"text\" selections of\n      Just _ -> Console.log \"✓ Found text selection\"\n      Nothing -> Console.log \"✗ Missing text selection\"\n\n    Console.log \"Simple tree rendering complete!\"\n"

snippet_nestedElements_content :: String
snippet_nestedElements_content = "module D3.Viz.TreeAPI.NestedElementsExample where\n\nimport Prelude\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, fontSize, textAnchor, textContent, transform)\nimport Web.DOM.Element (Element)\n\n-- | Test: Multi-level nested elements (Group → Circle + Text)\n-- |\n-- | This is the key pattern for visualizations - a container group with\n-- | multiple child elements (shape + label).\n-- |\n-- | This validates that withChildren works correctly and that we can\n-- | create the nested structures that were blocking code-explorer.\ntestNestedElements :: Effect Unit\ntestNestedElements = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define a tree with MULTI-LEVEL NESTING\n  -- This is the pattern: Group → (Circle + Text)\n  let tree :: Tree Unit\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num 600.0\n          , height $ num 400.0\n          , viewBox 0.0 0.0 600.0 400.0\n          , attr \"id\" $ text \"nested-example-svg\"\n          ]\n          `T.withChild`\n            (T.named Group \"mainGroup\" [attr \"class\" $ text \"main-group\"]\n              `T.withChildren`\n                -- Multiple node groups, each with Circle + Text\n                [ -- Node 1\n                  T.named Group \"node1\"\n                    [ attr \"class\" $ text \"node\"\n                    , transform $ text \"translate(100, 100)\"\n                    ]\n                    `T.withChildren`\n                      [ T.named Circle \"node1Circle\"\n                          [ cx $ num 0.0, cy $ num 0.0\n                          , r $ num 25.0\n                          , fill $ text \"steelblue\"\n                          , stroke $ text \"white\"\n                          , strokeWidth $ num 2.0\n                          ]\n                      , T.named Text \"node1Label\"\n                          [ x $ num 0.0, y $ num 40.0\n                          , textContent $ text \"Node A\"\n                          , textAnchor $ text \"middle\"\n                          , fontSize $ num 14.0\n                          ]\n                      ]\n\n                , -- Node 2\n                  T.named Group \"node2\"\n                    [ attr \"class\" $ text \"node\"\n                    , transform $ text \"translate(300, 150)\"\n                    ]\n                    `T.withChildren`\n                      [ T.named Circle \"node2Circle\"\n                          [ cx $ num 0.0, cy $ num 0.0\n                          , r $ num 20.0\n                          , fill $ text \"orange\"\n                          , stroke $ text \"white\"\n                          , strokeWidth $ num 2.0\n                          ]\n                      , T.named Text \"node2Label\"\n                          [ x $ num 0.0, y $ num 35.0\n                          , textContent $ text \"Node B\"\n                          , textAnchor $ text \"middle\"\n                          , fontSize $ num 14.0\n                          ]\n                      ]\n\n                , -- Node 3\n                  T.named Group \"node3\"\n                    [ attr \"class\" $ text \"node\"\n                    , transform $ text \"translate(500, 100)\"\n                    ]\n                    `T.withChildren`\n                      [ T.named Circle \"node3Circle\"\n                          [ cx $ num 0.0, cy $ num 0.0\n                          , r $ num 30.0\n                          , fill $ text \"green\"\n                          , stroke $ text \"white\"\n                          , strokeWidth $ num 2.0\n                          ]\n                      , T.named Text \"node3Label\"\n                          [ x $ num 0.0, y $ num 45.0\n                          , textContent $ text \"Node C\"\n                          , textAnchor $ text \"middle\"\n                          , fontSize $ num 14.0\n                          ]\n                      ]\n                ])\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Nested Elements Test ===\"\n    Console.log \"\"\n    Console.log \"Structure: SVG → Group → (Node1, Node2, Node3)\"\n    Console.log \"           Each Node → (Circle + Text)\"\n    Console.log \"\"\n\n    -- Verify all selections\n    let checkSelection name = case Map.lookup name selections of\n          Just _ -> Console.log $ \"✓ \" <> name\n          Nothing -> Console.log $ \"✗ Missing: \" <> name\n\n    Console.log \"Top-level:\"\n    checkSelection \"svg\"\n    checkSelection \"mainGroup\"\n\n    Console.log \"\\nNode 1 (steelblue at 100, 100):\"\n    checkSelection \"node1\"\n    checkSelection \"node1Circle\"\n    checkSelection \"node1Label\"\n\n    Console.log \"\\nNode 2 (orange at 300, 150):\"\n    checkSelection \"node2\"\n    checkSelection \"node2Circle\"\n    checkSelection \"node2Label\"\n\n    Console.log \"\\nNode 3 (green at 500, 100):\"\n    checkSelection \"node3\"\n    checkSelection \"node3Circle\"\n    checkSelection \"node3Label\"\n\n    Console.log $ \"\\n\" <> show (Map.size selections) <> \" total selections in map\"\n\n    Console.log \"\\n=== SUCCESS CRITERIA ===\"\n    Console.log \"✓ Multi-level nesting works (Group → Circle + Text)\"\n    Console.log \"✓ withChildren handles arrays of subtrees\"\n    Console.log \"✓ All named nodes are accessible via Map\"\n    Console.log \"\"\n    Console.log \"NEXT: Need data joins to generate this structure from Array data\"\n    Console.log \"      instead of manually creating each node.\"\n"

snippet_barChart_content :: String
snippet_barChart_content = "module D3.Viz.TreeAPI.BarChartExample where\n\nimport Prelude\n\nimport Data.Array (length)\nimport Data.Foldable (maximum)\nimport Data.Int as Int\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, x, y, fill, stroke, strokeWidth, transform)\nimport PSD3.Axis.Axis (axisBottom, axisLeft, renderAxis, Scale)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Simple data point\ntype DataPoint = { x :: Number, y :: Number }\n\n-- | Sample data\nsampleData :: Array DataPoint\nsampleData =\n  [ { x: 1.0, y: 30.0 }\n  , { x: 2.0, y: 80.0 }\n  , { x: 3.0, y: 45.0 }\n  , { x: 4.0, y: 60.0 }\n  , { x: 5.0, y: 20.0 }\n  , { x: 6.0, y: 90.0 }\n  , { x: 7.0, y: 55.0 }\n  ]\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 600.0\n  , height: 400.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 40.0\n  , marginLeft: 50.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Bar chart using declarative tree API\nbarChart :: Effect Unit\nbarChart = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n  let iWidth = innerWidth dims\n  let iHeight = innerHeight dims\n\n  -- Calculate data extents\n  let yValues = map _.y sampleData\n  let minY = 0.0 -- Start bars from zero\n  let maxY = fromMaybe 100.0 $ maximum yValues\n\n  -- Calculate bar width (80% of available space per bar)\n  let numBars = length sampleData\n  let barWidth = if numBars > 0 then (iWidth / (Int.toNumber numBars)) * 0.8 else 0.0\n\n  -- KEY: Create scales to map data values → pixel positions\n  -- Scales are the bridge between data space and visual space\n  let\n    xScale :: Scale\n    xScale =\n      { domain: { min: 1.0, max: Int.toNumber numBars } -- Data range\n      , range: { min: 0.0, max: iWidth } -- Pixel range\n      }\n\n  let\n    yScale :: Scale\n    yScale =\n      { domain: { min: minY, max: maxY } -- Data range (0 to max value)\n      , range: { min: iHeight, max: 0.0 } -- Pixel range (inverted for SVG coords)\n      }\n\n  -- Create axes\n  let xAxis = axisBottom xScale\n  let yAxis = axisLeft yScale\n\n  -- First, render the SVG container with axes (datum type: Unit)\n  let\n    axesTree :: Tree Unit\n    axesTree =\n      T.named SVG \"svg\"\n        [ width $ num dims.width\n        , height $ num dims.height\n        , viewBox 0.0 0.0 dims.width dims.height\n        , attr \"class\" $ text \"bar-chart-tree\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"chart-content\"\n              , transform $ text (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\")\n              ]\n              `T.withChildren`\n                [ -- X axis\n                  T.named Group \"xAxis\"\n                    [ transform $ text (\"translate(0,\" <> show iHeight <> \")\")\n                    , attr \"class\" $ text \"x-axis\"\n                    ]\n                    `T.withChild`\n                      renderAxis xAxis\n                , -- Y axis\n                  T.named Group \"yAxis\"\n                    [ attr \"class\" $ text \"y-axis\"\n                    ]\n                    `T.withChild`\n                      renderAxis yAxis\n                ]\n          )\n\n  -- Render axes first (underlaying)\n  axesSelections <- renderTree container axesTree\n\n  -- KEY: Reselect the chartGroup for layered rendering\n  -- This allows us to render bars on top of axes\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" axesSelections\n\n  -- KEY: Data join creates one rect per data point\n  let\n    barsTree :: Tree DataPoint\n    barsTree =\n      T.joinData \"bars\" \"rect\" sampleData $ \\point ->\n        -- Calculate bar position and dimensions from data\n        let\n          xPos = (point.x - 1.0) * (iWidth / (Int.toNumber numBars)) + ((iWidth / (Int.toNumber numBars)) - barWidth) / 2.0\n          yPos = iHeight - ((point.y - minY) / (maxY - minY) * iHeight) -- Manual scale calculation\n          barHeight = iHeight - yPos -- Bar grows from baseline\n        in\n          T.elem Rect\n            [ x $ num xPos -- Horizontal position\n            , y $ num yPos -- Top of bar (SVG coords from top-left)\n            , width $ num barWidth -- Bar width\n            , height $ num barHeight -- Bar height (grows downward in SVG)\n            , fill $ text \"#4a90e2\"\n            , stroke $ text \"#357abd\"\n            , strokeWidth $ num 1.0\n            , attr \"class\" $ text \"bar\"\n            ]\n\n  -- Render bars into the chart group (overlaying)\n  barsSelections <- renderTree chartGroupSel barsTree\n\n  liftEffect do\n    Console.log \"=== Bar Chart (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (length sampleData) <> \" bars with axes\"\n\n    case Map.lookup \"svg\" axesSelections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"chartGroup\" axesSelections of\n      Just _ -> Console.log \"✓ Chart group created\"\n      Nothing -> Console.log \"✗ Missing chart group\"\n\n    case Map.lookup \"xAxis\" axesSelections of\n      Just _ -> Console.log \"✓ X axis created\"\n      Nothing -> Console.log \"✗ Missing X axis\"\n\n    case Map.lookup \"yAxis\" axesSelections of\n      Just _ -> Console.log \"✓ Y axis created\"\n      Nothing -> Console.log \"✗ Missing Y axis\"\n\n    case Map.lookup \"bars\" barsSelections of\n      Just _ -> Console.log \"✓ Bars collection created\"\n      Nothing -> Console.log \"✗ Missing bars collection\"\n\n    Console.log \"\"\n    Console.log \"Expected: 7 blue bars of varying heights with X and Y axes\"\n"

snippet_scatterPlot_content :: String
snippet_scatterPlot_content = "module D3.Viz.TreeAPI.ScatterPlotExample where\n\nimport Prelude\n\nimport Data.Array (length)\nimport Data.Foldable (maximum, minimum)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, fill, opacity, transform)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree, joinData)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Data point with x, y coordinates\ntype Point = { x :: Number, y :: Number }\n\n-- | Sample scatter plot data\nscatterData :: Array Point\nscatterData =\n  [ { x: 10.0, y: 20.0 }\n  , { x: 25.0, y: 45.0 }\n  , { x: 40.0, y: 30.0 }\n  , { x: 55.0, y: 70.0 }\n  , { x: 70.0, y: 50.0 }\n  , { x: 85.0, y: 85.0 }\n  , { x: 100.0, y: 65.0 }\n  , { x: 115.0, y: 90.0 }\n  , { x: 130.0, y: 75.0 }\n  , { x: 145.0, y: 95.0 }\n  ]\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 600.0\n  , height: 400.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 40.0\n  , marginLeft: 50.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Scatter plot using declarative tree API\nscatterPlot :: Effect Unit\nscatterPlot = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n  let iWidth = innerWidth dims\n  let iHeight = innerHeight dims\n\n  -- Calculate data extents\n  let xValues = map _.x scatterData\n  let yValues = map _.y scatterData\n  let minX = fromMaybe 0.0 $ minimum xValues\n  let maxX = fromMaybe 100.0 $ maximum xValues\n  let minY = fromMaybe 0.0 $ minimum yValues\n  let maxY = fromMaybe 100.0 $ maximum yValues\n\n  -- Simple linear scale functions\n  let xScale val = ((val - minX) / (maxX - minX)) * iWidth\n  let yScale val = iHeight - ((val - minY) / (maxY - minY)) * iHeight\n\n  -- Define the tree structure\n  let tree :: Tree Point\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num dims.width\n          , height $ num dims.height\n          , viewBox 0.0 0.0 dims.width dims.height\n          , attr \"class\" $ text \"scatter-plot-tree\"\n          ]\n          `T.withChild`\n            (T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"chart-content\"\n              , transform $ text (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\")\n              ]\n              `T.withChild`\n                -- Data join for points\n                (joinData \"points\" \"circle\" scatterData $ \\point ->\n                  T.elem Circle\n                    [ cx $ num (xScale point.x)\n                    , cy $ num (yScale point.y)\n                    , r $ num 6.0\n                    , fill $ text \"#e74c3c\"\n                    , opacity $ num 0.7\n                    , attr \"class\" $ text \"point\"\n                    ]\n                ))\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Scatter Plot (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (length scatterData) <> \" points\"\n\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"chartGroup\" selections of\n      Just _ -> Console.log \"✓ Chart group created\"\n      Nothing -> Console.log \"✗ Missing chart group\"\n\n    case Map.lookup \"points\" selections of\n      Just _ -> Console.log \"✓ Points collection created\"\n      Nothing -> Console.log \"✗ Missing points collection\"\n\n    Console.log \"\"\n    Console.log \"Expected: 10 red circles showing scatter pattern\"\n"

snippet_lineChart_content :: String
snippet_lineChart_content = "module D3.Viz.TreeAPI.LineChartExample where\n\nimport Prelude\n\nimport Data.Array (length, mapWithIndex, range)\nimport Data.Foldable (maximum, minimum)\nimport Data.Int as Int\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.String (joinWith)\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, fill, stroke, strokeWidth, transform, path)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Data point\ntype Point = { x :: Number, y :: Number }\n\n-- | Sample line data (sine wave)\nlineData :: Array Point\nlineData = mapWithIndex (\\i _ ->\n  let x = (Int.toNumber i) * 0.1\n      y = sin(x * pi) * 50.0 + 50.0\n  in { x, y }\n) (range 0 62)\n\n-- FFI for Math functions\nforeign import sin :: Number -> Number\nforeign import pi :: Number\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 600.0\n  , height: 300.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 40.0\n  , marginLeft: 50.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Generate SVG path data string from points\npointsToPath :: Dimensions -> Array Point -> Number -> Number -> Number -> Number -> String\npointsToPath dims points minX maxX minY maxY =\n  let iWidth = innerWidth dims\n      iHeight = innerHeight dims\n      xScale val = ((val - minX) / (maxX - minX)) * iWidth\n      yScale val = iHeight - ((val - minY) / (maxY - minY)) * iHeight\n\n      toCommand :: Int -> Point -> String\n      toCommand 0 p = \"M \" <> show (xScale p.x) <> \" \" <> show (yScale p.y)\n      toCommand _ p = \"L \" <> show (xScale p.x) <> \" \" <> show (yScale p.y)\n  in\n    joinWith \" \" (mapWithIndex toCommand points)\n\n-- | Line chart using declarative tree API\nlineChart :: Effect Unit\nlineChart = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n\n  -- Calculate data extents\n  let xValues = map _.x lineData\n  let yValues = map _.y lineData\n  let minX = fromMaybe 0.0 $ minimum xValues\n  let maxX = fromMaybe 10.0 $ maximum xValues\n  let minY = fromMaybe 0.0 $ minimum yValues\n  let maxY = fromMaybe 100.0 $ maximum yValues\n\n  -- Generate path data\n  let pathData = pointsToPath dims lineData minX maxX minY maxY\n\n  -- Define the tree structure\n  let tree :: Tree Unit\n      tree =\n        T.named SVG \"svg\"\n          [ width $ num dims.width\n          , height $ num dims.height\n          , viewBox 0.0 0.0 dims.width dims.height\n          , attr \"class\" $ text \"line-chart-tree\"\n          ]\n          `T.withChild`\n            (T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"chart-content\"\n              , transform $ text (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\")\n              ]\n              `T.withChild`\n                -- Single path element for the line\n                (T.named Path \"line\"\n                  [ path $ text pathData\n                  , fill $ text \"none\"\n                  , stroke $ text \"#2ecc71\"\n                  , strokeWidth $ num 2.0\n                  , attr \"class\" $ text \"line\"\n                  ]\n                ))\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Line Chart (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered line with \" <> show (length lineData) <> \" points\"\n\n    case Map.lookup \"svg\" selections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n    case Map.lookup \"chartGroup\" selections of\n      Just _ -> Console.log \"✓ Chart group created\"\n      Nothing -> Console.log \"✗ Missing chart group\"\n\n    case Map.lookup \"line\" selections of\n      Just _ -> Console.log \"✓ Line path created\"\n      Nothing -> Console.log \"✗ Missing line path\"\n\n    Console.log \"\"\n    Console.log \"Expected: Green sine wave curve\"\n"

snippet_groupedBarChart_content :: String
snippet_groupedBarChart_content = "module D3.Viz.TreeAPI.GroupedBarChartExample where\n\nimport Prelude\n\nimport Data.Array (filter, findIndex, nub)\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.Foldable (maximum)\nimport Data.Int as Int\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number as Number\nimport Data.String (Pattern(..), split, trim)\nimport Effect (Effect)\nimport Effect.Aff (Aff, launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (DataFile(..), loadDataFile, parseCSVRow)\nimport PSD3.Expr.Integration (v3Attr, v3AttrStr, v3AttrFn, v3AttrFnStr)\nimport PSD3.Expr.Expr (lit, str)\nimport PSD3.Axis.Axis (axisBottom, axisLeft, renderAxis, Scale)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Grouped Bar Chart Data (State population by age group)\ntype GroupedBarData =\n  { state :: String\n  , age :: String\n  , population :: Number\n  }\n\n-- | Parse CSV row into population data\n-- | CSV format: State,Under 5 Years,5 to 13 Years,14 to 17 Years,18 to 24 Years,25 to 44 Years,45 to 64 Years,65 Years and Over\n-- | Map to 9 age categories: <10, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70-79, ≥80\nparsePopulationRow :: String -> Array GroupedBarData\nparsePopulationRow line =\n  case parseCSVRow line of\n    [ state, under5Str, age5to13Str, age14to17Str, age18to24Str, age25to44Str, age45to64Str, age65plusStr ] -> do\n      let\n        under5 = fromMaybe 0.0 $ Number.fromString (trim under5Str)\n        age5to13 = fromMaybe 0.0 $ Number.fromString (trim age5to13Str)\n        age14to17 = fromMaybe 0.0 $ Number.fromString (trim age14to17Str)\n        age18to24 = fromMaybe 0.0 $ Number.fromString (trim age18to24Str)\n        age25to44 = fromMaybe 0.0 $ Number.fromString (trim age25to44Str)\n        age45to64 = fromMaybe 0.0 $ Number.fromString (trim age45to64Str)\n        age65plus = fromMaybe 0.0 $ Number.fromString (trim age65plusStr)\n      [ { state: trim state, age: \"<10\", population: under5 + age5to13 * 0.5 }\n      , { state: trim state, age: \"10-19\", population: age5to13 * 0.5 + age14to17 }\n      , { state: trim state, age: \"20-29\", population: age18to24 + age25to44 * 0.25 }\n      , { state: trim state, age: \"30-39\", population: age25to44 * 0.5 }\n      , { state: trim state, age: \"40-49\", population: age25to44 * 0.25 }\n      , { state: trim state, age: \"50-59\", population: age45to64 * 0.6 }\n      , { state: trim state, age: \"60-69\", population: age45to64 * 0.4 }\n      , { state: trim state, age: \"70-79\", population: age65plus * 0.6 }\n      , { state: trim state, age: \"≥80\", population: age65plus * 0.4 }\n      ]\n    _ -> []\n\n-- | Load population data from CSV\nloadPopulationData :: Aff (Array GroupedBarData)\nloadPopulationData = do\n  result <- loadDataFile USPopulationStateAgeCSV\n  case result of\n    Left err -> do\n      liftEffect $ Console.log $ \"Failed to load population data: \" <> err\n      pure []\n    Right body -> do\n      let lines = split (Pattern \"\\n\") body\n      let dataLines = Array.drop 1 lines -- Skip header\n      let parsed = Array.concatMap parsePopulationRow dataLines\n      liftEffect $ Console.log $ \"Loaded \" <> show (Array.length parsed) <> \" population data points\"\n      pure parsed\n\n-- | Chart dimensions\ntype Dimensions =\n  { width :: Number\n  , height :: Number\n  , marginTop :: Number\n  , marginRight :: Number\n  , marginBottom :: Number\n  , marginLeft :: Number\n  }\n\ndefaultDims :: Dimensions\ndefaultDims =\n  { width: 800.0\n  , height: 500.0\n  , marginTop: 20.0\n  , marginRight: 20.0\n  , marginBottom: 60.0\n  , marginLeft: 60.0\n  }\n\ninnerWidth :: Dimensions -> Number\ninnerWidth dims = dims.width - dims.marginLeft - dims.marginRight\n\ninnerHeight :: Dimensions -> Number\ninnerHeight dims = dims.height - dims.marginTop - dims.marginBottom\n\n-- | Group data by state\ntype StateGroup = { state :: String, bars :: Array GroupedBarData }\n\ngroupByState :: Array GroupedBarData -> Array StateGroup\ngroupByState data' =\n  let\n    states = nub $ map _.state data'\n    getStateData st = filter (\\d -> d.state == st) data'\n  in\n    map (\\st -> { state: st, bars: getStateData st }) states\n\n-- | Get all unique age groups\ngetAges :: Array GroupedBarData -> Array String\ngetAges = nub <<< map _.age\n\n-- | Color scale for age groups\ncolorForAge :: String -> String\ncolorForAge \"<10\" = \"#e8384f\"\ncolorForAge \"10-19\" = \"#fd612c\"\ncolorForAge \"20-29\" = \"#fd8d3c\"\ncolorForAge \"30-39\" = \"#feb078\"\ncolorForAge \"40-49\" = \"#ffe0b3\"\ncolorForAge \"50-59\" = \"#d7eaf3\"\ncolorForAge \"60-69\" = \"#abd9e9\"\ncolorForAge \"70-79\" = \"#74add1\"\ncolorForAge \"≥80\" = \"#4575b4\"\ncolorForAge _ = \"#999\"\n\n-- | Grouped bar chart using Tree API\n-- |\n-- | This demonstrates:\n-- | - Nested joins: states → bars within each state\n-- | - Multiple data series with color encoding\n-- | - Axes with proper scales\n-- | Draw grouped bar chart with loaded data\ndrawGroupedBarChart :: String -> Array GroupedBarData -> Effect Unit\ndrawGroupedBarChart selector populationData = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let dims = defaultDims\n  let iWidth = innerWidth dims\n  let iHeight = innerHeight dims\n\n  -- Group data by state\n  let stateGroups = groupByState populationData\n  let ages = getAges populationData\n  let numStates = Array.length stateGroups\n  let numAges = Array.length ages\n\n  -- Calculate bar dimensions\n  let groupWidth = iWidth / Int.toNumber numStates\n  let barWidth = groupWidth / Int.toNumber numAges * 0.9\n\n  -- Calculate scales\n  let populationValues = map _.population populationData\n  let maxPop = fromMaybe 6000000.0 $ maximum populationValues\n\n  -- X scale maps state index to position\n  let\n    xScale :: Scale\n    xScale =\n      { domain: { min: 0.0, max: Int.toNumber numStates }\n      , range: { min: 0.0, max: iWidth }\n      }\n\n  -- Y scale maps population to height\n  let\n    yScale :: Scale\n    yScale =\n      { domain: { min: 0.0, max: maxPop }\n      , range: { min: iHeight, max: 0.0 }\n      }\n\n  -- Create axes\n  let xAxis = axisBottom xScale\n  let yAxis = axisLeft yScale\n\n  -- First tree: SVG container with axes\n  let\n    axesTree :: T.Tree Unit\n    axesTree =\n      T.named SVG \"svg\"\n        [ v3Attr \"width\" (lit dims.width)\n        , v3Attr \"height\" (lit dims.height)\n        , v3AttrStr \"viewBox\" (str (\"0 0 \" <> show dims.width <> \" \" <> show dims.height))\n        , v3AttrStr \"class\" (str \"grouped-bar-chart\")\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ v3AttrStr \"class\" (str \"chart-content\")\n              , v3AttrStr \"transform\" (str (\"translate(\" <> show dims.marginLeft <> \",\" <> show dims.marginTop <> \")\"))\n              ]\n              `T.withChildren`\n                [ -- X axis\n                  T.named Group \"xAxis\"\n                    [ v3AttrStr \"transform\" (str (\"translate(0,\" <> show iHeight <> \")\"))\n                    , v3AttrStr \"class\" (str \"x-axis\")\n                    ]\n                    `T.withChild`\n                      renderAxis xAxis\n                , -- Y axis\n                  T.named Group \"yAxis\"\n                    [ v3AttrStr \"class\" (str \"y-axis\")\n                    ]\n                    `T.withChild`\n                      renderAxis yAxis\n                ]\n          )\n\n  -- Render axes\n  axesSelections <- renderTree container axesTree\n\n  -- Second tree: Grouped bars\n  -- Extract the chartGroup selection for the second render\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" axesSelections\n\n  -- Use nestedJoin to create state groups → bars\n  let\n    barsTree :: T.Tree StateGroup\n    barsTree =\n      T.nestedJoin \"stateGroups\" \"g\" stateGroups (_.bars) $ \\bar ->\n        -- bar :: GroupedBarData\n        -- Calculate position for this bar\n        let\n          -- Find which state this bar belongs to\n          stateIdx = fromMaybe 0 $ findIndex (\\g -> g.state == bar.state) stateGroups\n          -- Find which age group this is\n          ageIdx = fromMaybe 0 $ findIndex (\\a -> a == bar.age) ages\n\n          -- X position: state position + age offset\n          xPos = Int.toNumber stateIdx * groupWidth + Int.toNumber ageIdx * barWidth\n\n          -- Y position and height from population\n          yPos = iHeight - ((bar.population / maxPop) * iHeight)\n          barHeight = (bar.population / maxPop) * iHeight\n        in\n          T.elem Rect\n            [ v3Attr \"x\" (lit xPos)\n            , v3Attr \"y\" (lit yPos)\n            , v3Attr \"width\" (lit barWidth)\n            , v3Attr \"height\" (lit barHeight)\n            , v3AttrStr \"fill\" (str (colorForAge bar.age))\n            , v3AttrStr \"class\" (str \"bar\")\n            ]\n\n  -- Render bars\n  barsSelections <- renderTree chartGroupSel barsTree\n\n  liftEffect do\n    Console.log \"=== Grouped Bar Chart (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (Array.length populationData) <> \" bars in \"\n      <> show numStates\n      <> \" groups\"\n\n    case Map.lookup \"svg\" axesSelections of\n      Just _ -> Console.log \"✓ SVG created\"\n      Nothing -> Console.log \"✗ Missing SVG\"\n\n-- | Main entry point - loads data then renders\ngroupedBarChart :: String -> Effect Unit\ngroupedBarChart selector = launchAff_ do\n  populationData <- loadPopulationData\n  liftEffect $ drawGroupedBarChart selector populationData\n"

snippet_treeViz_content :: String
snippet_treeViz_content = "module D3.Viz.TreeAPI.TreeViz where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Control.Comonad.Cofree (head, tail)\nimport Data.Tree (Tree, mkTree)\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Shared.Data (loadFlareData)\nimport DataViz.Layout.Hierarchy.Tree (tree, defaultTreeConfig)\nimport PSD3.Expr.Friendly (num, text, attr, viewBox, width, height, cx, cy, r, x, y, fill, stroke, strokeWidth, fontSize, textAnchor, textContent, path)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_, reselectD3v2)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Hierarchy node type (matches loadFlareData output)\ntype HierNode = { name :: String, value :: Number, x :: Number, y :: Number, depth :: Int, height :: Int }\n\n-- | Link data type\ntype LinkDatum = { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n\n-- | Create links from parent to children\nmakeLinks\n  :: forall r\n   . Tree { x :: Number, y :: Number | r }\n  -> Array { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\nmakeLinks tree' = Array.fromFoldable $ makeLinksList tree'\n  where\n  makeLinksList\n    :: Tree { x :: Number, y :: Number | r }\n    -> List { source :: { x :: Number, y :: Number }, target :: { x :: Number, y :: Number } }\n  makeLinksList t =\n    let\n      val = head t\n      children = tail t\n      childLinks = children >>= \\child ->\n        let childVal = head child\n        in Cons { source: { x: val.x, y: val.y }, target: { x: childVal.x, y: childVal.y } } Nil\n      grandchildLinks = children >>= makeLinksList\n    in\n      childLinks <> grandchildLinks\n\n-- | Link path generator (curved links)\nlinkPath :: Number -> Number -> Number -> Number -> String\nlinkPath x1' y1' x2' y2' =\n  \"M\" <> show x1' <> \",\" <> show y1'\n    <> \"C\"\n    <> show x1'\n    <> \",\"\n    <> show ((y1' + y2') / 2.0)\n    <> \" \"\n    <> show x2'\n    <> \",\"\n    <> show ((y1' + y2') / 2.0)\n    <> \" \"\n    <> show x2'\n    <> \",\"\n    <> show y2'\n\n-- | Draw tree hierarchy with loaded data\ndrawTree :: String -> Tree HierNode -> Effect Unit\ndrawTree selector flareTree = runD3v2M do\n  container <- select selector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  let chartWidth = 800.0\n  let chartHeight = 600.0\n  let padding = 40.0\n\n  -- Apply Tree layout\n  let\n    config = defaultTreeConfig\n      { size =\n          { width: chartWidth - (2.0 * padding)\n          , height: chartHeight - (2.0 * padding)\n          }\n      }\n  let positioned = tree config flareTree\n\n  -- Flatten to arrays\n  let nodes = Array.fromFoldable positioned\n  let links = makeLinks positioned\n\n  liftEffect $ Console.log $ \"Rendering \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n\n  -- First tree: SVG container with links (datum type: link data)\n  let\n    linksTree :: T.Tree LinkDatum\n    linksTree =\n      T.named SVG \"svg\"\n        [ width $ num chartWidth\n        , height $ num chartHeight\n        , viewBox 0.0 0.0 chartWidth chartHeight\n        , attr \"class\" $ text \"simple-hierarchy-tree\"\n        ]\n        `T.withChild`\n          ( T.named Group \"chartGroup\"\n              [ attr \"class\" $ text \"tree-content\" ]\n              `T.withChild`\n                ( T.named Group \"linksGroup\"\n                    [ attr \"class\" $ text \"links\" ]\n                    `T.withChild`\n                      ( T.joinData \"links\" \"path\" links $ \\link ->\n                          T.elem Path\n                            [ path $ text ( linkPath\n                                    (link.source.x + padding)\n                                    (link.source.y + padding)\n                                    (link.target.x + padding)\n                                    (link.target.y + padding)\n                                )\n                            , fill $ text \"none\"\n                            , stroke $ text \"#999\"\n                            , strokeWidth $ num 1.5\n                            , attr \"class\" $ text \"link\"\n                            ]\n                      )\n                )\n          )\n\n  -- Render links first (underlaying)\n  linksSelections <- renderTree container linksTree\n\n  -- Second tree: Nodes on top (datum type: HierNode)\n  -- Reselect the chartGroup from rendered selections (not global CSS selector!)\n  chartGroupSel <- liftEffect $ reselectD3v2 \"chartGroup\" linksSelections\n\n  let\n    nodesTree :: T.Tree HierNode\n    nodesTree =\n      T.named Group \"nodesGroup\"\n        [ attr \"class\" $ text \"nodes\" ]\n        `T.withChild`\n          ( T.joinData \"nodeGroups\" \"g\" nodes $ \\node ->\n              T.named Group (\"node-\" <> node.name)\n                [ attr \"class\" $ text \"node\" ]\n                `T.withChildren`\n                  [ T.elem Circle\n                      [ cx $ num (node.x + padding)\n                      , cy $ num (node.y + padding)\n                      , r $ num 6.0\n                      , fill $ text \"#69b3a2\"\n                      , stroke $ text \"#fff\"\n                      , strokeWidth $ num 2.0\n                      ]\n                  , T.elem Text\n                      [ x $ num (node.x + padding + 10.0)\n                      , y $ num (node.y + padding + 4.0)\n                      , textContent $ text node.name\n                      , fontSize $ num 12.0\n                      , textAnchor $ text \"start\"\n                      ]\n                  ]\n          )\n\n  -- Render nodes on top (overlaying)\n  nodesSelections <- renderTree chartGroupSel nodesTree\n\n  liftEffect do\n    Console.log \"=== Tree Layout (Tree API) ===\"\n    Console.log \"\"\n    Console.log $ \"Rendered \" <> show (Array.length nodes) <> \" nodes, \" <> show (Array.length links) <> \" links\"\n    Console.log \"Flare visualization toolkit hierarchy\"\n    Console.log \"\"\n\n-- | Main entry point - loads Flare data then renders\ntreeViz :: String -> Effect Unit\ntreeViz selector = launchAff_ do\n  result <- loadFlareData\n  case result of\n    Left err -> liftEffect $ Console.log $ \"Failed to load Flare data: \" <> err\n    Right flareTree -> liftEffect $ drawTree selector flareTree\n"

snippet_threeLittleDimensions_content :: String
snippet_threeLittleDimensions_content = "module D3.Viz.TreeAPI.ThreeLittleDimensionsExample where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport PSD3.Expr.Integration (v3AttrStr)\nimport PSD3.Expr.Expr (str)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- | Nested data structure: array of arrays\ntype Matrix = Array (Array Int)\n\n-- | Sample 3x3 matrix\nmatrixData :: Matrix\nmatrixData = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\n\n-- | Three Little Dimensions using declarative tree API\n-- | This demonstrates nested data joins: outer array → rows, inner arrays → cells\nthreeLittleDimensions :: Effect Unit\nthreeLittleDimensions = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- The challenge: how to represent nested decomposition in a tree?\n  -- Outer datum type: Array Int (a row)\n  -- Inner datum type: Int (a cell value)\n\n  -- Approach: Use nestedJoin to handle datum type decomposition\n  -- Outer type: Array Int (a row)\n  -- Inner type: Int (a cell value)\n  let\n    tree :: T.Tree (Array Int)\n    tree =\n      T.named Table \"table\"\n        [ v3AttrStr \"class\" (str \"nested-data-table\") ]\n        `T.withChild`\n          -- nestedJoin handles the type change from Array Int → Int\n          -- identity is the decomposer: it just returns the row data as-is\n          ( T.nestedJoin \"rows\" \"tr\" matrixData identity $ \\cellValue ->\n              -- cellValue :: Int (decomposed from Array Int)\n              T.elem Td\n                [ v3AttrStr \"class\" (str \"table-cell\")\n                , v3AttrStr \"textContent\" (str (show cellValue))\n                ]\n          )\n\n  -- Render the tree\n  selections <- renderTree container tree\n\n  liftEffect do\n    Console.log \"=== Three Little Dimensions (Tree API) ===\"\n    Console.log \"\"\n\n    case Map.lookup \"table\" selections of\n      Just _ -> Console.log \"✓ Table created\"\n      Nothing -> Console.log \"✗ Missing table\"\n\n    case Map.lookup \"rows\" selections of\n      Just _ -> Console.log $ \"✓ Rows created (\" <> show (Array.length matrixData) <> \")\"\n      Nothing -> Console.log \"✗ Missing rows\"\n\n    case Map.lookup \"cells\" selections of\n      Just _ ->\n        let\n          totalCells = Array.foldl (\\acc row -> acc + Array.length row) 0 matrixData\n        in\n          Console.log $ \"✓ Cells created (\" <> show totalCells <> \" total)\"\n      Nothing -> Console.log \"✗ Missing cells\"\n\n    Console.log \"\"\n    Console.log \"Expected: 3x3 table with numbers 1-9\"\n"

snippet_v3Parabola_content :: String
snippet_v3Parabola_content = "-- | Expression DSL Parabola Demo - Live Browser Rendering\n-- |\n-- | This demonstrates the v3 \"Finally Tagless\" DSL rendering to actual DOM via D3.\n-- |\n-- | The same polymorphic expressions produce:\n-- |   - Runtime values for D3 (EvalD)\n-- |   - Source code for display (CodeGen)\n-- |   - SVG strings for server-side (SVGD) - not shown here\n-- |\n-- | This is the \"money shot\" - same expression, three different outputs!\nmodule D3.Viz.TreeAPI.V3ParabolaDemo where\n\nimport Prelude hiding (add)\n\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\n\n-- v2 infrastructure for D3 rendering\nimport PSD3.Expr.Integration (v3Attr, v3AttrStr, v3AttrFn, v3AttrFnStr)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL imports\nimport PSD3.Expr.Expr (class NumExpr, lit, add, str)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((*:), (+:))\nimport PSD3.Expr.Interpreter.CodeGen (CodeGen, runCodeGen)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- =============================================================================\n-- Data Type\n-- =============================================================================\n\ntype ParabolaPoint = { x :: Number, y :: Number }\n\ntype ParabolaRow = ( x :: Number, y :: Number )\n\n-- Sample data: y = x²\nparabolaData :: Array ParabolaPoint\nparabolaData =\n  [ { x: -10.0, y: 100.0 }\n  , { x: -7.5, y: 56.25 }\n  , { x: -5.0, y: 25.0 }\n  , { x: -2.5, y: 6.25 }\n  , { x: 0.0, y: 0.0 }\n  , { x: 2.5, y: 6.25 }\n  , { x: 5.0, y: 25.0 }\n  , { x: 7.5, y: 56.25 }\n  , { x: 10.0, y: 100.0 }\n  ]\n\n-- =============================================================================\n-- v3 Expressions (Polymorphic!)\n-- =============================================================================\n\n-- | Scale X coordinate: (x + 5) * 30 + 50\n-- |\n-- | This expression is polymorphic over ANY repr that implements the typeclasses.\n-- | It can produce: Number (EvalD), String (CodeGen), String (SVGD)\nscaleX :: forall repr. NumExpr repr => DatumExpr repr ParabolaRow => repr Number\nscaleX = (xField +: 5.0) *: 30.0 +: 50.0\n  where\n    xField = field (Proxy :: Proxy \"x\")\n\n-- | Scale Y coordinate: 200 - (y * 1.8)\nscaleY :: forall repr. NumExpr repr => DatumExpr repr ParabolaRow => repr Number\nscaleY = add (lit 200.0) (yField *: (-1.8))\n  where\n    yField = field (Proxy :: Proxy \"y\")\n\n-- | Point radius based on distance from origin\n-- | Larger radius for points near the vertex\npointRadius :: forall repr. NumExpr repr => DatumExpr repr ParabolaRow => repr Number\npointRadius = add (lit 6.0) (yField *: (-0.05))\n  where\n    yField = field (Proxy :: Proxy \"y\")\n\n-- =============================================================================\n-- v3→v2 Integration: Evaluate expressions with datum\n-- =============================================================================\n\n-- | Evaluate a v3 expression with a datum to get a concrete value\n-- | This bridges v3 polymorphic expressions → v2 static attributes\nevalExpr :: forall a. EvalD ParabolaPoint a -> ParabolaPoint -> a\nevalExpr expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- Browser Demo\n-- =============================================================================\n\nv3ParabolaDemo :: Effect Unit\nv3ParabolaDemo = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Define the visualization tree using v3 expressions\n  -- The template callback receives each datum, we evaluate v3 expressions with it\n  let tree :: Tree ParabolaPoint\n      tree =\n        T.named SVG \"svg\"\n          [ v3Attr \"width\" (lit 400.0)\n          , v3Attr \"height\" (lit 250.0)\n          , v3AttrStr \"viewBox\" (str \"0 0 400 250\")\n          , v3AttrStr \"id\" (str \"v3-parabola-svg\")\n          , v3AttrStr \"class\" (str \"v3-demo\")\n          ]\n          `T.withChild`\n            (T.joinData \"points\" \"circle\" parabolaData $ \\d ->\n              -- v3 expressions are evaluated with datum → static v2 attributes\n              T.elem Circle\n                [ v3Attr \"cx\" (lit (evalExpr scaleX d))       -- v3 expression evaluated!\n                , v3Attr \"cy\" (lit (evalExpr scaleY d))       -- v3 expression evaluated!\n                , v3Attr \"r\" (lit (evalExpr pointRadius d))  -- v3 expression evaluated!\n                , v3AttrStr \"fill\" (str \"#3498db\")\n                , v3AttrStr \"stroke\" (str \"white\")\n                , v3Attr \"stroke-width\" (lit 2.0)\n                ])\n\n  -- Render to DOM via D3!\n  selections <- renderTree container tree\n\n  -- Log the \"money shot\" - same expressions, different outputs\n  liftEffect do\n    Console.log \"=== Expression DSL Parabola Demo: Live D3 Rendering ===\"\n    Console.log \"\"\n    Console.log \"v3 Expressions (polymorphic definitions):\"\n    Console.log \"  scaleX = (x + 5) * 30 + 50\"\n    Console.log \"  scaleY = 200 + (y * -1.8)\"\n    Console.log \"\"\n    Console.log \"CodeGen output (PureScript source):\"\n    Console.log $ \"  scaleX → \" <> runCodeGen (scaleX :: CodeGen Number)\n    Console.log $ \"  scaleY → \" <> runCodeGen (scaleY :: CodeGen Number)\n    Console.log \"\"\n    Console.log \"EvalD output (D3 runtime values for sample point):\"\n    let pt = { x: -10.0, y: 100.0 }  -- Sample point\n    let cxVal = runEvalD scaleX pt 0\n    let cyVal = runEvalD scaleY pt 0\n    Console.log $ \"  { x: \" <> show pt.x <> \", y: \" <> show pt.y <> \" } → cx=\" <> show cxVal <> \", cy=\" <> show cyVal\n    Console.log \"\"\n    Console.log \"Same expression, three outputs:\"\n    Console.log \"  • CodeGen: produces PureScript source code\"\n    Console.log \"  • EvalD: produces runtime Number values for D3\"\n    Console.log \"  • SVGD: produces SVG attribute strings (server-side)\"\n    Console.log \"\"\n\n    case Map.lookup \"points\" selections of\n      Just _ -> Console.log \"✓ Points rendered to DOM via D3 (check browser!)\"\n      Nothing -> Console.log \"✗ No points selection found\"\n"

snippet_v3Transition_content :: String
snippet_v3Transition_content = "-- | Expression Transition Demo - Declarative Transitions with v3 Expressions\n-- |\n-- | This demonstrates the fully declarative approach to transitions:\n-- | - sceneJoin defines enter behavior with initial state + transition\n-- | - Template defines final state using v3 expressions\n-- | - No Map lookup, no unsafeCoerce - type flows through the tree\n-- |\n-- | Key insight: Transitions belong IN the tree structure, not after it.\n-- | This keeps the datum type chain intact.\nmodule D3.Viz.TreeAPI.V3TransitionDemo where\n\nimport Prelude hiding (add)\n\nimport Data.Maybe (Maybe(..))\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\n\n-- v2 infrastructure\nimport PSD3.Expr.Integration (v3Attr, v3AttrStr, v3AttrFn, v3AttrFnStr)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.Internal.Transition.Types (staggeredTransition)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL\nimport PSD3.Expr.Expr (class NumExpr, lit, str)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((*:), (+:))\nimport PSD3.Expr.Interpreter.CodeGen (CodeGen, runCodeGen)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- =============================================================================\n-- Data Type\n-- =============================================================================\n\ntype CircleData =\n  { id :: Int\n  , x :: Number -- X position\n  , y :: Number -- Y position\n  , value :: Number -- 0 to 100 (affects radius and color)\n  }\n\ntype CircleRow = (id :: Int, x :: Number, y :: Number, value :: Number)\n\n-- Circle data with positions spread out\ncircleData :: Array CircleData\ncircleData =\n  [ { id: 1, x: 80.0, y: 80.0, value: 30.0 }\n  , { id: 2, x: 160.0, y: 220.0, value: 60.0 }\n  , { id: 3, x: 250.0, y: 60.0, value: 90.0 }\n  , { id: 4, x: 340.0, y: 200.0, value: 45.0 }\n  , { id: 5, x: 420.0, y: 100.0, value: 75.0 }\n  ]\n\n-- =============================================================================\n-- v3 Expressions (Polymorphic!)\n-- =============================================================================\n\n-- | X position from datum\nposX :: forall repr. NumExpr repr => DatumExpr repr CircleRow => repr Number\nposX = field (Proxy :: Proxy \"x\")\n\n-- | Y position from datum\nposY :: forall repr. NumExpr repr => DatumExpr repr CircleRow => repr Number\nposY = field (Proxy :: Proxy \"y\")\n\n-- | Radius based on value: (value * 0.2) + 8\n-- | Higher values = larger circles\ncircleRadius :: forall repr. NumExpr repr => DatumExpr repr CircleRow => repr Number\ncircleRadius = valueField *: 0.2 +: 8.0\n  where\n  valueField = field (Proxy :: Proxy \"value\")\n\n-- =============================================================================\n-- v3→v2 Integration\n-- =============================================================================\n\n-- | Evaluate v3 expression with datum (for templates)\nevalExpr :: forall a. EvalD CircleData a -> CircleData -> a\nevalExpr expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- Browser Demo\n-- =============================================================================\n\nv3TransitionDemo :: Effect Unit\nv3TransitionDemo = runD3v2M do\n  container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Fully declarative tree with transitions INSIDE the structure\n  -- No Map lookup needed - type flows through the entire tree\n  let\n    tree :: Tree CircleData\n    tree =\n      T.named SVG \"svg\"\n        [ v3Attr \"width\" (lit 500.0)\n        , v3Attr \"height\" (lit 300.0)\n        , v3AttrStr \"viewBox\" (str \"0 0 500 300\")\n        , v3AttrStr \"id\" (str \"v3-transition-svg\")\n        , v3AttrStr \"class\" (str \"v3-demo\")\n        ]\n        `T.withChild`\n          -- sceneJoin: template = final state, enterBehavior = initial state + transition\n          ( T.sceneJoin \"circles\" \"circle\" circleData\n              -- Template defines FINAL state (where elements end up)\n              ( \\d -> T.elem Circle\n                  [ v3Attr \"cx\" (lit (evalExpr posX d)) -- v3: final X position\n                  , v3Attr \"cy\" (lit (evalExpr posY d)) -- v3: final Y position\n                  , v3Attr \"r\" (lit (evalExpr circleRadius d)) -- v3: radius from value\n                  , v3AttrStr \"fill\" (str \"#e67e22\") -- final color (orange)\n                  , v3AttrStr \"stroke\" (str \"white\")\n                  , v3Attr \"stroke-width\" (lit 2.0)\n                  ]\n              )\n              -- Behaviors: enter starts at center, transitions to final with stagger\n              { keyFn: Nothing  -- No updates in this demo\n              , enterBehavior: Just\n                  { initialAttrs:\n                      [ v3Attr \"cx\" (lit 250.0) -- start at center X\n                      , v3Attr \"cy\" (lit 150.0) -- start at center Y\n                      , v3AttrStr \"fill\" (str \"#3498db\") -- start color (blue)\n                      ]\n                  , transition: Just (staggeredTransition (Milliseconds 600.0) 100.0)\n                  -- Each element delays 100ms more than previous\n                  }\n              , updateBehavior: Nothing\n              , exitBehavior: Nothing\n              }\n          )\n\n  -- Log what we're demonstrating\n  liftEffect do\n    Console.log \"=== Expression Declarative Staggered Transition Demo ===\"\n    Console.log \"\"\n    Console.log \"v3 Expressions (final positions):\"\n    Console.log $ \"  posX         → \" <> runCodeGen (posX :: CodeGen Number)\n    Console.log $ \"  posY         → \" <> runCodeGen (posY :: CodeGen Number)\n    Console.log $ \"  circleRadius → \" <> runCodeGen (circleRadius :: CodeGen Number)\n    Console.log \"\"\n    Console.log \"Approach: Fully declarative with sceneJoin + staggeredTransition\"\n    Console.log \"  • Template defines final state (v3 expressions)\"\n    Console.log \"  • enterBehavior defines initial state + staggered transition\"\n    Console.log \"  • staggeredTransition: 600ms duration, 100ms stagger per element\"\n    Console.log \"  • No Map lookup, no unsafeCoerce - type flows through tree\"\n    Console.log \"\"\n\n  -- Render - transitions happen automatically!\n  _ <- renderTree container tree\n\n  liftEffect do\n    Console.log \"Staggered transition triggered by renderTree!\"\n    Console.log \"\"\n    Console.log \"Key insights:\"\n    Console.log \"  1. Transitions belong IN the tree structure\"\n    Console.log \"  2. staggerDelay in TransitionConfig handles per-element delays\"\n    Console.log \"  3. The datum type chain stays intact from definition to render\"\n"

snippet_v3GUP_content :: String
snippet_v3GUP_content = "-- | Expression DSL General Update Pattern Demo\n-- |\n-- | The classic D3 \"letters\" example reimagined with:\n-- | - v3 polymorphic expressions for computed attributes\n-- | - sceneJoin with declarative enter/update/exit behaviors\n-- | - Staggered transitions for visual appeal\n-- |\n-- | Data changes trigger the full GUP cycle:\n-- | - ENTER: New letters fade in from above\n-- | - UPDATE: Existing letters slide to new positions\n-- | - EXIT: Removed letters fade out and drop\nmodule D3.Viz.TreeAPI.V3GUPDemo\n  ( v3GUPDemo\n  , updateWithLetters\n  , initV3GUP\n  , LetterDatum\n  ) where\n\nimport Prelude hiding (add)\n\nimport Data.Array as Array\nimport Data.Int (toNumber)\nimport Data.Maybe (Maybe(..))\nimport Data.String.CodeUnits as SCU\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\nimport Effect.Console as Console\nimport Type.Proxy (Proxy(..))\n\n-- v2 infrastructure\nimport PSD3.Internal.Attribute (Attribute)\nimport PSD3.Expr.Friendly (num, text, attr, from, viewBox, width, height, x, y, fill, opacity, fontSize, textAnchor, dominantBaseline, textContent)\nimport PSD3.Internal.Capabilities.Selection (select, renderTree)\nimport PSD3.Interpreter.D3 (runD3v2M, D3v2Selection_)\nimport PSD3.Internal.Selection.Types (ElementType(..), SEmpty)\nimport PSD3.Internal.Transition.Types (Easing(..), transitionWith)\nimport PSD3.AST (Tree)\nimport PSD3.AST as T\nimport Web.DOM.Element (Element)\n\n-- v3 DSL\nimport PSD3.Expr.Expr (class NumExpr)\nimport PSD3.Expr.Datum (class DatumExpr, field)\nimport PSD3.Expr.Sugar ((*:), (+:))\nimport PSD3.Expr.Interpreter.CodeGen (CodeGen, runCodeGen)\nimport PSD3.Expr.Interpreter.Eval (EvalD, runEvalD)\n\n-- =============================================================================\n-- Data Type\n-- =============================================================================\n\n-- | Each letter has an index (for positioning) and the character\ntype LetterDatum =\n  { letter :: String\n  , index :: Number  -- Number for v3 expression compatibility\n  }\n\ntype LetterRow = (letter :: String, index :: Number)\n\n-- =============================================================================\n-- v3 Expressions (Polymorphic!)\n-- =============================================================================\n\n-- | X position based on index: index * 40 + 50\nletterX :: forall repr. NumExpr repr => DatumExpr repr LetterRow => repr Number\nletterX = indexField *: 40.0 +: 50.0\n  where\n    indexField = field (Proxy :: Proxy \"index\")\n\n-- | Y position (constant for update state)\nletterY :: Number\nletterY = 100.0\n\n-- =============================================================================\n-- v3 -> v2 Integration\n-- =============================================================================\n\n-- | Evaluate v3 expression with datum\nevalExpr :: forall a. EvalD LetterDatum a -> LetterDatum -> a\nevalExpr expr datum = runEvalD expr datum 0\n\n-- =============================================================================\n-- GUP Tree with Full Enter/Update/Exit\n-- =============================================================================\n\n-- | Create the GUP tree for letters\n-- |\n-- | ENTER: Letters start above (y=20), invisible, then fade in and drop to y=100\n-- | UPDATE: Letters slide horizontally to new positions\n-- | EXIT: Letters fade out and drop below (y=180)\ncreateLettersTree :: Array LetterDatum -> Tree LetterDatum\ncreateLettersTree letters =\n  T.sceneJoin \"letters\" \"text\" letters\n    -- Template: FINAL state for each letter (where they end up after enter/update)\n    (\\d -> T.elem Text\n      [ x $ num (evalExpr letterX d)   -- v3: computed X position\n      , y $ num letterY                -- Final Y position\n      , fontSize $ num 32.0\n      , textAnchor $ text \"middle\"\n      , dominantBaseline $ text \"middle\"\n      , fill $ text \"#2c3e50\"\n      , opacity $ num 1.0\n      -- The text content is set via a special TextContent attribute\n      , textContent $ text d.letter\n      ])\n    -- Behaviors for enter/update/exit\n    { keyFn: Just _.letter       -- Identity by letter, not by index!\n    , enterBehavior: Just\n        { initialAttrs:\n            [ y $ num 20.0              -- Start above\n            , opacity $ num 0.0         -- Start invisible\n            , fill $ text \"#27ae60\"      -- Green for entering\n            ]\n        , transition: Just $ transitionWith\n            { duration: Milliseconds 750.0\n            , delay: Nothing\n            , staggerDelay: Just 50.0  -- Stagger enter\n            , easing: Just BounceOut   -- Bouncy entrance!\n            }\n        }\n    , updateBehavior: Just\n        { attrs:\n            -- Update attributes (slide to new position)\n            [ from \"x\" (\\d' -> evalExpr letterX d')\n            , y $ num letterY\n            , fill $ text \"#2c3e50\"  -- Dark for stable\n            , opacity $ num 1.0\n            ]\n        , transition: Just $ transitionWith\n            { duration: Milliseconds 500.0\n            , delay: Nothing\n            , staggerDelay: Just 30.0  -- Stagger update\n            , easing: Just CubicInOut\n            }\n        }\n    , exitBehavior: Just\n        { attrs:\n            [ y $ num 180.0             -- Drop below\n            , opacity $ num 0.0         -- Fade out\n            , fill $ text \"#e74c3c\"      -- Red for exiting\n            ]\n        , transition: Just $ transitionWith\n            { duration: Milliseconds 500.0\n            , delay: Nothing\n            , staggerDelay: Just 40.0  -- Stagger exit\n            , easing: Just CubicIn\n            }\n        }\n    }\n\n-- =============================================================================\n-- Public API\n-- =============================================================================\n\n-- | Initialize the GUP demo - creates SVG container and renders initial letters\nv3GUPDemo :: Effect Unit\nv3GUPDemo = do\n  Console.log \"=== Expression DSL General Update Pattern Demo ===\"\n  Console.log \"\"\n  Console.log \"v3 Expression for X position:\"\n  Console.log $ \"  letterX = \" <> runCodeGen (letterX :: CodeGen Number)\n  Console.log \"\"\n  Console.log \"Starting with: A B C D E F G\"\n  Console.log \"\"\n\n  -- Create the SVG container first\n  runD3v2M do\n    container <- select \"#viz\" :: _ (D3v2Selection_ SEmpty Element Unit)\n    let svgTree :: Tree Unit\n        svgTree =\n          T.named SVG \"svg\"\n            [ width $ num 600.0\n            , height $ num 200.0\n            , viewBox 0.0 0.0 600.0 200.0\n            , attr \"id\" $ text \"v3-gup-svg\"\n            , attr \"class\" $ text \"v3-gup-demo\"\n            ]\n            `T.withChild`\n              T.elem Group []  -- Empty group placeholder\n    _ <- renderTree container svgTree\n    pure unit\n\n  -- Initial render with ABCDEFG\n  updateWithLetters \"ABCDEFG\"\n\n-- | Update the visualization with a new set of letters\n-- |\n-- | This triggers the full GUP cycle:\n-- | - Letters not in old set: ENTER (fade in from above)\n-- | - Letters in both sets: UPDATE (slide to new position)\n-- | - Letters not in new set: EXIT (fade out and drop)\nupdateWithLetters :: String -> Effect Unit\nupdateWithLetters letterString = runD3v2M do\n  -- Select into the existing SVG (not #viz)\n  svg <- select \"#v3-gup-svg\" :: _ (D3v2Selection_ SEmpty Element Unit)\n\n  -- Convert string to array of LetterDatum with indices\n  let letters = Array.mapWithIndex\n        (\\i c -> { letter: SCU.singleton c, index: toNumber i })\n        (SCU.toCharArray letterString)\n\n  liftEffect $ Console.log $ \"Updating to: \" <> letterString <> \" (\" <> show (Array.length letters) <> \" letters)\"\n\n  -- Just the letters tree - renders INTO the existing SVG\n  let tree :: Tree LetterDatum\n      tree = createLettersTree letters\n\n  -- Render - sceneJoin handles enter/update/exit automatically!\n  _ <- renderTree svg tree\n\n  liftEffect do\n    Console.log \"GUP cycle complete!\"\n    Console.log \"  - New letters entered (green, bounced in from above)\"\n    Console.log \"  - Existing letters updated (slid to new positions)\"\n    Console.log \"  - Removed letters exited (red, faded and dropped)\"\n\n-- | Initialize the V3 GUP demo in a given container\n-- | Returns an update function that accepts an array of characters\n-- | Compatible with the GUPv2 API for drop-in replacement\ninitV3GUP :: String -> Effect (Array Char -> Effect Unit)\ninitV3GUP containerSelector = do\n  -- Create unique SVG ID based on selector\n  let svgId = \"v3-gup-svg-\" <> filterAlphaNum containerSelector\n      svgSelector = \"#\" <> svgId\n\n  -- Create the SVG container\n  runD3v2M do\n    container <- select containerSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n    let svgTree :: Tree Unit\n        svgTree =\n          T.named SVG \"svg\"\n            [ width $ num 800.0\n            , height $ num 500.0\n            , viewBox 0.0 (-50.0) 800.0 500.0\n            , attr \"id\" $ text svgId\n            , attr \"class\" $ text \"v3-gup-demo d3svg gup\"\n            ]\n            `T.withChild`\n              T.elem Group []  -- Empty group placeholder\n    _ <- renderTree container svgTree\n    pure unit\n\n  -- Return update function\n  pure \\letters -> runD3v2M do\n    svg <- select svgSelector :: _ (D3v2Selection_ SEmpty Element Unit)\n\n    -- Convert Char array to LetterDatum array with indices\n    let letterData = Array.mapWithIndex\n          (\\i c -> { letter: SCU.singleton c, index: toNumber i })\n          letters\n\n    -- Render the letters tree\n    let tree :: Tree LetterDatum\n        tree = createLettersTree letterData\n\n    _ <- renderTree svg tree\n    pure unit\n\n-- | Filter string to alphanumeric characters only (for ID generation)\nfilterAlphaNum :: String -> String\nfilterAlphaNum s = SCU.fromCharArray $ Array.filter isAlphaNum (SCU.toCharArray s)\n  where\n    isAlphaNum c =\n      (c >= 'a' && c <= 'z') ||\n      (c >= 'A' && c <= 'Z') ||\n      (c >= '0' && c <= '9')\n"

-- | Look up a snippet by name
getSnippet :: String -> String
getSnippet name = case name of
  "threeLittleCircles" -> snippet_threeLittleCircles_content
  "threeLittleCirclesTransition" -> snippet_threeLittleCirclesTransition_content
  "simpleTree" -> snippet_simpleTree_content
  "nestedElements" -> snippet_nestedElements_content
  "barChart" -> snippet_barChart_content
  "scatterPlot" -> snippet_scatterPlot_content
  "lineChart" -> snippet_lineChart_content
  "groupedBarChart" -> snippet_groupedBarChart_content
  "treeViz" -> snippet_treeViz_content
  "threeLittleDimensions" -> snippet_threeLittleDimensions_content
  "v3Parabola" -> snippet_v3Parabola_content
  "v3Transition" -> snippet_v3Transition_content
  "v3GUP" -> snippet_v3GUP_content
  _ -> "Snippet not found: " <> name

-- | Get snippet info by name
getSnippetInfo :: String -> SnippetInfo
getSnippetInfo name = case name of
  "threeLittleCircles" ->
    { name: "threeLittleCircles"
    , content: snippet_threeLittleCircles_content
    , source: "demo-website/src/Viz/TreeAPI/ThreeLittleCircles.purs"
    , lines: "1-88"
    }
  "threeLittleCirclesTransition" ->
    { name: "threeLittleCirclesTransition"
    , content: snippet_threeLittleCirclesTransition_content
    , source: "demo-website/src/Viz/TreeAPI/ThreeLittleCirclesTransition.purs"
    , lines: "1-163"
    }
  "simpleTree" ->
    { name: "simpleTree"
    , content: snippet_simpleTree_content
    , source: "demo-website/src/Viz/TreeAPI/SimpleTreeExample.purs"
    , lines: "1-66"
    }
  "nestedElements" ->
    { name: "nestedElements"
    , content: snippet_nestedElements_content
    , source: "demo-website/src/Viz/TreeAPI/NestedElementsExample.purs"
    , lines: "1-150"
    }
  "barChart" ->
    { name: "barChart"
    , content: snippet_barChart_content
    , source: "demo-website/src/Viz/TreeAPI/BarChartExample.purs"
    , lines: "1-192"
    }
  "scatterPlot" ->
    { name: "scatterPlot"
    , content: snippet_scatterPlot_content
    , source: "demo-website/src/Viz/TreeAPI/ScatterPlotExample.purs"
    , lines: "1-134"
    }
  "lineChart" ->
    { name: "lineChart"
    , content: snippet_lineChart_content
    , source: "demo-website/src/Viz/TreeAPI/LineChartExample.purs"
    , lines: "1-142"
    }
  "groupedBarChart" ->
    { name: "groupedBarChart"
    , content: snippet_groupedBarChart_content
    , source: "demo-website/src/Viz/TreeAPI/GroupedBarChartExample.purs"
    , lines: "1-267"
    }
  "treeViz" ->
    { name: "treeViz"
    , content: snippet_treeViz_content
    , source: "demo-website/src/Viz/TreeAPI/TreeViz.purs"
    , lines: "1-178"
    }
  "threeLittleDimensions" ->
    { name: "threeLittleDimensions"
    , content: snippet_threeLittleDimensions_content
    , source: "demo-website/src/Viz/TreeAPI/ThreeLittleDimensionsExample.purs"
    , lines: "1-80"
    }
  "v3Parabola" ->
    { name: "v3Parabola"
    , content: snippet_v3Parabola_content
    , source: "demo-website/src/Viz/TreeAPI/V3ParabolaDemo.purs"
    , lines: "1-156"
    }
  "v3Transition" ->
    { name: "v3Transition"
    , content: snippet_v3Transition_content
    , source: "demo-website/src/Viz/TreeAPI/V3TransitionDemo.purs"
    , lines: "1-163"
    }
  "v3GUP" ->
    { name: "v3GUP"
    , content: snippet_v3GUP_content
    , source: "demo-website/src/Viz/TreeAPI/V3GUPDemo.purs"
    , lines: "1-268"
    }
  _ ->
    { name: "not-found"
    , content: "Snippet not found: " <> name
    , source: ""
    , lines: "1-1"
    }
